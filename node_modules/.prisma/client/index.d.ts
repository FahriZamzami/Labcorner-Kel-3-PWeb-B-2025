
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model lab
 * 
 */
export type lab = $Result.DefaultSelection<Prisma.$labPayload>
/**
 * Model praktikum
 * 
 */
export type praktikum = $Result.DefaultSelection<Prisma.$praktikumPayload>
/**
 * Model pendaftaran
 * 
 */
export type pendaftaran = $Result.DefaultSelection<Prisma.$pendaftaranPayload>
/**
 * Model jadwal
 * 
 */
export type jadwal = $Result.DefaultSelection<Prisma.$jadwalPayload>
/**
 * Model modul
 * 
 */
export type modul = $Result.DefaultSelection<Prisma.$modulPayload>
/**
 * Model tugas
 * 
 */
export type tugas = $Result.DefaultSelection<Prisma.$tugasPayload>
/**
 * Model pengumpulan
 * 
 */
export type pengumpulan = $Result.DefaultSelection<Prisma.$pengumpulanPayload>
/**
 * Model pengumuman
 * 
 */
export type pengumuman = $Result.DefaultSelection<Prisma.$pengumumanPayload>
/**
 * Model absensi
 * 
 */
export type absensi = $Result.DefaultSelection<Prisma.$absensiPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Peran: {
  admin: 'admin',
  mahasiswa: 'mahasiswa',
  asisten: 'asisten'
};

export type Peran = (typeof Peran)[keyof typeof Peran]


export const StatusTugas: {
  open: 'open',
  close: 'close'
};

export type StatusTugas = (typeof StatusTugas)[keyof typeof StatusTugas]


export const StatusAbsensi: {
  Hadir: 'Hadir',
  Tidak_Hadir: 'Tidak_Hadir'
};

export type StatusAbsensi = (typeof StatusAbsensi)[keyof typeof StatusAbsensi]

}

export type Peran = $Enums.Peran

export const Peran: typeof $Enums.Peran

export type StatusTugas = $Enums.StatusTugas

export const StatusTugas: typeof $Enums.StatusTugas

export type StatusAbsensi = $Enums.StatusAbsensi

export const StatusAbsensi: typeof $Enums.StatusAbsensi

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lab`: Exposes CRUD operations for the **lab** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Labs
    * const labs = await prisma.lab.findMany()
    * ```
    */
  get lab(): Prisma.labDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.praktikum`: Exposes CRUD operations for the **praktikum** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Praktikums
    * const praktikums = await prisma.praktikum.findMany()
    * ```
    */
  get praktikum(): Prisma.praktikumDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pendaftaran`: Exposes CRUD operations for the **pendaftaran** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pendaftarans
    * const pendaftarans = await prisma.pendaftaran.findMany()
    * ```
    */
  get pendaftaran(): Prisma.pendaftaranDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jadwal`: Exposes CRUD operations for the **jadwal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jadwals
    * const jadwals = await prisma.jadwal.findMany()
    * ```
    */
  get jadwal(): Prisma.jadwalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modul`: Exposes CRUD operations for the **modul** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Moduls
    * const moduls = await prisma.modul.findMany()
    * ```
    */
  get modul(): Prisma.modulDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tugas`: Exposes CRUD operations for the **tugas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tugases
    * const tugases = await prisma.tugas.findMany()
    * ```
    */
  get tugas(): Prisma.tugasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pengumpulan`: Exposes CRUD operations for the **pengumpulan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pengumpulans
    * const pengumpulans = await prisma.pengumpulan.findMany()
    * ```
    */
  get pengumpulan(): Prisma.pengumpulanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pengumuman`: Exposes CRUD operations for the **pengumuman** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pengumumen
    * const pengumumen = await prisma.pengumuman.findMany()
    * ```
    */
  get pengumuman(): Prisma.pengumumanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.absensi`: Exposes CRUD operations for the **absensi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Absensis
    * const absensis = await prisma.absensi.findMany()
    * ```
    */
  get absensi(): Prisma.absensiDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    user: 'user',
    lab: 'lab',
    praktikum: 'praktikum',
    pendaftaran: 'pendaftaran',
    jadwal: 'jadwal',
    modul: 'modul',
    tugas: 'tugas',
    pengumpulan: 'pengumpulan',
    pengumuman: 'pengumuman',
    absensi: 'absensi'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "lab" | "praktikum" | "pendaftaran" | "jadwal" | "modul" | "tugas" | "pengumpulan" | "pengumuman" | "absensi"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      lab: {
        payload: Prisma.$labPayload<ExtArgs>
        fields: Prisma.labFieldRefs
        operations: {
          findUnique: {
            args: Prisma.labFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$labPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.labFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$labPayload>
          }
          findFirst: {
            args: Prisma.labFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$labPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.labFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$labPayload>
          }
          findMany: {
            args: Prisma.labFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$labPayload>[]
          }
          create: {
            args: Prisma.labCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$labPayload>
          }
          createMany: {
            args: Prisma.labCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.labDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$labPayload>
          }
          update: {
            args: Prisma.labUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$labPayload>
          }
          deleteMany: {
            args: Prisma.labDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.labUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.labUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$labPayload>
          }
          aggregate: {
            args: Prisma.LabAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLab>
          }
          groupBy: {
            args: Prisma.labGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabGroupByOutputType>[]
          }
          count: {
            args: Prisma.labCountArgs<ExtArgs>
            result: $Utils.Optional<LabCountAggregateOutputType> | number
          }
        }
      }
      praktikum: {
        payload: Prisma.$praktikumPayload<ExtArgs>
        fields: Prisma.praktikumFieldRefs
        operations: {
          findUnique: {
            args: Prisma.praktikumFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praktikumPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.praktikumFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praktikumPayload>
          }
          findFirst: {
            args: Prisma.praktikumFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praktikumPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.praktikumFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praktikumPayload>
          }
          findMany: {
            args: Prisma.praktikumFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praktikumPayload>[]
          }
          create: {
            args: Prisma.praktikumCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praktikumPayload>
          }
          createMany: {
            args: Prisma.praktikumCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.praktikumDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praktikumPayload>
          }
          update: {
            args: Prisma.praktikumUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praktikumPayload>
          }
          deleteMany: {
            args: Prisma.praktikumDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.praktikumUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.praktikumUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praktikumPayload>
          }
          aggregate: {
            args: Prisma.PraktikumAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePraktikum>
          }
          groupBy: {
            args: Prisma.praktikumGroupByArgs<ExtArgs>
            result: $Utils.Optional<PraktikumGroupByOutputType>[]
          }
          count: {
            args: Prisma.praktikumCountArgs<ExtArgs>
            result: $Utils.Optional<PraktikumCountAggregateOutputType> | number
          }
        }
      }
      pendaftaran: {
        payload: Prisma.$pendaftaranPayload<ExtArgs>
        fields: Prisma.pendaftaranFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pendaftaranFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pendaftaranPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pendaftaranFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pendaftaranPayload>
          }
          findFirst: {
            args: Prisma.pendaftaranFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pendaftaranPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pendaftaranFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pendaftaranPayload>
          }
          findMany: {
            args: Prisma.pendaftaranFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pendaftaranPayload>[]
          }
          create: {
            args: Prisma.pendaftaranCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pendaftaranPayload>
          }
          createMany: {
            args: Prisma.pendaftaranCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pendaftaranDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pendaftaranPayload>
          }
          update: {
            args: Prisma.pendaftaranUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pendaftaranPayload>
          }
          deleteMany: {
            args: Prisma.pendaftaranDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pendaftaranUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pendaftaranUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pendaftaranPayload>
          }
          aggregate: {
            args: Prisma.PendaftaranAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePendaftaran>
          }
          groupBy: {
            args: Prisma.pendaftaranGroupByArgs<ExtArgs>
            result: $Utils.Optional<PendaftaranGroupByOutputType>[]
          }
          count: {
            args: Prisma.pendaftaranCountArgs<ExtArgs>
            result: $Utils.Optional<PendaftaranCountAggregateOutputType> | number
          }
        }
      }
      jadwal: {
        payload: Prisma.$jadwalPayload<ExtArgs>
        fields: Prisma.jadwalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.jadwalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jadwalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.jadwalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jadwalPayload>
          }
          findFirst: {
            args: Prisma.jadwalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jadwalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.jadwalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jadwalPayload>
          }
          findMany: {
            args: Prisma.jadwalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jadwalPayload>[]
          }
          create: {
            args: Prisma.jadwalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jadwalPayload>
          }
          createMany: {
            args: Prisma.jadwalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.jadwalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jadwalPayload>
          }
          update: {
            args: Prisma.jadwalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jadwalPayload>
          }
          deleteMany: {
            args: Prisma.jadwalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.jadwalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.jadwalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jadwalPayload>
          }
          aggregate: {
            args: Prisma.JadwalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJadwal>
          }
          groupBy: {
            args: Prisma.jadwalGroupByArgs<ExtArgs>
            result: $Utils.Optional<JadwalGroupByOutputType>[]
          }
          count: {
            args: Prisma.jadwalCountArgs<ExtArgs>
            result: $Utils.Optional<JadwalCountAggregateOutputType> | number
          }
        }
      }
      modul: {
        payload: Prisma.$modulPayload<ExtArgs>
        fields: Prisma.modulFieldRefs
        operations: {
          findUnique: {
            args: Prisma.modulFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modulPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.modulFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modulPayload>
          }
          findFirst: {
            args: Prisma.modulFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modulPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.modulFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modulPayload>
          }
          findMany: {
            args: Prisma.modulFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modulPayload>[]
          }
          create: {
            args: Prisma.modulCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modulPayload>
          }
          createMany: {
            args: Prisma.modulCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.modulDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modulPayload>
          }
          update: {
            args: Prisma.modulUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modulPayload>
          }
          deleteMany: {
            args: Prisma.modulDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.modulUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.modulUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modulPayload>
          }
          aggregate: {
            args: Prisma.ModulAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModul>
          }
          groupBy: {
            args: Prisma.modulGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModulGroupByOutputType>[]
          }
          count: {
            args: Prisma.modulCountArgs<ExtArgs>
            result: $Utils.Optional<ModulCountAggregateOutputType> | number
          }
        }
      }
      tugas: {
        payload: Prisma.$tugasPayload<ExtArgs>
        fields: Prisma.tugasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tugasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tugasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tugasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tugasPayload>
          }
          findFirst: {
            args: Prisma.tugasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tugasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tugasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tugasPayload>
          }
          findMany: {
            args: Prisma.tugasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tugasPayload>[]
          }
          create: {
            args: Prisma.tugasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tugasPayload>
          }
          createMany: {
            args: Prisma.tugasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tugasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tugasPayload>
          }
          update: {
            args: Prisma.tugasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tugasPayload>
          }
          deleteMany: {
            args: Prisma.tugasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tugasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tugasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tugasPayload>
          }
          aggregate: {
            args: Prisma.TugasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTugas>
          }
          groupBy: {
            args: Prisma.tugasGroupByArgs<ExtArgs>
            result: $Utils.Optional<TugasGroupByOutputType>[]
          }
          count: {
            args: Prisma.tugasCountArgs<ExtArgs>
            result: $Utils.Optional<TugasCountAggregateOutputType> | number
          }
        }
      }
      pengumpulan: {
        payload: Prisma.$pengumpulanPayload<ExtArgs>
        fields: Prisma.pengumpulanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pengumpulanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pengumpulanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pengumpulanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pengumpulanPayload>
          }
          findFirst: {
            args: Prisma.pengumpulanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pengumpulanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pengumpulanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pengumpulanPayload>
          }
          findMany: {
            args: Prisma.pengumpulanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pengumpulanPayload>[]
          }
          create: {
            args: Prisma.pengumpulanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pengumpulanPayload>
          }
          createMany: {
            args: Prisma.pengumpulanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pengumpulanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pengumpulanPayload>
          }
          update: {
            args: Prisma.pengumpulanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pengumpulanPayload>
          }
          deleteMany: {
            args: Prisma.pengumpulanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pengumpulanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pengumpulanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pengumpulanPayload>
          }
          aggregate: {
            args: Prisma.PengumpulanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePengumpulan>
          }
          groupBy: {
            args: Prisma.pengumpulanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PengumpulanGroupByOutputType>[]
          }
          count: {
            args: Prisma.pengumpulanCountArgs<ExtArgs>
            result: $Utils.Optional<PengumpulanCountAggregateOutputType> | number
          }
        }
      }
      pengumuman: {
        payload: Prisma.$pengumumanPayload<ExtArgs>
        fields: Prisma.pengumumanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pengumumanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pengumumanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pengumumanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pengumumanPayload>
          }
          findFirst: {
            args: Prisma.pengumumanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pengumumanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pengumumanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pengumumanPayload>
          }
          findMany: {
            args: Prisma.pengumumanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pengumumanPayload>[]
          }
          create: {
            args: Prisma.pengumumanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pengumumanPayload>
          }
          createMany: {
            args: Prisma.pengumumanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.pengumumanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pengumumanPayload>
          }
          update: {
            args: Prisma.pengumumanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pengumumanPayload>
          }
          deleteMany: {
            args: Prisma.pengumumanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pengumumanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pengumumanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pengumumanPayload>
          }
          aggregate: {
            args: Prisma.PengumumanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePengumuman>
          }
          groupBy: {
            args: Prisma.pengumumanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PengumumanGroupByOutputType>[]
          }
          count: {
            args: Prisma.pengumumanCountArgs<ExtArgs>
            result: $Utils.Optional<PengumumanCountAggregateOutputType> | number
          }
        }
      }
      absensi: {
        payload: Prisma.$absensiPayload<ExtArgs>
        fields: Prisma.absensiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.absensiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$absensiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.absensiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$absensiPayload>
          }
          findFirst: {
            args: Prisma.absensiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$absensiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.absensiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$absensiPayload>
          }
          findMany: {
            args: Prisma.absensiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$absensiPayload>[]
          }
          create: {
            args: Prisma.absensiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$absensiPayload>
          }
          createMany: {
            args: Prisma.absensiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.absensiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$absensiPayload>
          }
          update: {
            args: Prisma.absensiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$absensiPayload>
          }
          deleteMany: {
            args: Prisma.absensiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.absensiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.absensiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$absensiPayload>
          }
          aggregate: {
            args: Prisma.AbsensiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAbsensi>
          }
          groupBy: {
            args: Prisma.absensiGroupByArgs<ExtArgs>
            result: $Utils.Optional<AbsensiGroupByOutputType>[]
          }
          count: {
            args: Prisma.absensiCountArgs<ExtArgs>
            result: $Utils.Optional<AbsensiCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: userOmit
    lab?: labOmit
    praktikum?: praktikumOmit
    pendaftaran?: pendaftaranOmit
    jadwal?: jadwalOmit
    modul?: modulOmit
    tugas?: tugasOmit
    pengumpulan?: pengumpulanOmit
    pengumuman?: pengumumanOmit
    absensi?: absensiOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    pendaftaran: number
    jadwal: number
    modul: number
    pengumpulan: number
    pengumuman: number
    absensi: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendaftaran?: boolean | UserCountOutputTypeCountPendaftaranArgs
    jadwal?: boolean | UserCountOutputTypeCountJadwalArgs
    modul?: boolean | UserCountOutputTypeCountModulArgs
    pengumpulan?: boolean | UserCountOutputTypeCountPengumpulanArgs
    pengumuman?: boolean | UserCountOutputTypeCountPengumumanArgs
    absensi?: boolean | UserCountOutputTypeCountAbsensiArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPendaftaranArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pendaftaranWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJadwalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jadwalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountModulArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: modulWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPengumpulanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pengumpulanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPengumumanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pengumumanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAbsensiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: absensiWhereInput
  }


  /**
   * Count Type LabCountOutputType
   */

  export type LabCountOutputType = {
    praktikum: number
  }

  export type LabCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    praktikum?: boolean | LabCountOutputTypeCountPraktikumArgs
  }

  // Custom InputTypes
  /**
   * LabCountOutputType without action
   */
  export type LabCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabCountOutputType
     */
    select?: LabCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabCountOutputType without action
   */
  export type LabCountOutputTypeCountPraktikumArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: praktikumWhereInput
  }


  /**
   * Count Type PraktikumCountOutputType
   */

  export type PraktikumCountOutputType = {
    pendaftaran: number
    jadwal: number
    modul: number
    tugas: number
    pengumuman: number
  }

  export type PraktikumCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendaftaran?: boolean | PraktikumCountOutputTypeCountPendaftaranArgs
    jadwal?: boolean | PraktikumCountOutputTypeCountJadwalArgs
    modul?: boolean | PraktikumCountOutputTypeCountModulArgs
    tugas?: boolean | PraktikumCountOutputTypeCountTugasArgs
    pengumuman?: boolean | PraktikumCountOutputTypeCountPengumumanArgs
  }

  // Custom InputTypes
  /**
   * PraktikumCountOutputType without action
   */
  export type PraktikumCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PraktikumCountOutputType
     */
    select?: PraktikumCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PraktikumCountOutputType without action
   */
  export type PraktikumCountOutputTypeCountPendaftaranArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pendaftaranWhereInput
  }

  /**
   * PraktikumCountOutputType without action
   */
  export type PraktikumCountOutputTypeCountJadwalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jadwalWhereInput
  }

  /**
   * PraktikumCountOutputType without action
   */
  export type PraktikumCountOutputTypeCountModulArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: modulWhereInput
  }

  /**
   * PraktikumCountOutputType without action
   */
  export type PraktikumCountOutputTypeCountTugasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tugasWhereInput
  }

  /**
   * PraktikumCountOutputType without action
   */
  export type PraktikumCountOutputTypeCountPengumumanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pengumumanWhereInput
  }


  /**
   * Count Type JadwalCountOutputType
   */

  export type JadwalCountOutputType = {
    absensi: number
  }

  export type JadwalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    absensi?: boolean | JadwalCountOutputTypeCountAbsensiArgs
  }

  // Custom InputTypes
  /**
   * JadwalCountOutputType without action
   */
  export type JadwalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JadwalCountOutputType
     */
    select?: JadwalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JadwalCountOutputType without action
   */
  export type JadwalCountOutputTypeCountAbsensiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: absensiWhereInput
  }


  /**
   * Count Type TugasCountOutputType
   */

  export type TugasCountOutputType = {
    pengumpulan: number
  }

  export type TugasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pengumpulan?: boolean | TugasCountOutputTypeCountPengumpulanArgs
  }

  // Custom InputTypes
  /**
   * TugasCountOutputType without action
   */
  export type TugasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TugasCountOutputType
     */
    select?: TugasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TugasCountOutputType without action
   */
  export type TugasCountOutputTypeCountPengumpulanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pengumpulanWhereInput
  }


  /**
   * Models
   */

  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    kata_sandi: string | null
    peran: $Enums.Peran | null
    dibuat_pada: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    kata_sandi: string | null
    peran: $Enums.Peran | null
    dibuat_pada: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    kata_sandi: number
    peran: number
    dibuat_pada: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    kata_sandi?: true
    peran?: true
    dibuat_pada?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    kata_sandi?: true
    peran?: true
    dibuat_pada?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    kata_sandi?: true
    peran?: true
    dibuat_pada?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    kata_sandi: string
    peran: $Enums.Peran
    dibuat_pada: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    kata_sandi?: boolean
    peran?: boolean
    dibuat_pada?: boolean
    pendaftaran?: boolean | user$pendaftaranArgs<ExtArgs>
    jadwal?: boolean | user$jadwalArgs<ExtArgs>
    modul?: boolean | user$modulArgs<ExtArgs>
    pengumpulan?: boolean | user$pengumpulanArgs<ExtArgs>
    pengumuman?: boolean | user$pengumumanArgs<ExtArgs>
    absensi?: boolean | user$absensiArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type userSelectScalar = {
    id?: boolean
    username?: boolean
    kata_sandi?: boolean
    peran?: boolean
    dibuat_pada?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "kata_sandi" | "peran" | "dibuat_pada", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendaftaran?: boolean | user$pendaftaranArgs<ExtArgs>
    jadwal?: boolean | user$jadwalArgs<ExtArgs>
    modul?: boolean | user$modulArgs<ExtArgs>
    pengumpulan?: boolean | user$pengumpulanArgs<ExtArgs>
    pengumuman?: boolean | user$pengumumanArgs<ExtArgs>
    absensi?: boolean | user$absensiArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      pendaftaran: Prisma.$pendaftaranPayload<ExtArgs>[]
      jadwal: Prisma.$jadwalPayload<ExtArgs>[]
      modul: Prisma.$modulPayload<ExtArgs>[]
      pengumpulan: Prisma.$pengumpulanPayload<ExtArgs>[]
      pengumuman: Prisma.$pengumumanPayload<ExtArgs>[]
      absensi: Prisma.$absensiPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      kata_sandi: string
      peran: $Enums.Peran
      dibuat_pada: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pendaftaran<T extends user$pendaftaranArgs<ExtArgs> = {}>(args?: Subset<T, user$pendaftaranArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pendaftaranPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jadwal<T extends user$jadwalArgs<ExtArgs> = {}>(args?: Subset<T, user$jadwalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jadwalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modul<T extends user$modulArgs<ExtArgs> = {}>(args?: Subset<T, user$modulArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$modulPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pengumpulan<T extends user$pengumpulanArgs<ExtArgs> = {}>(args?: Subset<T, user$pengumpulanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pengumpulanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pengumuman<T extends user$pengumumanArgs<ExtArgs> = {}>(args?: Subset<T, user$pengumumanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pengumumanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    absensi<T extends user$absensiArgs<ExtArgs> = {}>(args?: Subset<T, user$absensiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$absensiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'String'>
    readonly username: FieldRef<"user", 'String'>
    readonly kata_sandi: FieldRef<"user", 'String'>
    readonly peran: FieldRef<"user", 'Peran'>
    readonly dibuat_pada: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.pendaftaran
   */
  export type user$pendaftaranArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendaftaran
     */
    select?: pendaftaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pendaftaran
     */
    omit?: pendaftaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendaftaranInclude<ExtArgs> | null
    where?: pendaftaranWhereInput
    orderBy?: pendaftaranOrderByWithRelationInput | pendaftaranOrderByWithRelationInput[]
    cursor?: pendaftaranWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendaftaranScalarFieldEnum | PendaftaranScalarFieldEnum[]
  }

  /**
   * user.jadwal
   */
  export type user$jadwalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jadwal
     */
    select?: jadwalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jadwal
     */
    omit?: jadwalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jadwalInclude<ExtArgs> | null
    where?: jadwalWhereInput
    orderBy?: jadwalOrderByWithRelationInput | jadwalOrderByWithRelationInput[]
    cursor?: jadwalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JadwalScalarFieldEnum | JadwalScalarFieldEnum[]
  }

  /**
   * user.modul
   */
  export type user$modulArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modul
     */
    select?: modulSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modul
     */
    omit?: modulOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulInclude<ExtArgs> | null
    where?: modulWhereInput
    orderBy?: modulOrderByWithRelationInput | modulOrderByWithRelationInput[]
    cursor?: modulWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModulScalarFieldEnum | ModulScalarFieldEnum[]
  }

  /**
   * user.pengumpulan
   */
  export type user$pengumpulanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumpulan
     */
    select?: pengumpulanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumpulan
     */
    omit?: pengumpulanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumpulanInclude<ExtArgs> | null
    where?: pengumpulanWhereInput
    orderBy?: pengumpulanOrderByWithRelationInput | pengumpulanOrderByWithRelationInput[]
    cursor?: pengumpulanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PengumpulanScalarFieldEnum | PengumpulanScalarFieldEnum[]
  }

  /**
   * user.pengumuman
   */
  export type user$pengumumanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumuman
     */
    select?: pengumumanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumuman
     */
    omit?: pengumumanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumumanInclude<ExtArgs> | null
    where?: pengumumanWhereInput
    orderBy?: pengumumanOrderByWithRelationInput | pengumumanOrderByWithRelationInput[]
    cursor?: pengumumanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PengumumanScalarFieldEnum | PengumumanScalarFieldEnum[]
  }

  /**
   * user.absensi
   */
  export type user$absensiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the absensi
     */
    select?: absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the absensi
     */
    omit?: absensiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: absensiInclude<ExtArgs> | null
    where?: absensiWhereInput
    orderBy?: absensiOrderByWithRelationInput | absensiOrderByWithRelationInput[]
    cursor?: absensiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AbsensiScalarFieldEnum | AbsensiScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model lab
   */

  export type AggregateLab = {
    _count: LabCountAggregateOutputType | null
    _avg: LabAvgAggregateOutputType | null
    _sum: LabSumAggregateOutputType | null
    _min: LabMinAggregateOutputType | null
    _max: LabMaxAggregateOutputType | null
  }

  export type LabAvgAggregateOutputType = {
    id: number | null
  }

  export type LabSumAggregateOutputType = {
    id: number | null
  }

  export type LabMinAggregateOutputType = {
    id: number | null
    nama_lab: string | null
  }

  export type LabMaxAggregateOutputType = {
    id: number | null
    nama_lab: string | null
  }

  export type LabCountAggregateOutputType = {
    id: number
    nama_lab: number
    _all: number
  }


  export type LabAvgAggregateInputType = {
    id?: true
  }

  export type LabSumAggregateInputType = {
    id?: true
  }

  export type LabMinAggregateInputType = {
    id?: true
    nama_lab?: true
  }

  export type LabMaxAggregateInputType = {
    id?: true
    nama_lab?: true
  }

  export type LabCountAggregateInputType = {
    id?: true
    nama_lab?: true
    _all?: true
  }

  export type LabAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lab to aggregate.
     */
    where?: labWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of labs to fetch.
     */
    orderBy?: labOrderByWithRelationInput | labOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: labWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned labs
    **/
    _count?: true | LabCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabMaxAggregateInputType
  }

  export type GetLabAggregateType<T extends LabAggregateArgs> = {
        [P in keyof T & keyof AggregateLab]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLab[P]>
      : GetScalarType<T[P], AggregateLab[P]>
  }




  export type labGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: labWhereInput
    orderBy?: labOrderByWithAggregationInput | labOrderByWithAggregationInput[]
    by: LabScalarFieldEnum[] | LabScalarFieldEnum
    having?: labScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabCountAggregateInputType | true
    _avg?: LabAvgAggregateInputType
    _sum?: LabSumAggregateInputType
    _min?: LabMinAggregateInputType
    _max?: LabMaxAggregateInputType
  }

  export type LabGroupByOutputType = {
    id: number
    nama_lab: string
    _count: LabCountAggregateOutputType | null
    _avg: LabAvgAggregateOutputType | null
    _sum: LabSumAggregateOutputType | null
    _min: LabMinAggregateOutputType | null
    _max: LabMaxAggregateOutputType | null
  }

  type GetLabGroupByPayload<T extends labGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabGroupByOutputType[P]>
            : GetScalarType<T[P], LabGroupByOutputType[P]>
        }
      >
    >


  export type labSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama_lab?: boolean
    praktikum?: boolean | lab$praktikumArgs<ExtArgs>
    _count?: boolean | LabCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lab"]>



  export type labSelectScalar = {
    id?: boolean
    nama_lab?: boolean
  }

  export type labOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nama_lab", ExtArgs["result"]["lab"]>
  export type labInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    praktikum?: boolean | lab$praktikumArgs<ExtArgs>
    _count?: boolean | LabCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $labPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lab"
    objects: {
      praktikum: Prisma.$praktikumPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama_lab: string
    }, ExtArgs["result"]["lab"]>
    composites: {}
  }

  type labGetPayload<S extends boolean | null | undefined | labDefaultArgs> = $Result.GetResult<Prisma.$labPayload, S>

  type labCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<labFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabCountAggregateInputType | true
    }

  export interface labDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lab'], meta: { name: 'lab' } }
    /**
     * Find zero or one Lab that matches the filter.
     * @param {labFindUniqueArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends labFindUniqueArgs>(args: SelectSubset<T, labFindUniqueArgs<ExtArgs>>): Prisma__labClient<$Result.GetResult<Prisma.$labPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lab that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {labFindUniqueOrThrowArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends labFindUniqueOrThrowArgs>(args: SelectSubset<T, labFindUniqueOrThrowArgs<ExtArgs>>): Prisma__labClient<$Result.GetResult<Prisma.$labPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lab that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {labFindFirstArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends labFindFirstArgs>(args?: SelectSubset<T, labFindFirstArgs<ExtArgs>>): Prisma__labClient<$Result.GetResult<Prisma.$labPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lab that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {labFindFirstOrThrowArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends labFindFirstOrThrowArgs>(args?: SelectSubset<T, labFindFirstOrThrowArgs<ExtArgs>>): Prisma__labClient<$Result.GetResult<Prisma.$labPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Labs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {labFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Labs
     * const labs = await prisma.lab.findMany()
     * 
     * // Get first 10 Labs
     * const labs = await prisma.lab.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labWithIdOnly = await prisma.lab.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends labFindManyArgs>(args?: SelectSubset<T, labFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$labPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lab.
     * @param {labCreateArgs} args - Arguments to create a Lab.
     * @example
     * // Create one Lab
     * const Lab = await prisma.lab.create({
     *   data: {
     *     // ... data to create a Lab
     *   }
     * })
     * 
     */
    create<T extends labCreateArgs>(args: SelectSubset<T, labCreateArgs<ExtArgs>>): Prisma__labClient<$Result.GetResult<Prisma.$labPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Labs.
     * @param {labCreateManyArgs} args - Arguments to create many Labs.
     * @example
     * // Create many Labs
     * const lab = await prisma.lab.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends labCreateManyArgs>(args?: SelectSubset<T, labCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lab.
     * @param {labDeleteArgs} args - Arguments to delete one Lab.
     * @example
     * // Delete one Lab
     * const Lab = await prisma.lab.delete({
     *   where: {
     *     // ... filter to delete one Lab
     *   }
     * })
     * 
     */
    delete<T extends labDeleteArgs>(args: SelectSubset<T, labDeleteArgs<ExtArgs>>): Prisma__labClient<$Result.GetResult<Prisma.$labPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lab.
     * @param {labUpdateArgs} args - Arguments to update one Lab.
     * @example
     * // Update one Lab
     * const lab = await prisma.lab.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends labUpdateArgs>(args: SelectSubset<T, labUpdateArgs<ExtArgs>>): Prisma__labClient<$Result.GetResult<Prisma.$labPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Labs.
     * @param {labDeleteManyArgs} args - Arguments to filter Labs to delete.
     * @example
     * // Delete a few Labs
     * const { count } = await prisma.lab.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends labDeleteManyArgs>(args?: SelectSubset<T, labDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {labUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Labs
     * const lab = await prisma.lab.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends labUpdateManyArgs>(args: SelectSubset<T, labUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lab.
     * @param {labUpsertArgs} args - Arguments to update or create a Lab.
     * @example
     * // Update or create a Lab
     * const lab = await prisma.lab.upsert({
     *   create: {
     *     // ... data to create a Lab
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lab we want to update
     *   }
     * })
     */
    upsert<T extends labUpsertArgs>(args: SelectSubset<T, labUpsertArgs<ExtArgs>>): Prisma__labClient<$Result.GetResult<Prisma.$labPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Labs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {labCountArgs} args - Arguments to filter Labs to count.
     * @example
     * // Count the number of Labs
     * const count = await prisma.lab.count({
     *   where: {
     *     // ... the filter for the Labs we want to count
     *   }
     * })
    **/
    count<T extends labCountArgs>(
      args?: Subset<T, labCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lab.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabAggregateArgs>(args: Subset<T, LabAggregateArgs>): Prisma.PrismaPromise<GetLabAggregateType<T>>

    /**
     * Group by Lab.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {labGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends labGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: labGroupByArgs['orderBy'] }
        : { orderBy?: labGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, labGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lab model
   */
  readonly fields: labFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lab.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__labClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    praktikum<T extends lab$praktikumArgs<ExtArgs> = {}>(args?: Subset<T, lab$praktikumArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$praktikumPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the lab model
   */
  interface labFieldRefs {
    readonly id: FieldRef<"lab", 'Int'>
    readonly nama_lab: FieldRef<"lab", 'String'>
  }
    

  // Custom InputTypes
  /**
   * lab findUnique
   */
  export type labFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab
     */
    select?: labSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab
     */
    omit?: labOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: labInclude<ExtArgs> | null
    /**
     * Filter, which lab to fetch.
     */
    where: labWhereUniqueInput
  }

  /**
   * lab findUniqueOrThrow
   */
  export type labFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab
     */
    select?: labSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab
     */
    omit?: labOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: labInclude<ExtArgs> | null
    /**
     * Filter, which lab to fetch.
     */
    where: labWhereUniqueInput
  }

  /**
   * lab findFirst
   */
  export type labFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab
     */
    select?: labSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab
     */
    omit?: labOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: labInclude<ExtArgs> | null
    /**
     * Filter, which lab to fetch.
     */
    where?: labWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of labs to fetch.
     */
    orderBy?: labOrderByWithRelationInput | labOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for labs.
     */
    cursor?: labWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of labs.
     */
    distinct?: LabScalarFieldEnum | LabScalarFieldEnum[]
  }

  /**
   * lab findFirstOrThrow
   */
  export type labFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab
     */
    select?: labSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab
     */
    omit?: labOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: labInclude<ExtArgs> | null
    /**
     * Filter, which lab to fetch.
     */
    where?: labWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of labs to fetch.
     */
    orderBy?: labOrderByWithRelationInput | labOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for labs.
     */
    cursor?: labWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of labs.
     */
    distinct?: LabScalarFieldEnum | LabScalarFieldEnum[]
  }

  /**
   * lab findMany
   */
  export type labFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab
     */
    select?: labSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab
     */
    omit?: labOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: labInclude<ExtArgs> | null
    /**
     * Filter, which labs to fetch.
     */
    where?: labWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of labs to fetch.
     */
    orderBy?: labOrderByWithRelationInput | labOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing labs.
     */
    cursor?: labWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` labs.
     */
    skip?: number
    distinct?: LabScalarFieldEnum | LabScalarFieldEnum[]
  }

  /**
   * lab create
   */
  export type labCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab
     */
    select?: labSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab
     */
    omit?: labOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: labInclude<ExtArgs> | null
    /**
     * The data needed to create a lab.
     */
    data: XOR<labCreateInput, labUncheckedCreateInput>
  }

  /**
   * lab createMany
   */
  export type labCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many labs.
     */
    data: labCreateManyInput | labCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lab update
   */
  export type labUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab
     */
    select?: labSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab
     */
    omit?: labOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: labInclude<ExtArgs> | null
    /**
     * The data needed to update a lab.
     */
    data: XOR<labUpdateInput, labUncheckedUpdateInput>
    /**
     * Choose, which lab to update.
     */
    where: labWhereUniqueInput
  }

  /**
   * lab updateMany
   */
  export type labUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update labs.
     */
    data: XOR<labUpdateManyMutationInput, labUncheckedUpdateManyInput>
    /**
     * Filter which labs to update
     */
    where?: labWhereInput
    /**
     * Limit how many labs to update.
     */
    limit?: number
  }

  /**
   * lab upsert
   */
  export type labUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab
     */
    select?: labSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab
     */
    omit?: labOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: labInclude<ExtArgs> | null
    /**
     * The filter to search for the lab to update in case it exists.
     */
    where: labWhereUniqueInput
    /**
     * In case the lab found by the `where` argument doesn't exist, create a new lab with this data.
     */
    create: XOR<labCreateInput, labUncheckedCreateInput>
    /**
     * In case the lab was found with the provided `where` argument, update it with this data.
     */
    update: XOR<labUpdateInput, labUncheckedUpdateInput>
  }

  /**
   * lab delete
   */
  export type labDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab
     */
    select?: labSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab
     */
    omit?: labOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: labInclude<ExtArgs> | null
    /**
     * Filter which lab to delete.
     */
    where: labWhereUniqueInput
  }

  /**
   * lab deleteMany
   */
  export type labDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which labs to delete
     */
    where?: labWhereInput
    /**
     * Limit how many labs to delete.
     */
    limit?: number
  }

  /**
   * lab.praktikum
   */
  export type lab$praktikumArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praktikum
     */
    select?: praktikumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praktikum
     */
    omit?: praktikumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praktikumInclude<ExtArgs> | null
    where?: praktikumWhereInput
    orderBy?: praktikumOrderByWithRelationInput | praktikumOrderByWithRelationInput[]
    cursor?: praktikumWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PraktikumScalarFieldEnum | PraktikumScalarFieldEnum[]
  }

  /**
   * lab without action
   */
  export type labDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lab
     */
    select?: labSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lab
     */
    omit?: labOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: labInclude<ExtArgs> | null
  }


  /**
   * Model praktikum
   */

  export type AggregatePraktikum = {
    _count: PraktikumCountAggregateOutputType | null
    _avg: PraktikumAvgAggregateOutputType | null
    _sum: PraktikumSumAggregateOutputType | null
    _min: PraktikumMinAggregateOutputType | null
    _max: PraktikumMaxAggregateOutputType | null
  }

  export type PraktikumAvgAggregateOutputType = {
    id: number | null
    lab_id: number | null
  }

  export type PraktikumSumAggregateOutputType = {
    id: number | null
    lab_id: number | null
  }

  export type PraktikumMinAggregateOutputType = {
    id: number | null
    nama_praktikum: string | null
    lab_id: number | null
    dibuat_pada: Date | null
  }

  export type PraktikumMaxAggregateOutputType = {
    id: number | null
    nama_praktikum: string | null
    lab_id: number | null
    dibuat_pada: Date | null
  }

  export type PraktikumCountAggregateOutputType = {
    id: number
    nama_praktikum: number
    lab_id: number
    dibuat_pada: number
    _all: number
  }


  export type PraktikumAvgAggregateInputType = {
    id?: true
    lab_id?: true
  }

  export type PraktikumSumAggregateInputType = {
    id?: true
    lab_id?: true
  }

  export type PraktikumMinAggregateInputType = {
    id?: true
    nama_praktikum?: true
    lab_id?: true
    dibuat_pada?: true
  }

  export type PraktikumMaxAggregateInputType = {
    id?: true
    nama_praktikum?: true
    lab_id?: true
    dibuat_pada?: true
  }

  export type PraktikumCountAggregateInputType = {
    id?: true
    nama_praktikum?: true
    lab_id?: true
    dibuat_pada?: true
    _all?: true
  }

  export type PraktikumAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which praktikum to aggregate.
     */
    where?: praktikumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of praktikums to fetch.
     */
    orderBy?: praktikumOrderByWithRelationInput | praktikumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: praktikumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` praktikums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` praktikums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned praktikums
    **/
    _count?: true | PraktikumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PraktikumAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PraktikumSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PraktikumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PraktikumMaxAggregateInputType
  }

  export type GetPraktikumAggregateType<T extends PraktikumAggregateArgs> = {
        [P in keyof T & keyof AggregatePraktikum]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePraktikum[P]>
      : GetScalarType<T[P], AggregatePraktikum[P]>
  }




  export type praktikumGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: praktikumWhereInput
    orderBy?: praktikumOrderByWithAggregationInput | praktikumOrderByWithAggregationInput[]
    by: PraktikumScalarFieldEnum[] | PraktikumScalarFieldEnum
    having?: praktikumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PraktikumCountAggregateInputType | true
    _avg?: PraktikumAvgAggregateInputType
    _sum?: PraktikumSumAggregateInputType
    _min?: PraktikumMinAggregateInputType
    _max?: PraktikumMaxAggregateInputType
  }

  export type PraktikumGroupByOutputType = {
    id: number
    nama_praktikum: string
    lab_id: number
    dibuat_pada: Date
    _count: PraktikumCountAggregateOutputType | null
    _avg: PraktikumAvgAggregateOutputType | null
    _sum: PraktikumSumAggregateOutputType | null
    _min: PraktikumMinAggregateOutputType | null
    _max: PraktikumMaxAggregateOutputType | null
  }

  type GetPraktikumGroupByPayload<T extends praktikumGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PraktikumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PraktikumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PraktikumGroupByOutputType[P]>
            : GetScalarType<T[P], PraktikumGroupByOutputType[P]>
        }
      >
    >


  export type praktikumSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama_praktikum?: boolean
    lab_id?: boolean
    dibuat_pada?: boolean
    lab?: boolean | labDefaultArgs<ExtArgs>
    pendaftaran?: boolean | praktikum$pendaftaranArgs<ExtArgs>
    jadwal?: boolean | praktikum$jadwalArgs<ExtArgs>
    modul?: boolean | praktikum$modulArgs<ExtArgs>
    tugas?: boolean | praktikum$tugasArgs<ExtArgs>
    pengumuman?: boolean | praktikum$pengumumanArgs<ExtArgs>
    _count?: boolean | PraktikumCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["praktikum"]>



  export type praktikumSelectScalar = {
    id?: boolean
    nama_praktikum?: boolean
    lab_id?: boolean
    dibuat_pada?: boolean
  }

  export type praktikumOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nama_praktikum" | "lab_id" | "dibuat_pada", ExtArgs["result"]["praktikum"]>
  export type praktikumInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | labDefaultArgs<ExtArgs>
    pendaftaran?: boolean | praktikum$pendaftaranArgs<ExtArgs>
    jadwal?: boolean | praktikum$jadwalArgs<ExtArgs>
    modul?: boolean | praktikum$modulArgs<ExtArgs>
    tugas?: boolean | praktikum$tugasArgs<ExtArgs>
    pengumuman?: boolean | praktikum$pengumumanArgs<ExtArgs>
    _count?: boolean | PraktikumCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $praktikumPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "praktikum"
    objects: {
      lab: Prisma.$labPayload<ExtArgs>
      pendaftaran: Prisma.$pendaftaranPayload<ExtArgs>[]
      jadwal: Prisma.$jadwalPayload<ExtArgs>[]
      modul: Prisma.$modulPayload<ExtArgs>[]
      tugas: Prisma.$tugasPayload<ExtArgs>[]
      pengumuman: Prisma.$pengumumanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nama_praktikum: string
      lab_id: number
      dibuat_pada: Date
    }, ExtArgs["result"]["praktikum"]>
    composites: {}
  }

  type praktikumGetPayload<S extends boolean | null | undefined | praktikumDefaultArgs> = $Result.GetResult<Prisma.$praktikumPayload, S>

  type praktikumCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<praktikumFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PraktikumCountAggregateInputType | true
    }

  export interface praktikumDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['praktikum'], meta: { name: 'praktikum' } }
    /**
     * Find zero or one Praktikum that matches the filter.
     * @param {praktikumFindUniqueArgs} args - Arguments to find a Praktikum
     * @example
     * // Get one Praktikum
     * const praktikum = await prisma.praktikum.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends praktikumFindUniqueArgs>(args: SelectSubset<T, praktikumFindUniqueArgs<ExtArgs>>): Prisma__praktikumClient<$Result.GetResult<Prisma.$praktikumPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Praktikum that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {praktikumFindUniqueOrThrowArgs} args - Arguments to find a Praktikum
     * @example
     * // Get one Praktikum
     * const praktikum = await prisma.praktikum.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends praktikumFindUniqueOrThrowArgs>(args: SelectSubset<T, praktikumFindUniqueOrThrowArgs<ExtArgs>>): Prisma__praktikumClient<$Result.GetResult<Prisma.$praktikumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Praktikum that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {praktikumFindFirstArgs} args - Arguments to find a Praktikum
     * @example
     * // Get one Praktikum
     * const praktikum = await prisma.praktikum.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends praktikumFindFirstArgs>(args?: SelectSubset<T, praktikumFindFirstArgs<ExtArgs>>): Prisma__praktikumClient<$Result.GetResult<Prisma.$praktikumPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Praktikum that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {praktikumFindFirstOrThrowArgs} args - Arguments to find a Praktikum
     * @example
     * // Get one Praktikum
     * const praktikum = await prisma.praktikum.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends praktikumFindFirstOrThrowArgs>(args?: SelectSubset<T, praktikumFindFirstOrThrowArgs<ExtArgs>>): Prisma__praktikumClient<$Result.GetResult<Prisma.$praktikumPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Praktikums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {praktikumFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Praktikums
     * const praktikums = await prisma.praktikum.findMany()
     * 
     * // Get first 10 Praktikums
     * const praktikums = await prisma.praktikum.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const praktikumWithIdOnly = await prisma.praktikum.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends praktikumFindManyArgs>(args?: SelectSubset<T, praktikumFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$praktikumPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Praktikum.
     * @param {praktikumCreateArgs} args - Arguments to create a Praktikum.
     * @example
     * // Create one Praktikum
     * const Praktikum = await prisma.praktikum.create({
     *   data: {
     *     // ... data to create a Praktikum
     *   }
     * })
     * 
     */
    create<T extends praktikumCreateArgs>(args: SelectSubset<T, praktikumCreateArgs<ExtArgs>>): Prisma__praktikumClient<$Result.GetResult<Prisma.$praktikumPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Praktikums.
     * @param {praktikumCreateManyArgs} args - Arguments to create many Praktikums.
     * @example
     * // Create many Praktikums
     * const praktikum = await prisma.praktikum.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends praktikumCreateManyArgs>(args?: SelectSubset<T, praktikumCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Praktikum.
     * @param {praktikumDeleteArgs} args - Arguments to delete one Praktikum.
     * @example
     * // Delete one Praktikum
     * const Praktikum = await prisma.praktikum.delete({
     *   where: {
     *     // ... filter to delete one Praktikum
     *   }
     * })
     * 
     */
    delete<T extends praktikumDeleteArgs>(args: SelectSubset<T, praktikumDeleteArgs<ExtArgs>>): Prisma__praktikumClient<$Result.GetResult<Prisma.$praktikumPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Praktikum.
     * @param {praktikumUpdateArgs} args - Arguments to update one Praktikum.
     * @example
     * // Update one Praktikum
     * const praktikum = await prisma.praktikum.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends praktikumUpdateArgs>(args: SelectSubset<T, praktikumUpdateArgs<ExtArgs>>): Prisma__praktikumClient<$Result.GetResult<Prisma.$praktikumPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Praktikums.
     * @param {praktikumDeleteManyArgs} args - Arguments to filter Praktikums to delete.
     * @example
     * // Delete a few Praktikums
     * const { count } = await prisma.praktikum.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends praktikumDeleteManyArgs>(args?: SelectSubset<T, praktikumDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Praktikums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {praktikumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Praktikums
     * const praktikum = await prisma.praktikum.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends praktikumUpdateManyArgs>(args: SelectSubset<T, praktikumUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Praktikum.
     * @param {praktikumUpsertArgs} args - Arguments to update or create a Praktikum.
     * @example
     * // Update or create a Praktikum
     * const praktikum = await prisma.praktikum.upsert({
     *   create: {
     *     // ... data to create a Praktikum
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Praktikum we want to update
     *   }
     * })
     */
    upsert<T extends praktikumUpsertArgs>(args: SelectSubset<T, praktikumUpsertArgs<ExtArgs>>): Prisma__praktikumClient<$Result.GetResult<Prisma.$praktikumPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Praktikums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {praktikumCountArgs} args - Arguments to filter Praktikums to count.
     * @example
     * // Count the number of Praktikums
     * const count = await prisma.praktikum.count({
     *   where: {
     *     // ... the filter for the Praktikums we want to count
     *   }
     * })
    **/
    count<T extends praktikumCountArgs>(
      args?: Subset<T, praktikumCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PraktikumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Praktikum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PraktikumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PraktikumAggregateArgs>(args: Subset<T, PraktikumAggregateArgs>): Prisma.PrismaPromise<GetPraktikumAggregateType<T>>

    /**
     * Group by Praktikum.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {praktikumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends praktikumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: praktikumGroupByArgs['orderBy'] }
        : { orderBy?: praktikumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, praktikumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPraktikumGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the praktikum model
   */
  readonly fields: praktikumFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for praktikum.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__praktikumClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lab<T extends labDefaultArgs<ExtArgs> = {}>(args?: Subset<T, labDefaultArgs<ExtArgs>>): Prisma__labClient<$Result.GetResult<Prisma.$labPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pendaftaran<T extends praktikum$pendaftaranArgs<ExtArgs> = {}>(args?: Subset<T, praktikum$pendaftaranArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pendaftaranPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jadwal<T extends praktikum$jadwalArgs<ExtArgs> = {}>(args?: Subset<T, praktikum$jadwalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jadwalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modul<T extends praktikum$modulArgs<ExtArgs> = {}>(args?: Subset<T, praktikum$modulArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$modulPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tugas<T extends praktikum$tugasArgs<ExtArgs> = {}>(args?: Subset<T, praktikum$tugasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tugasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pengumuman<T extends praktikum$pengumumanArgs<ExtArgs> = {}>(args?: Subset<T, praktikum$pengumumanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pengumumanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the praktikum model
   */
  interface praktikumFieldRefs {
    readonly id: FieldRef<"praktikum", 'Int'>
    readonly nama_praktikum: FieldRef<"praktikum", 'String'>
    readonly lab_id: FieldRef<"praktikum", 'Int'>
    readonly dibuat_pada: FieldRef<"praktikum", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * praktikum findUnique
   */
  export type praktikumFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praktikum
     */
    select?: praktikumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praktikum
     */
    omit?: praktikumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praktikumInclude<ExtArgs> | null
    /**
     * Filter, which praktikum to fetch.
     */
    where: praktikumWhereUniqueInput
  }

  /**
   * praktikum findUniqueOrThrow
   */
  export type praktikumFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praktikum
     */
    select?: praktikumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praktikum
     */
    omit?: praktikumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praktikumInclude<ExtArgs> | null
    /**
     * Filter, which praktikum to fetch.
     */
    where: praktikumWhereUniqueInput
  }

  /**
   * praktikum findFirst
   */
  export type praktikumFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praktikum
     */
    select?: praktikumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praktikum
     */
    omit?: praktikumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praktikumInclude<ExtArgs> | null
    /**
     * Filter, which praktikum to fetch.
     */
    where?: praktikumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of praktikums to fetch.
     */
    orderBy?: praktikumOrderByWithRelationInput | praktikumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for praktikums.
     */
    cursor?: praktikumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` praktikums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` praktikums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of praktikums.
     */
    distinct?: PraktikumScalarFieldEnum | PraktikumScalarFieldEnum[]
  }

  /**
   * praktikum findFirstOrThrow
   */
  export type praktikumFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praktikum
     */
    select?: praktikumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praktikum
     */
    omit?: praktikumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praktikumInclude<ExtArgs> | null
    /**
     * Filter, which praktikum to fetch.
     */
    where?: praktikumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of praktikums to fetch.
     */
    orderBy?: praktikumOrderByWithRelationInput | praktikumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for praktikums.
     */
    cursor?: praktikumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` praktikums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` praktikums.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of praktikums.
     */
    distinct?: PraktikumScalarFieldEnum | PraktikumScalarFieldEnum[]
  }

  /**
   * praktikum findMany
   */
  export type praktikumFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praktikum
     */
    select?: praktikumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praktikum
     */
    omit?: praktikumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praktikumInclude<ExtArgs> | null
    /**
     * Filter, which praktikums to fetch.
     */
    where?: praktikumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of praktikums to fetch.
     */
    orderBy?: praktikumOrderByWithRelationInput | praktikumOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing praktikums.
     */
    cursor?: praktikumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` praktikums from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` praktikums.
     */
    skip?: number
    distinct?: PraktikumScalarFieldEnum | PraktikumScalarFieldEnum[]
  }

  /**
   * praktikum create
   */
  export type praktikumCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praktikum
     */
    select?: praktikumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praktikum
     */
    omit?: praktikumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praktikumInclude<ExtArgs> | null
    /**
     * The data needed to create a praktikum.
     */
    data: XOR<praktikumCreateInput, praktikumUncheckedCreateInput>
  }

  /**
   * praktikum createMany
   */
  export type praktikumCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many praktikums.
     */
    data: praktikumCreateManyInput | praktikumCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * praktikum update
   */
  export type praktikumUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praktikum
     */
    select?: praktikumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praktikum
     */
    omit?: praktikumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praktikumInclude<ExtArgs> | null
    /**
     * The data needed to update a praktikum.
     */
    data: XOR<praktikumUpdateInput, praktikumUncheckedUpdateInput>
    /**
     * Choose, which praktikum to update.
     */
    where: praktikumWhereUniqueInput
  }

  /**
   * praktikum updateMany
   */
  export type praktikumUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update praktikums.
     */
    data: XOR<praktikumUpdateManyMutationInput, praktikumUncheckedUpdateManyInput>
    /**
     * Filter which praktikums to update
     */
    where?: praktikumWhereInput
    /**
     * Limit how many praktikums to update.
     */
    limit?: number
  }

  /**
   * praktikum upsert
   */
  export type praktikumUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praktikum
     */
    select?: praktikumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praktikum
     */
    omit?: praktikumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praktikumInclude<ExtArgs> | null
    /**
     * The filter to search for the praktikum to update in case it exists.
     */
    where: praktikumWhereUniqueInput
    /**
     * In case the praktikum found by the `where` argument doesn't exist, create a new praktikum with this data.
     */
    create: XOR<praktikumCreateInput, praktikumUncheckedCreateInput>
    /**
     * In case the praktikum was found with the provided `where` argument, update it with this data.
     */
    update: XOR<praktikumUpdateInput, praktikumUncheckedUpdateInput>
  }

  /**
   * praktikum delete
   */
  export type praktikumDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praktikum
     */
    select?: praktikumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praktikum
     */
    omit?: praktikumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praktikumInclude<ExtArgs> | null
    /**
     * Filter which praktikum to delete.
     */
    where: praktikumWhereUniqueInput
  }

  /**
   * praktikum deleteMany
   */
  export type praktikumDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which praktikums to delete
     */
    where?: praktikumWhereInput
    /**
     * Limit how many praktikums to delete.
     */
    limit?: number
  }

  /**
   * praktikum.pendaftaran
   */
  export type praktikum$pendaftaranArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendaftaran
     */
    select?: pendaftaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pendaftaran
     */
    omit?: pendaftaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendaftaranInclude<ExtArgs> | null
    where?: pendaftaranWhereInput
    orderBy?: pendaftaranOrderByWithRelationInput | pendaftaranOrderByWithRelationInput[]
    cursor?: pendaftaranWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendaftaranScalarFieldEnum | PendaftaranScalarFieldEnum[]
  }

  /**
   * praktikum.jadwal
   */
  export type praktikum$jadwalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jadwal
     */
    select?: jadwalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jadwal
     */
    omit?: jadwalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jadwalInclude<ExtArgs> | null
    where?: jadwalWhereInput
    orderBy?: jadwalOrderByWithRelationInput | jadwalOrderByWithRelationInput[]
    cursor?: jadwalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JadwalScalarFieldEnum | JadwalScalarFieldEnum[]
  }

  /**
   * praktikum.modul
   */
  export type praktikum$modulArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modul
     */
    select?: modulSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modul
     */
    omit?: modulOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulInclude<ExtArgs> | null
    where?: modulWhereInput
    orderBy?: modulOrderByWithRelationInput | modulOrderByWithRelationInput[]
    cursor?: modulWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModulScalarFieldEnum | ModulScalarFieldEnum[]
  }

  /**
   * praktikum.tugas
   */
  export type praktikum$tugasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tugas
     */
    select?: tugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tugas
     */
    omit?: tugasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tugasInclude<ExtArgs> | null
    where?: tugasWhereInput
    orderBy?: tugasOrderByWithRelationInput | tugasOrderByWithRelationInput[]
    cursor?: tugasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TugasScalarFieldEnum | TugasScalarFieldEnum[]
  }

  /**
   * praktikum.pengumuman
   */
  export type praktikum$pengumumanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumuman
     */
    select?: pengumumanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumuman
     */
    omit?: pengumumanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumumanInclude<ExtArgs> | null
    where?: pengumumanWhereInput
    orderBy?: pengumumanOrderByWithRelationInput | pengumumanOrderByWithRelationInput[]
    cursor?: pengumumanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PengumumanScalarFieldEnum | PengumumanScalarFieldEnum[]
  }

  /**
   * praktikum without action
   */
  export type praktikumDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praktikum
     */
    select?: praktikumSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praktikum
     */
    omit?: praktikumOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praktikumInclude<ExtArgs> | null
  }


  /**
   * Model pendaftaran
   */

  export type AggregatePendaftaran = {
    _count: PendaftaranCountAggregateOutputType | null
    _avg: PendaftaranAvgAggregateOutputType | null
    _sum: PendaftaranSumAggregateOutputType | null
    _min: PendaftaranMinAggregateOutputType | null
    _max: PendaftaranMaxAggregateOutputType | null
  }

  export type PendaftaranAvgAggregateOutputType = {
    id: number | null
    praktikum_id: number | null
  }

  export type PendaftaranSumAggregateOutputType = {
    id: number | null
    praktikum_id: number | null
  }

  export type PendaftaranMinAggregateOutputType = {
    id: number | null
    user_id: string | null
    praktikum_id: number | null
    waktu_daftar: Date | null
  }

  export type PendaftaranMaxAggregateOutputType = {
    id: number | null
    user_id: string | null
    praktikum_id: number | null
    waktu_daftar: Date | null
  }

  export type PendaftaranCountAggregateOutputType = {
    id: number
    user_id: number
    praktikum_id: number
    waktu_daftar: number
    _all: number
  }


  export type PendaftaranAvgAggregateInputType = {
    id?: true
    praktikum_id?: true
  }

  export type PendaftaranSumAggregateInputType = {
    id?: true
    praktikum_id?: true
  }

  export type PendaftaranMinAggregateInputType = {
    id?: true
    user_id?: true
    praktikum_id?: true
    waktu_daftar?: true
  }

  export type PendaftaranMaxAggregateInputType = {
    id?: true
    user_id?: true
    praktikum_id?: true
    waktu_daftar?: true
  }

  export type PendaftaranCountAggregateInputType = {
    id?: true
    user_id?: true
    praktikum_id?: true
    waktu_daftar?: true
    _all?: true
  }

  export type PendaftaranAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pendaftaran to aggregate.
     */
    where?: pendaftaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pendaftarans to fetch.
     */
    orderBy?: pendaftaranOrderByWithRelationInput | pendaftaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pendaftaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pendaftarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pendaftarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pendaftarans
    **/
    _count?: true | PendaftaranCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendaftaranAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendaftaranSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendaftaranMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendaftaranMaxAggregateInputType
  }

  export type GetPendaftaranAggregateType<T extends PendaftaranAggregateArgs> = {
        [P in keyof T & keyof AggregatePendaftaran]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendaftaran[P]>
      : GetScalarType<T[P], AggregatePendaftaran[P]>
  }




  export type pendaftaranGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pendaftaranWhereInput
    orderBy?: pendaftaranOrderByWithAggregationInput | pendaftaranOrderByWithAggregationInput[]
    by: PendaftaranScalarFieldEnum[] | PendaftaranScalarFieldEnum
    having?: pendaftaranScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendaftaranCountAggregateInputType | true
    _avg?: PendaftaranAvgAggregateInputType
    _sum?: PendaftaranSumAggregateInputType
    _min?: PendaftaranMinAggregateInputType
    _max?: PendaftaranMaxAggregateInputType
  }

  export type PendaftaranGroupByOutputType = {
    id: number
    user_id: string
    praktikum_id: number
    waktu_daftar: Date | null
    _count: PendaftaranCountAggregateOutputType | null
    _avg: PendaftaranAvgAggregateOutputType | null
    _sum: PendaftaranSumAggregateOutputType | null
    _min: PendaftaranMinAggregateOutputType | null
    _max: PendaftaranMaxAggregateOutputType | null
  }

  type GetPendaftaranGroupByPayload<T extends pendaftaranGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendaftaranGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendaftaranGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendaftaranGroupByOutputType[P]>
            : GetScalarType<T[P], PendaftaranGroupByOutputType[P]>
        }
      >
    >


  export type pendaftaranSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    praktikum_id?: boolean
    waktu_daftar?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    praktikum?: boolean | praktikumDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendaftaran"]>



  export type pendaftaranSelectScalar = {
    id?: boolean
    user_id?: boolean
    praktikum_id?: boolean
    waktu_daftar?: boolean
  }

  export type pendaftaranOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "praktikum_id" | "waktu_daftar", ExtArgs["result"]["pendaftaran"]>
  export type pendaftaranInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    praktikum?: boolean | praktikumDefaultArgs<ExtArgs>
  }

  export type $pendaftaranPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pendaftaran"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      praktikum: Prisma.$praktikumPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: string
      praktikum_id: number
      waktu_daftar: Date | null
    }, ExtArgs["result"]["pendaftaran"]>
    composites: {}
  }

  type pendaftaranGetPayload<S extends boolean | null | undefined | pendaftaranDefaultArgs> = $Result.GetResult<Prisma.$pendaftaranPayload, S>

  type pendaftaranCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pendaftaranFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PendaftaranCountAggregateInputType | true
    }

  export interface pendaftaranDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pendaftaran'], meta: { name: 'pendaftaran' } }
    /**
     * Find zero or one Pendaftaran that matches the filter.
     * @param {pendaftaranFindUniqueArgs} args - Arguments to find a Pendaftaran
     * @example
     * // Get one Pendaftaran
     * const pendaftaran = await prisma.pendaftaran.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pendaftaranFindUniqueArgs>(args: SelectSubset<T, pendaftaranFindUniqueArgs<ExtArgs>>): Prisma__pendaftaranClient<$Result.GetResult<Prisma.$pendaftaranPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pendaftaran that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pendaftaranFindUniqueOrThrowArgs} args - Arguments to find a Pendaftaran
     * @example
     * // Get one Pendaftaran
     * const pendaftaran = await prisma.pendaftaran.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pendaftaranFindUniqueOrThrowArgs>(args: SelectSubset<T, pendaftaranFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pendaftaranClient<$Result.GetResult<Prisma.$pendaftaranPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pendaftaran that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pendaftaranFindFirstArgs} args - Arguments to find a Pendaftaran
     * @example
     * // Get one Pendaftaran
     * const pendaftaran = await prisma.pendaftaran.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pendaftaranFindFirstArgs>(args?: SelectSubset<T, pendaftaranFindFirstArgs<ExtArgs>>): Prisma__pendaftaranClient<$Result.GetResult<Prisma.$pendaftaranPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pendaftaran that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pendaftaranFindFirstOrThrowArgs} args - Arguments to find a Pendaftaran
     * @example
     * // Get one Pendaftaran
     * const pendaftaran = await prisma.pendaftaran.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pendaftaranFindFirstOrThrowArgs>(args?: SelectSubset<T, pendaftaranFindFirstOrThrowArgs<ExtArgs>>): Prisma__pendaftaranClient<$Result.GetResult<Prisma.$pendaftaranPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pendaftarans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pendaftaranFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pendaftarans
     * const pendaftarans = await prisma.pendaftaran.findMany()
     * 
     * // Get first 10 Pendaftarans
     * const pendaftarans = await prisma.pendaftaran.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendaftaranWithIdOnly = await prisma.pendaftaran.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pendaftaranFindManyArgs>(args?: SelectSubset<T, pendaftaranFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pendaftaranPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pendaftaran.
     * @param {pendaftaranCreateArgs} args - Arguments to create a Pendaftaran.
     * @example
     * // Create one Pendaftaran
     * const Pendaftaran = await prisma.pendaftaran.create({
     *   data: {
     *     // ... data to create a Pendaftaran
     *   }
     * })
     * 
     */
    create<T extends pendaftaranCreateArgs>(args: SelectSubset<T, pendaftaranCreateArgs<ExtArgs>>): Prisma__pendaftaranClient<$Result.GetResult<Prisma.$pendaftaranPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pendaftarans.
     * @param {pendaftaranCreateManyArgs} args - Arguments to create many Pendaftarans.
     * @example
     * // Create many Pendaftarans
     * const pendaftaran = await prisma.pendaftaran.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pendaftaranCreateManyArgs>(args?: SelectSubset<T, pendaftaranCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pendaftaran.
     * @param {pendaftaranDeleteArgs} args - Arguments to delete one Pendaftaran.
     * @example
     * // Delete one Pendaftaran
     * const Pendaftaran = await prisma.pendaftaran.delete({
     *   where: {
     *     // ... filter to delete one Pendaftaran
     *   }
     * })
     * 
     */
    delete<T extends pendaftaranDeleteArgs>(args: SelectSubset<T, pendaftaranDeleteArgs<ExtArgs>>): Prisma__pendaftaranClient<$Result.GetResult<Prisma.$pendaftaranPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pendaftaran.
     * @param {pendaftaranUpdateArgs} args - Arguments to update one Pendaftaran.
     * @example
     * // Update one Pendaftaran
     * const pendaftaran = await prisma.pendaftaran.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pendaftaranUpdateArgs>(args: SelectSubset<T, pendaftaranUpdateArgs<ExtArgs>>): Prisma__pendaftaranClient<$Result.GetResult<Prisma.$pendaftaranPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pendaftarans.
     * @param {pendaftaranDeleteManyArgs} args - Arguments to filter Pendaftarans to delete.
     * @example
     * // Delete a few Pendaftarans
     * const { count } = await prisma.pendaftaran.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pendaftaranDeleteManyArgs>(args?: SelectSubset<T, pendaftaranDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pendaftarans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pendaftaranUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pendaftarans
     * const pendaftaran = await prisma.pendaftaran.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pendaftaranUpdateManyArgs>(args: SelectSubset<T, pendaftaranUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pendaftaran.
     * @param {pendaftaranUpsertArgs} args - Arguments to update or create a Pendaftaran.
     * @example
     * // Update or create a Pendaftaran
     * const pendaftaran = await prisma.pendaftaran.upsert({
     *   create: {
     *     // ... data to create a Pendaftaran
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pendaftaran we want to update
     *   }
     * })
     */
    upsert<T extends pendaftaranUpsertArgs>(args: SelectSubset<T, pendaftaranUpsertArgs<ExtArgs>>): Prisma__pendaftaranClient<$Result.GetResult<Prisma.$pendaftaranPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pendaftarans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pendaftaranCountArgs} args - Arguments to filter Pendaftarans to count.
     * @example
     * // Count the number of Pendaftarans
     * const count = await prisma.pendaftaran.count({
     *   where: {
     *     // ... the filter for the Pendaftarans we want to count
     *   }
     * })
    **/
    count<T extends pendaftaranCountArgs>(
      args?: Subset<T, pendaftaranCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendaftaranCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pendaftaran.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendaftaranAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendaftaranAggregateArgs>(args: Subset<T, PendaftaranAggregateArgs>): Prisma.PrismaPromise<GetPendaftaranAggregateType<T>>

    /**
     * Group by Pendaftaran.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pendaftaranGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pendaftaranGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pendaftaranGroupByArgs['orderBy'] }
        : { orderBy?: pendaftaranGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pendaftaranGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendaftaranGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pendaftaran model
   */
  readonly fields: pendaftaranFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pendaftaran.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pendaftaranClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    praktikum<T extends praktikumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, praktikumDefaultArgs<ExtArgs>>): Prisma__praktikumClient<$Result.GetResult<Prisma.$praktikumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pendaftaran model
   */
  interface pendaftaranFieldRefs {
    readonly id: FieldRef<"pendaftaran", 'Int'>
    readonly user_id: FieldRef<"pendaftaran", 'String'>
    readonly praktikum_id: FieldRef<"pendaftaran", 'Int'>
    readonly waktu_daftar: FieldRef<"pendaftaran", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pendaftaran findUnique
   */
  export type pendaftaranFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendaftaran
     */
    select?: pendaftaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pendaftaran
     */
    omit?: pendaftaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendaftaranInclude<ExtArgs> | null
    /**
     * Filter, which pendaftaran to fetch.
     */
    where: pendaftaranWhereUniqueInput
  }

  /**
   * pendaftaran findUniqueOrThrow
   */
  export type pendaftaranFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendaftaran
     */
    select?: pendaftaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pendaftaran
     */
    omit?: pendaftaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendaftaranInclude<ExtArgs> | null
    /**
     * Filter, which pendaftaran to fetch.
     */
    where: pendaftaranWhereUniqueInput
  }

  /**
   * pendaftaran findFirst
   */
  export type pendaftaranFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendaftaran
     */
    select?: pendaftaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pendaftaran
     */
    omit?: pendaftaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendaftaranInclude<ExtArgs> | null
    /**
     * Filter, which pendaftaran to fetch.
     */
    where?: pendaftaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pendaftarans to fetch.
     */
    orderBy?: pendaftaranOrderByWithRelationInput | pendaftaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pendaftarans.
     */
    cursor?: pendaftaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pendaftarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pendaftarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pendaftarans.
     */
    distinct?: PendaftaranScalarFieldEnum | PendaftaranScalarFieldEnum[]
  }

  /**
   * pendaftaran findFirstOrThrow
   */
  export type pendaftaranFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendaftaran
     */
    select?: pendaftaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pendaftaran
     */
    omit?: pendaftaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendaftaranInclude<ExtArgs> | null
    /**
     * Filter, which pendaftaran to fetch.
     */
    where?: pendaftaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pendaftarans to fetch.
     */
    orderBy?: pendaftaranOrderByWithRelationInput | pendaftaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pendaftarans.
     */
    cursor?: pendaftaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pendaftarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pendaftarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pendaftarans.
     */
    distinct?: PendaftaranScalarFieldEnum | PendaftaranScalarFieldEnum[]
  }

  /**
   * pendaftaran findMany
   */
  export type pendaftaranFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendaftaran
     */
    select?: pendaftaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pendaftaran
     */
    omit?: pendaftaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendaftaranInclude<ExtArgs> | null
    /**
     * Filter, which pendaftarans to fetch.
     */
    where?: pendaftaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pendaftarans to fetch.
     */
    orderBy?: pendaftaranOrderByWithRelationInput | pendaftaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pendaftarans.
     */
    cursor?: pendaftaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pendaftarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pendaftarans.
     */
    skip?: number
    distinct?: PendaftaranScalarFieldEnum | PendaftaranScalarFieldEnum[]
  }

  /**
   * pendaftaran create
   */
  export type pendaftaranCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendaftaran
     */
    select?: pendaftaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pendaftaran
     */
    omit?: pendaftaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendaftaranInclude<ExtArgs> | null
    /**
     * The data needed to create a pendaftaran.
     */
    data: XOR<pendaftaranCreateInput, pendaftaranUncheckedCreateInput>
  }

  /**
   * pendaftaran createMany
   */
  export type pendaftaranCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pendaftarans.
     */
    data: pendaftaranCreateManyInput | pendaftaranCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pendaftaran update
   */
  export type pendaftaranUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendaftaran
     */
    select?: pendaftaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pendaftaran
     */
    omit?: pendaftaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendaftaranInclude<ExtArgs> | null
    /**
     * The data needed to update a pendaftaran.
     */
    data: XOR<pendaftaranUpdateInput, pendaftaranUncheckedUpdateInput>
    /**
     * Choose, which pendaftaran to update.
     */
    where: pendaftaranWhereUniqueInput
  }

  /**
   * pendaftaran updateMany
   */
  export type pendaftaranUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pendaftarans.
     */
    data: XOR<pendaftaranUpdateManyMutationInput, pendaftaranUncheckedUpdateManyInput>
    /**
     * Filter which pendaftarans to update
     */
    where?: pendaftaranWhereInput
    /**
     * Limit how many pendaftarans to update.
     */
    limit?: number
  }

  /**
   * pendaftaran upsert
   */
  export type pendaftaranUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendaftaran
     */
    select?: pendaftaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pendaftaran
     */
    omit?: pendaftaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendaftaranInclude<ExtArgs> | null
    /**
     * The filter to search for the pendaftaran to update in case it exists.
     */
    where: pendaftaranWhereUniqueInput
    /**
     * In case the pendaftaran found by the `where` argument doesn't exist, create a new pendaftaran with this data.
     */
    create: XOR<pendaftaranCreateInput, pendaftaranUncheckedCreateInput>
    /**
     * In case the pendaftaran was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pendaftaranUpdateInput, pendaftaranUncheckedUpdateInput>
  }

  /**
   * pendaftaran delete
   */
  export type pendaftaranDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendaftaran
     */
    select?: pendaftaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pendaftaran
     */
    omit?: pendaftaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendaftaranInclude<ExtArgs> | null
    /**
     * Filter which pendaftaran to delete.
     */
    where: pendaftaranWhereUniqueInput
  }

  /**
   * pendaftaran deleteMany
   */
  export type pendaftaranDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pendaftarans to delete
     */
    where?: pendaftaranWhereInput
    /**
     * Limit how many pendaftarans to delete.
     */
    limit?: number
  }

  /**
   * pendaftaran without action
   */
  export type pendaftaranDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pendaftaran
     */
    select?: pendaftaranSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pendaftaran
     */
    omit?: pendaftaranOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pendaftaranInclude<ExtArgs> | null
  }


  /**
   * Model jadwal
   */

  export type AggregateJadwal = {
    _count: JadwalCountAggregateOutputType | null
    _avg: JadwalAvgAggregateOutputType | null
    _sum: JadwalSumAggregateOutputType | null
    _min: JadwalMinAggregateOutputType | null
    _max: JadwalMaxAggregateOutputType | null
  }

  export type JadwalAvgAggregateOutputType = {
    id: number | null
    praktikum_id: number | null
  }

  export type JadwalSumAggregateOutputType = {
    id: number | null
    praktikum_id: number | null
  }

  export type JadwalMinAggregateOutputType = {
    id: number | null
    praktikum_id: number | null
    tanggal: Date | null
    jam: Date | null
    ruangan: string | null
    user_id: string | null
    nama_pengajar: string | null
    dibuat_pada: Date | null
  }

  export type JadwalMaxAggregateOutputType = {
    id: number | null
    praktikum_id: number | null
    tanggal: Date | null
    jam: Date | null
    ruangan: string | null
    user_id: string | null
    nama_pengajar: string | null
    dibuat_pada: Date | null
  }

  export type JadwalCountAggregateOutputType = {
    id: number
    praktikum_id: number
    tanggal: number
    jam: number
    ruangan: number
    user_id: number
    nama_pengajar: number
    dibuat_pada: number
    _all: number
  }


  export type JadwalAvgAggregateInputType = {
    id?: true
    praktikum_id?: true
  }

  export type JadwalSumAggregateInputType = {
    id?: true
    praktikum_id?: true
  }

  export type JadwalMinAggregateInputType = {
    id?: true
    praktikum_id?: true
    tanggal?: true
    jam?: true
    ruangan?: true
    user_id?: true
    nama_pengajar?: true
    dibuat_pada?: true
  }

  export type JadwalMaxAggregateInputType = {
    id?: true
    praktikum_id?: true
    tanggal?: true
    jam?: true
    ruangan?: true
    user_id?: true
    nama_pengajar?: true
    dibuat_pada?: true
  }

  export type JadwalCountAggregateInputType = {
    id?: true
    praktikum_id?: true
    tanggal?: true
    jam?: true
    ruangan?: true
    user_id?: true
    nama_pengajar?: true
    dibuat_pada?: true
    _all?: true
  }

  export type JadwalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jadwal to aggregate.
     */
    where?: jadwalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jadwals to fetch.
     */
    orderBy?: jadwalOrderByWithRelationInput | jadwalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jadwalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jadwals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jadwals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jadwals
    **/
    _count?: true | JadwalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JadwalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JadwalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JadwalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JadwalMaxAggregateInputType
  }

  export type GetJadwalAggregateType<T extends JadwalAggregateArgs> = {
        [P in keyof T & keyof AggregateJadwal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJadwal[P]>
      : GetScalarType<T[P], AggregateJadwal[P]>
  }




  export type jadwalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jadwalWhereInput
    orderBy?: jadwalOrderByWithAggregationInput | jadwalOrderByWithAggregationInput[]
    by: JadwalScalarFieldEnum[] | JadwalScalarFieldEnum
    having?: jadwalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JadwalCountAggregateInputType | true
    _avg?: JadwalAvgAggregateInputType
    _sum?: JadwalSumAggregateInputType
    _min?: JadwalMinAggregateInputType
    _max?: JadwalMaxAggregateInputType
  }

  export type JadwalGroupByOutputType = {
    id: number
    praktikum_id: number
    tanggal: Date
    jam: Date
    ruangan: string | null
    user_id: string
    nama_pengajar: string | null
    dibuat_pada: Date | null
    _count: JadwalCountAggregateOutputType | null
    _avg: JadwalAvgAggregateOutputType | null
    _sum: JadwalSumAggregateOutputType | null
    _min: JadwalMinAggregateOutputType | null
    _max: JadwalMaxAggregateOutputType | null
  }

  type GetJadwalGroupByPayload<T extends jadwalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JadwalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JadwalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JadwalGroupByOutputType[P]>
            : GetScalarType<T[P], JadwalGroupByOutputType[P]>
        }
      >
    >


  export type jadwalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    praktikum_id?: boolean
    tanggal?: boolean
    jam?: boolean
    ruangan?: boolean
    user_id?: boolean
    nama_pengajar?: boolean
    dibuat_pada?: boolean
    praktikum?: boolean | praktikumDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
    absensi?: boolean | jadwal$absensiArgs<ExtArgs>
    _count?: boolean | JadwalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jadwal"]>



  export type jadwalSelectScalar = {
    id?: boolean
    praktikum_id?: boolean
    tanggal?: boolean
    jam?: boolean
    ruangan?: boolean
    user_id?: boolean
    nama_pengajar?: boolean
    dibuat_pada?: boolean
  }

  export type jadwalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "praktikum_id" | "tanggal" | "jam" | "ruangan" | "user_id" | "nama_pengajar" | "dibuat_pada", ExtArgs["result"]["jadwal"]>
  export type jadwalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    praktikum?: boolean | praktikumDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
    absensi?: boolean | jadwal$absensiArgs<ExtArgs>
    _count?: boolean | JadwalCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $jadwalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "jadwal"
    objects: {
      praktikum: Prisma.$praktikumPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
      absensi: Prisma.$absensiPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      praktikum_id: number
      tanggal: Date
      jam: Date
      ruangan: string | null
      user_id: string
      nama_pengajar: string | null
      dibuat_pada: Date | null
    }, ExtArgs["result"]["jadwal"]>
    composites: {}
  }

  type jadwalGetPayload<S extends boolean | null | undefined | jadwalDefaultArgs> = $Result.GetResult<Prisma.$jadwalPayload, S>

  type jadwalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<jadwalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JadwalCountAggregateInputType | true
    }

  export interface jadwalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['jadwal'], meta: { name: 'jadwal' } }
    /**
     * Find zero or one Jadwal that matches the filter.
     * @param {jadwalFindUniqueArgs} args - Arguments to find a Jadwal
     * @example
     * // Get one Jadwal
     * const jadwal = await prisma.jadwal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends jadwalFindUniqueArgs>(args: SelectSubset<T, jadwalFindUniqueArgs<ExtArgs>>): Prisma__jadwalClient<$Result.GetResult<Prisma.$jadwalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Jadwal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {jadwalFindUniqueOrThrowArgs} args - Arguments to find a Jadwal
     * @example
     * // Get one Jadwal
     * const jadwal = await prisma.jadwal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends jadwalFindUniqueOrThrowArgs>(args: SelectSubset<T, jadwalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__jadwalClient<$Result.GetResult<Prisma.$jadwalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jadwal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jadwalFindFirstArgs} args - Arguments to find a Jadwal
     * @example
     * // Get one Jadwal
     * const jadwal = await prisma.jadwal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends jadwalFindFirstArgs>(args?: SelectSubset<T, jadwalFindFirstArgs<ExtArgs>>): Prisma__jadwalClient<$Result.GetResult<Prisma.$jadwalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jadwal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jadwalFindFirstOrThrowArgs} args - Arguments to find a Jadwal
     * @example
     * // Get one Jadwal
     * const jadwal = await prisma.jadwal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends jadwalFindFirstOrThrowArgs>(args?: SelectSubset<T, jadwalFindFirstOrThrowArgs<ExtArgs>>): Prisma__jadwalClient<$Result.GetResult<Prisma.$jadwalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jadwals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jadwalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jadwals
     * const jadwals = await prisma.jadwal.findMany()
     * 
     * // Get first 10 Jadwals
     * const jadwals = await prisma.jadwal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jadwalWithIdOnly = await prisma.jadwal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends jadwalFindManyArgs>(args?: SelectSubset<T, jadwalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jadwalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Jadwal.
     * @param {jadwalCreateArgs} args - Arguments to create a Jadwal.
     * @example
     * // Create one Jadwal
     * const Jadwal = await prisma.jadwal.create({
     *   data: {
     *     // ... data to create a Jadwal
     *   }
     * })
     * 
     */
    create<T extends jadwalCreateArgs>(args: SelectSubset<T, jadwalCreateArgs<ExtArgs>>): Prisma__jadwalClient<$Result.GetResult<Prisma.$jadwalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jadwals.
     * @param {jadwalCreateManyArgs} args - Arguments to create many Jadwals.
     * @example
     * // Create many Jadwals
     * const jadwal = await prisma.jadwal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends jadwalCreateManyArgs>(args?: SelectSubset<T, jadwalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Jadwal.
     * @param {jadwalDeleteArgs} args - Arguments to delete one Jadwal.
     * @example
     * // Delete one Jadwal
     * const Jadwal = await prisma.jadwal.delete({
     *   where: {
     *     // ... filter to delete one Jadwal
     *   }
     * })
     * 
     */
    delete<T extends jadwalDeleteArgs>(args: SelectSubset<T, jadwalDeleteArgs<ExtArgs>>): Prisma__jadwalClient<$Result.GetResult<Prisma.$jadwalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Jadwal.
     * @param {jadwalUpdateArgs} args - Arguments to update one Jadwal.
     * @example
     * // Update one Jadwal
     * const jadwal = await prisma.jadwal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends jadwalUpdateArgs>(args: SelectSubset<T, jadwalUpdateArgs<ExtArgs>>): Prisma__jadwalClient<$Result.GetResult<Prisma.$jadwalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jadwals.
     * @param {jadwalDeleteManyArgs} args - Arguments to filter Jadwals to delete.
     * @example
     * // Delete a few Jadwals
     * const { count } = await prisma.jadwal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends jadwalDeleteManyArgs>(args?: SelectSubset<T, jadwalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jadwals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jadwalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jadwals
     * const jadwal = await prisma.jadwal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends jadwalUpdateManyArgs>(args: SelectSubset<T, jadwalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jadwal.
     * @param {jadwalUpsertArgs} args - Arguments to update or create a Jadwal.
     * @example
     * // Update or create a Jadwal
     * const jadwal = await prisma.jadwal.upsert({
     *   create: {
     *     // ... data to create a Jadwal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jadwal we want to update
     *   }
     * })
     */
    upsert<T extends jadwalUpsertArgs>(args: SelectSubset<T, jadwalUpsertArgs<ExtArgs>>): Prisma__jadwalClient<$Result.GetResult<Prisma.$jadwalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jadwals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jadwalCountArgs} args - Arguments to filter Jadwals to count.
     * @example
     * // Count the number of Jadwals
     * const count = await prisma.jadwal.count({
     *   where: {
     *     // ... the filter for the Jadwals we want to count
     *   }
     * })
    **/
    count<T extends jadwalCountArgs>(
      args?: Subset<T, jadwalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JadwalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jadwal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JadwalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JadwalAggregateArgs>(args: Subset<T, JadwalAggregateArgs>): Prisma.PrismaPromise<GetJadwalAggregateType<T>>

    /**
     * Group by Jadwal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jadwalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends jadwalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: jadwalGroupByArgs['orderBy'] }
        : { orderBy?: jadwalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, jadwalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJadwalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the jadwal model
   */
  readonly fields: jadwalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for jadwal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__jadwalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    praktikum<T extends praktikumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, praktikumDefaultArgs<ExtArgs>>): Prisma__praktikumClient<$Result.GetResult<Prisma.$praktikumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    absensi<T extends jadwal$absensiArgs<ExtArgs> = {}>(args?: Subset<T, jadwal$absensiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$absensiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the jadwal model
   */
  interface jadwalFieldRefs {
    readonly id: FieldRef<"jadwal", 'Int'>
    readonly praktikum_id: FieldRef<"jadwal", 'Int'>
    readonly tanggal: FieldRef<"jadwal", 'DateTime'>
    readonly jam: FieldRef<"jadwal", 'DateTime'>
    readonly ruangan: FieldRef<"jadwal", 'String'>
    readonly user_id: FieldRef<"jadwal", 'String'>
    readonly nama_pengajar: FieldRef<"jadwal", 'String'>
    readonly dibuat_pada: FieldRef<"jadwal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * jadwal findUnique
   */
  export type jadwalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jadwal
     */
    select?: jadwalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jadwal
     */
    omit?: jadwalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jadwalInclude<ExtArgs> | null
    /**
     * Filter, which jadwal to fetch.
     */
    where: jadwalWhereUniqueInput
  }

  /**
   * jadwal findUniqueOrThrow
   */
  export type jadwalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jadwal
     */
    select?: jadwalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jadwal
     */
    omit?: jadwalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jadwalInclude<ExtArgs> | null
    /**
     * Filter, which jadwal to fetch.
     */
    where: jadwalWhereUniqueInput
  }

  /**
   * jadwal findFirst
   */
  export type jadwalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jadwal
     */
    select?: jadwalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jadwal
     */
    omit?: jadwalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jadwalInclude<ExtArgs> | null
    /**
     * Filter, which jadwal to fetch.
     */
    where?: jadwalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jadwals to fetch.
     */
    orderBy?: jadwalOrderByWithRelationInput | jadwalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jadwals.
     */
    cursor?: jadwalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jadwals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jadwals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jadwals.
     */
    distinct?: JadwalScalarFieldEnum | JadwalScalarFieldEnum[]
  }

  /**
   * jadwal findFirstOrThrow
   */
  export type jadwalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jadwal
     */
    select?: jadwalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jadwal
     */
    omit?: jadwalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jadwalInclude<ExtArgs> | null
    /**
     * Filter, which jadwal to fetch.
     */
    where?: jadwalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jadwals to fetch.
     */
    orderBy?: jadwalOrderByWithRelationInput | jadwalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jadwals.
     */
    cursor?: jadwalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jadwals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jadwals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jadwals.
     */
    distinct?: JadwalScalarFieldEnum | JadwalScalarFieldEnum[]
  }

  /**
   * jadwal findMany
   */
  export type jadwalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jadwal
     */
    select?: jadwalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jadwal
     */
    omit?: jadwalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jadwalInclude<ExtArgs> | null
    /**
     * Filter, which jadwals to fetch.
     */
    where?: jadwalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jadwals to fetch.
     */
    orderBy?: jadwalOrderByWithRelationInput | jadwalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jadwals.
     */
    cursor?: jadwalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jadwals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jadwals.
     */
    skip?: number
    distinct?: JadwalScalarFieldEnum | JadwalScalarFieldEnum[]
  }

  /**
   * jadwal create
   */
  export type jadwalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jadwal
     */
    select?: jadwalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jadwal
     */
    omit?: jadwalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jadwalInclude<ExtArgs> | null
    /**
     * The data needed to create a jadwal.
     */
    data: XOR<jadwalCreateInput, jadwalUncheckedCreateInput>
  }

  /**
   * jadwal createMany
   */
  export type jadwalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many jadwals.
     */
    data: jadwalCreateManyInput | jadwalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * jadwal update
   */
  export type jadwalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jadwal
     */
    select?: jadwalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jadwal
     */
    omit?: jadwalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jadwalInclude<ExtArgs> | null
    /**
     * The data needed to update a jadwal.
     */
    data: XOR<jadwalUpdateInput, jadwalUncheckedUpdateInput>
    /**
     * Choose, which jadwal to update.
     */
    where: jadwalWhereUniqueInput
  }

  /**
   * jadwal updateMany
   */
  export type jadwalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update jadwals.
     */
    data: XOR<jadwalUpdateManyMutationInput, jadwalUncheckedUpdateManyInput>
    /**
     * Filter which jadwals to update
     */
    where?: jadwalWhereInput
    /**
     * Limit how many jadwals to update.
     */
    limit?: number
  }

  /**
   * jadwal upsert
   */
  export type jadwalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jadwal
     */
    select?: jadwalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jadwal
     */
    omit?: jadwalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jadwalInclude<ExtArgs> | null
    /**
     * The filter to search for the jadwal to update in case it exists.
     */
    where: jadwalWhereUniqueInput
    /**
     * In case the jadwal found by the `where` argument doesn't exist, create a new jadwal with this data.
     */
    create: XOR<jadwalCreateInput, jadwalUncheckedCreateInput>
    /**
     * In case the jadwal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jadwalUpdateInput, jadwalUncheckedUpdateInput>
  }

  /**
   * jadwal delete
   */
  export type jadwalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jadwal
     */
    select?: jadwalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jadwal
     */
    omit?: jadwalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jadwalInclude<ExtArgs> | null
    /**
     * Filter which jadwal to delete.
     */
    where: jadwalWhereUniqueInput
  }

  /**
   * jadwal deleteMany
   */
  export type jadwalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jadwals to delete
     */
    where?: jadwalWhereInput
    /**
     * Limit how many jadwals to delete.
     */
    limit?: number
  }

  /**
   * jadwal.absensi
   */
  export type jadwal$absensiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the absensi
     */
    select?: absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the absensi
     */
    omit?: absensiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: absensiInclude<ExtArgs> | null
    where?: absensiWhereInput
    orderBy?: absensiOrderByWithRelationInput | absensiOrderByWithRelationInput[]
    cursor?: absensiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AbsensiScalarFieldEnum | AbsensiScalarFieldEnum[]
  }

  /**
   * jadwal without action
   */
  export type jadwalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jadwal
     */
    select?: jadwalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jadwal
     */
    omit?: jadwalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jadwalInclude<ExtArgs> | null
  }


  /**
   * Model modul
   */

  export type AggregateModul = {
    _count: ModulCountAggregateOutputType | null
    _avg: ModulAvgAggregateOutputType | null
    _sum: ModulSumAggregateOutputType | null
    _min: ModulMinAggregateOutputType | null
    _max: ModulMaxAggregateOutputType | null
  }

  export type ModulAvgAggregateOutputType = {
    id: number | null
    praktikum_id: number | null
  }

  export type ModulSumAggregateOutputType = {
    id: number | null
    praktikum_id: number | null
  }

  export type ModulMinAggregateOutputType = {
    id: number | null
    praktikum_id: number | null
    judul: string | null
    file_path: string | null
    diunggah_oleh: string | null
    diunggah_pada: Date | null
  }

  export type ModulMaxAggregateOutputType = {
    id: number | null
    praktikum_id: number | null
    judul: string | null
    file_path: string | null
    diunggah_oleh: string | null
    diunggah_pada: Date | null
  }

  export type ModulCountAggregateOutputType = {
    id: number
    praktikum_id: number
    judul: number
    file_path: number
    diunggah_oleh: number
    diunggah_pada: number
    _all: number
  }


  export type ModulAvgAggregateInputType = {
    id?: true
    praktikum_id?: true
  }

  export type ModulSumAggregateInputType = {
    id?: true
    praktikum_id?: true
  }

  export type ModulMinAggregateInputType = {
    id?: true
    praktikum_id?: true
    judul?: true
    file_path?: true
    diunggah_oleh?: true
    diunggah_pada?: true
  }

  export type ModulMaxAggregateInputType = {
    id?: true
    praktikum_id?: true
    judul?: true
    file_path?: true
    diunggah_oleh?: true
    diunggah_pada?: true
  }

  export type ModulCountAggregateInputType = {
    id?: true
    praktikum_id?: true
    judul?: true
    file_path?: true
    diunggah_oleh?: true
    diunggah_pada?: true
    _all?: true
  }

  export type ModulAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which modul to aggregate.
     */
    where?: modulWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of moduls to fetch.
     */
    orderBy?: modulOrderByWithRelationInput | modulOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: modulWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` moduls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` moduls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned moduls
    **/
    _count?: true | ModulCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModulAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModulSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModulMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModulMaxAggregateInputType
  }

  export type GetModulAggregateType<T extends ModulAggregateArgs> = {
        [P in keyof T & keyof AggregateModul]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModul[P]>
      : GetScalarType<T[P], AggregateModul[P]>
  }




  export type modulGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: modulWhereInput
    orderBy?: modulOrderByWithAggregationInput | modulOrderByWithAggregationInput[]
    by: ModulScalarFieldEnum[] | ModulScalarFieldEnum
    having?: modulScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModulCountAggregateInputType | true
    _avg?: ModulAvgAggregateInputType
    _sum?: ModulSumAggregateInputType
    _min?: ModulMinAggregateInputType
    _max?: ModulMaxAggregateInputType
  }

  export type ModulGroupByOutputType = {
    id: number
    praktikum_id: number
    judul: string
    file_path: string
    diunggah_oleh: string
    diunggah_pada: Date | null
    _count: ModulCountAggregateOutputType | null
    _avg: ModulAvgAggregateOutputType | null
    _sum: ModulSumAggregateOutputType | null
    _min: ModulMinAggregateOutputType | null
    _max: ModulMaxAggregateOutputType | null
  }

  type GetModulGroupByPayload<T extends modulGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModulGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModulGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModulGroupByOutputType[P]>
            : GetScalarType<T[P], ModulGroupByOutputType[P]>
        }
      >
    >


  export type modulSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    praktikum_id?: boolean
    judul?: boolean
    file_path?: boolean
    diunggah_oleh?: boolean
    diunggah_pada?: boolean
    praktikum?: boolean | praktikumDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["modul"]>



  export type modulSelectScalar = {
    id?: boolean
    praktikum_id?: boolean
    judul?: boolean
    file_path?: boolean
    diunggah_oleh?: boolean
    diunggah_pada?: boolean
  }

  export type modulOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "praktikum_id" | "judul" | "file_path" | "diunggah_oleh" | "diunggah_pada", ExtArgs["result"]["modul"]>
  export type modulInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    praktikum?: boolean | praktikumDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $modulPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "modul"
    objects: {
      praktikum: Prisma.$praktikumPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      praktikum_id: number
      judul: string
      file_path: string
      diunggah_oleh: string
      diunggah_pada: Date | null
    }, ExtArgs["result"]["modul"]>
    composites: {}
  }

  type modulGetPayload<S extends boolean | null | undefined | modulDefaultArgs> = $Result.GetResult<Prisma.$modulPayload, S>

  type modulCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<modulFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModulCountAggregateInputType | true
    }

  export interface modulDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['modul'], meta: { name: 'modul' } }
    /**
     * Find zero or one Modul that matches the filter.
     * @param {modulFindUniqueArgs} args - Arguments to find a Modul
     * @example
     * // Get one Modul
     * const modul = await prisma.modul.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends modulFindUniqueArgs>(args: SelectSubset<T, modulFindUniqueArgs<ExtArgs>>): Prisma__modulClient<$Result.GetResult<Prisma.$modulPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Modul that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {modulFindUniqueOrThrowArgs} args - Arguments to find a Modul
     * @example
     * // Get one Modul
     * const modul = await prisma.modul.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends modulFindUniqueOrThrowArgs>(args: SelectSubset<T, modulFindUniqueOrThrowArgs<ExtArgs>>): Prisma__modulClient<$Result.GetResult<Prisma.$modulPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Modul that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modulFindFirstArgs} args - Arguments to find a Modul
     * @example
     * // Get one Modul
     * const modul = await prisma.modul.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends modulFindFirstArgs>(args?: SelectSubset<T, modulFindFirstArgs<ExtArgs>>): Prisma__modulClient<$Result.GetResult<Prisma.$modulPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Modul that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modulFindFirstOrThrowArgs} args - Arguments to find a Modul
     * @example
     * // Get one Modul
     * const modul = await prisma.modul.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends modulFindFirstOrThrowArgs>(args?: SelectSubset<T, modulFindFirstOrThrowArgs<ExtArgs>>): Prisma__modulClient<$Result.GetResult<Prisma.$modulPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Moduls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modulFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Moduls
     * const moduls = await prisma.modul.findMany()
     * 
     * // Get first 10 Moduls
     * const moduls = await prisma.modul.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modulWithIdOnly = await prisma.modul.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends modulFindManyArgs>(args?: SelectSubset<T, modulFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$modulPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Modul.
     * @param {modulCreateArgs} args - Arguments to create a Modul.
     * @example
     * // Create one Modul
     * const Modul = await prisma.modul.create({
     *   data: {
     *     // ... data to create a Modul
     *   }
     * })
     * 
     */
    create<T extends modulCreateArgs>(args: SelectSubset<T, modulCreateArgs<ExtArgs>>): Prisma__modulClient<$Result.GetResult<Prisma.$modulPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Moduls.
     * @param {modulCreateManyArgs} args - Arguments to create many Moduls.
     * @example
     * // Create many Moduls
     * const modul = await prisma.modul.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends modulCreateManyArgs>(args?: SelectSubset<T, modulCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Modul.
     * @param {modulDeleteArgs} args - Arguments to delete one Modul.
     * @example
     * // Delete one Modul
     * const Modul = await prisma.modul.delete({
     *   where: {
     *     // ... filter to delete one Modul
     *   }
     * })
     * 
     */
    delete<T extends modulDeleteArgs>(args: SelectSubset<T, modulDeleteArgs<ExtArgs>>): Prisma__modulClient<$Result.GetResult<Prisma.$modulPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Modul.
     * @param {modulUpdateArgs} args - Arguments to update one Modul.
     * @example
     * // Update one Modul
     * const modul = await prisma.modul.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends modulUpdateArgs>(args: SelectSubset<T, modulUpdateArgs<ExtArgs>>): Prisma__modulClient<$Result.GetResult<Prisma.$modulPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Moduls.
     * @param {modulDeleteManyArgs} args - Arguments to filter Moduls to delete.
     * @example
     * // Delete a few Moduls
     * const { count } = await prisma.modul.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends modulDeleteManyArgs>(args?: SelectSubset<T, modulDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Moduls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modulUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Moduls
     * const modul = await prisma.modul.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends modulUpdateManyArgs>(args: SelectSubset<T, modulUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Modul.
     * @param {modulUpsertArgs} args - Arguments to update or create a Modul.
     * @example
     * // Update or create a Modul
     * const modul = await prisma.modul.upsert({
     *   create: {
     *     // ... data to create a Modul
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Modul we want to update
     *   }
     * })
     */
    upsert<T extends modulUpsertArgs>(args: SelectSubset<T, modulUpsertArgs<ExtArgs>>): Prisma__modulClient<$Result.GetResult<Prisma.$modulPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Moduls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modulCountArgs} args - Arguments to filter Moduls to count.
     * @example
     * // Count the number of Moduls
     * const count = await prisma.modul.count({
     *   where: {
     *     // ... the filter for the Moduls we want to count
     *   }
     * })
    **/
    count<T extends modulCountArgs>(
      args?: Subset<T, modulCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModulCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Modul.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModulAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModulAggregateArgs>(args: Subset<T, ModulAggregateArgs>): Prisma.PrismaPromise<GetModulAggregateType<T>>

    /**
     * Group by Modul.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modulGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends modulGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: modulGroupByArgs['orderBy'] }
        : { orderBy?: modulGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, modulGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModulGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the modul model
   */
  readonly fields: modulFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for modul.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__modulClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    praktikum<T extends praktikumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, praktikumDefaultArgs<ExtArgs>>): Prisma__praktikumClient<$Result.GetResult<Prisma.$praktikumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the modul model
   */
  interface modulFieldRefs {
    readonly id: FieldRef<"modul", 'Int'>
    readonly praktikum_id: FieldRef<"modul", 'Int'>
    readonly judul: FieldRef<"modul", 'String'>
    readonly file_path: FieldRef<"modul", 'String'>
    readonly diunggah_oleh: FieldRef<"modul", 'String'>
    readonly diunggah_pada: FieldRef<"modul", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * modul findUnique
   */
  export type modulFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modul
     */
    select?: modulSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modul
     */
    omit?: modulOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulInclude<ExtArgs> | null
    /**
     * Filter, which modul to fetch.
     */
    where: modulWhereUniqueInput
  }

  /**
   * modul findUniqueOrThrow
   */
  export type modulFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modul
     */
    select?: modulSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modul
     */
    omit?: modulOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulInclude<ExtArgs> | null
    /**
     * Filter, which modul to fetch.
     */
    where: modulWhereUniqueInput
  }

  /**
   * modul findFirst
   */
  export type modulFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modul
     */
    select?: modulSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modul
     */
    omit?: modulOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulInclude<ExtArgs> | null
    /**
     * Filter, which modul to fetch.
     */
    where?: modulWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of moduls to fetch.
     */
    orderBy?: modulOrderByWithRelationInput | modulOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for moduls.
     */
    cursor?: modulWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` moduls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` moduls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of moduls.
     */
    distinct?: ModulScalarFieldEnum | ModulScalarFieldEnum[]
  }

  /**
   * modul findFirstOrThrow
   */
  export type modulFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modul
     */
    select?: modulSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modul
     */
    omit?: modulOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulInclude<ExtArgs> | null
    /**
     * Filter, which modul to fetch.
     */
    where?: modulWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of moduls to fetch.
     */
    orderBy?: modulOrderByWithRelationInput | modulOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for moduls.
     */
    cursor?: modulWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` moduls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` moduls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of moduls.
     */
    distinct?: ModulScalarFieldEnum | ModulScalarFieldEnum[]
  }

  /**
   * modul findMany
   */
  export type modulFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modul
     */
    select?: modulSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modul
     */
    omit?: modulOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulInclude<ExtArgs> | null
    /**
     * Filter, which moduls to fetch.
     */
    where?: modulWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of moduls to fetch.
     */
    orderBy?: modulOrderByWithRelationInput | modulOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing moduls.
     */
    cursor?: modulWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` moduls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` moduls.
     */
    skip?: number
    distinct?: ModulScalarFieldEnum | ModulScalarFieldEnum[]
  }

  /**
   * modul create
   */
  export type modulCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modul
     */
    select?: modulSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modul
     */
    omit?: modulOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulInclude<ExtArgs> | null
    /**
     * The data needed to create a modul.
     */
    data: XOR<modulCreateInput, modulUncheckedCreateInput>
  }

  /**
   * modul createMany
   */
  export type modulCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many moduls.
     */
    data: modulCreateManyInput | modulCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * modul update
   */
  export type modulUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modul
     */
    select?: modulSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modul
     */
    omit?: modulOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulInclude<ExtArgs> | null
    /**
     * The data needed to update a modul.
     */
    data: XOR<modulUpdateInput, modulUncheckedUpdateInput>
    /**
     * Choose, which modul to update.
     */
    where: modulWhereUniqueInput
  }

  /**
   * modul updateMany
   */
  export type modulUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update moduls.
     */
    data: XOR<modulUpdateManyMutationInput, modulUncheckedUpdateManyInput>
    /**
     * Filter which moduls to update
     */
    where?: modulWhereInput
    /**
     * Limit how many moduls to update.
     */
    limit?: number
  }

  /**
   * modul upsert
   */
  export type modulUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modul
     */
    select?: modulSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modul
     */
    omit?: modulOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulInclude<ExtArgs> | null
    /**
     * The filter to search for the modul to update in case it exists.
     */
    where: modulWhereUniqueInput
    /**
     * In case the modul found by the `where` argument doesn't exist, create a new modul with this data.
     */
    create: XOR<modulCreateInput, modulUncheckedCreateInput>
    /**
     * In case the modul was found with the provided `where` argument, update it with this data.
     */
    update: XOR<modulUpdateInput, modulUncheckedUpdateInput>
  }

  /**
   * modul delete
   */
  export type modulDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modul
     */
    select?: modulSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modul
     */
    omit?: modulOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulInclude<ExtArgs> | null
    /**
     * Filter which modul to delete.
     */
    where: modulWhereUniqueInput
  }

  /**
   * modul deleteMany
   */
  export type modulDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which moduls to delete
     */
    where?: modulWhereInput
    /**
     * Limit how many moduls to delete.
     */
    limit?: number
  }

  /**
   * modul without action
   */
  export type modulDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the modul
     */
    select?: modulSelect<ExtArgs> | null
    /**
     * Omit specific fields from the modul
     */
    omit?: modulOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modulInclude<ExtArgs> | null
  }


  /**
   * Model tugas
   */

  export type AggregateTugas = {
    _count: TugasCountAggregateOutputType | null
    _avg: TugasAvgAggregateOutputType | null
    _sum: TugasSumAggregateOutputType | null
    _min: TugasMinAggregateOutputType | null
    _max: TugasMaxAggregateOutputType | null
  }

  export type TugasAvgAggregateOutputType = {
    id: number | null
    praktikum_id: number | null
  }

  export type TugasSumAggregateOutputType = {
    id: number | null
    praktikum_id: number | null
  }

  export type TugasMinAggregateOutputType = {
    id: number | null
    praktikum_id: number | null
    judul: string | null
    deskripsi: string | null
    fileTugas: string | null
    batas_waktu: Date | null
    dibuat_pada: Date | null
    status: $Enums.StatusTugas | null
  }

  export type TugasMaxAggregateOutputType = {
    id: number | null
    praktikum_id: number | null
    judul: string | null
    deskripsi: string | null
    fileTugas: string | null
    batas_waktu: Date | null
    dibuat_pada: Date | null
    status: $Enums.StatusTugas | null
  }

  export type TugasCountAggregateOutputType = {
    id: number
    praktikum_id: number
    judul: number
    deskripsi: number
    fileTugas: number
    batas_waktu: number
    dibuat_pada: number
    status: number
    _all: number
  }


  export type TugasAvgAggregateInputType = {
    id?: true
    praktikum_id?: true
  }

  export type TugasSumAggregateInputType = {
    id?: true
    praktikum_id?: true
  }

  export type TugasMinAggregateInputType = {
    id?: true
    praktikum_id?: true
    judul?: true
    deskripsi?: true
    fileTugas?: true
    batas_waktu?: true
    dibuat_pada?: true
    status?: true
  }

  export type TugasMaxAggregateInputType = {
    id?: true
    praktikum_id?: true
    judul?: true
    deskripsi?: true
    fileTugas?: true
    batas_waktu?: true
    dibuat_pada?: true
    status?: true
  }

  export type TugasCountAggregateInputType = {
    id?: true
    praktikum_id?: true
    judul?: true
    deskripsi?: true
    fileTugas?: true
    batas_waktu?: true
    dibuat_pada?: true
    status?: true
    _all?: true
  }

  export type TugasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tugas to aggregate.
     */
    where?: tugasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tugases to fetch.
     */
    orderBy?: tugasOrderByWithRelationInput | tugasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tugasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tugases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tugases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tugases
    **/
    _count?: true | TugasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TugasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TugasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TugasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TugasMaxAggregateInputType
  }

  export type GetTugasAggregateType<T extends TugasAggregateArgs> = {
        [P in keyof T & keyof AggregateTugas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTugas[P]>
      : GetScalarType<T[P], AggregateTugas[P]>
  }




  export type tugasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tugasWhereInput
    orderBy?: tugasOrderByWithAggregationInput | tugasOrderByWithAggregationInput[]
    by: TugasScalarFieldEnum[] | TugasScalarFieldEnum
    having?: tugasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TugasCountAggregateInputType | true
    _avg?: TugasAvgAggregateInputType
    _sum?: TugasSumAggregateInputType
    _min?: TugasMinAggregateInputType
    _max?: TugasMaxAggregateInputType
  }

  export type TugasGroupByOutputType = {
    id: number
    praktikum_id: number
    judul: string
    deskripsi: string | null
    fileTugas: string | null
    batas_waktu: Date
    dibuat_pada: Date
    status: $Enums.StatusTugas
    _count: TugasCountAggregateOutputType | null
    _avg: TugasAvgAggregateOutputType | null
    _sum: TugasSumAggregateOutputType | null
    _min: TugasMinAggregateOutputType | null
    _max: TugasMaxAggregateOutputType | null
  }

  type GetTugasGroupByPayload<T extends tugasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TugasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TugasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TugasGroupByOutputType[P]>
            : GetScalarType<T[P], TugasGroupByOutputType[P]>
        }
      >
    >


  export type tugasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    praktikum_id?: boolean
    judul?: boolean
    deskripsi?: boolean
    fileTugas?: boolean
    batas_waktu?: boolean
    dibuat_pada?: boolean
    status?: boolean
    praktikum?: boolean | praktikumDefaultArgs<ExtArgs>
    pengumpulan?: boolean | tugas$pengumpulanArgs<ExtArgs>
    _count?: boolean | TugasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tugas"]>



  export type tugasSelectScalar = {
    id?: boolean
    praktikum_id?: boolean
    judul?: boolean
    deskripsi?: boolean
    fileTugas?: boolean
    batas_waktu?: boolean
    dibuat_pada?: boolean
    status?: boolean
  }

  export type tugasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "praktikum_id" | "judul" | "deskripsi" | "fileTugas" | "batas_waktu" | "dibuat_pada" | "status", ExtArgs["result"]["tugas"]>
  export type tugasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    praktikum?: boolean | praktikumDefaultArgs<ExtArgs>
    pengumpulan?: boolean | tugas$pengumpulanArgs<ExtArgs>
    _count?: boolean | TugasCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $tugasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tugas"
    objects: {
      praktikum: Prisma.$praktikumPayload<ExtArgs>
      pengumpulan: Prisma.$pengumpulanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      praktikum_id: number
      judul: string
      deskripsi: string | null
      fileTugas: string | null
      batas_waktu: Date
      dibuat_pada: Date
      status: $Enums.StatusTugas
    }, ExtArgs["result"]["tugas"]>
    composites: {}
  }

  type tugasGetPayload<S extends boolean | null | undefined | tugasDefaultArgs> = $Result.GetResult<Prisma.$tugasPayload, S>

  type tugasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tugasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TugasCountAggregateInputType | true
    }

  export interface tugasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tugas'], meta: { name: 'tugas' } }
    /**
     * Find zero or one Tugas that matches the filter.
     * @param {tugasFindUniqueArgs} args - Arguments to find a Tugas
     * @example
     * // Get one Tugas
     * const tugas = await prisma.tugas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tugasFindUniqueArgs>(args: SelectSubset<T, tugasFindUniqueArgs<ExtArgs>>): Prisma__tugasClient<$Result.GetResult<Prisma.$tugasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tugas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tugasFindUniqueOrThrowArgs} args - Arguments to find a Tugas
     * @example
     * // Get one Tugas
     * const tugas = await prisma.tugas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tugasFindUniqueOrThrowArgs>(args: SelectSubset<T, tugasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tugasClient<$Result.GetResult<Prisma.$tugasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tugas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tugasFindFirstArgs} args - Arguments to find a Tugas
     * @example
     * // Get one Tugas
     * const tugas = await prisma.tugas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tugasFindFirstArgs>(args?: SelectSubset<T, tugasFindFirstArgs<ExtArgs>>): Prisma__tugasClient<$Result.GetResult<Prisma.$tugasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tugas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tugasFindFirstOrThrowArgs} args - Arguments to find a Tugas
     * @example
     * // Get one Tugas
     * const tugas = await prisma.tugas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tugasFindFirstOrThrowArgs>(args?: SelectSubset<T, tugasFindFirstOrThrowArgs<ExtArgs>>): Prisma__tugasClient<$Result.GetResult<Prisma.$tugasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tugases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tugasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tugases
     * const tugases = await prisma.tugas.findMany()
     * 
     * // Get first 10 Tugases
     * const tugases = await prisma.tugas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tugasWithIdOnly = await prisma.tugas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tugasFindManyArgs>(args?: SelectSubset<T, tugasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tugasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tugas.
     * @param {tugasCreateArgs} args - Arguments to create a Tugas.
     * @example
     * // Create one Tugas
     * const Tugas = await prisma.tugas.create({
     *   data: {
     *     // ... data to create a Tugas
     *   }
     * })
     * 
     */
    create<T extends tugasCreateArgs>(args: SelectSubset<T, tugasCreateArgs<ExtArgs>>): Prisma__tugasClient<$Result.GetResult<Prisma.$tugasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tugases.
     * @param {tugasCreateManyArgs} args - Arguments to create many Tugases.
     * @example
     * // Create many Tugases
     * const tugas = await prisma.tugas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tugasCreateManyArgs>(args?: SelectSubset<T, tugasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tugas.
     * @param {tugasDeleteArgs} args - Arguments to delete one Tugas.
     * @example
     * // Delete one Tugas
     * const Tugas = await prisma.tugas.delete({
     *   where: {
     *     // ... filter to delete one Tugas
     *   }
     * })
     * 
     */
    delete<T extends tugasDeleteArgs>(args: SelectSubset<T, tugasDeleteArgs<ExtArgs>>): Prisma__tugasClient<$Result.GetResult<Prisma.$tugasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tugas.
     * @param {tugasUpdateArgs} args - Arguments to update one Tugas.
     * @example
     * // Update one Tugas
     * const tugas = await prisma.tugas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tugasUpdateArgs>(args: SelectSubset<T, tugasUpdateArgs<ExtArgs>>): Prisma__tugasClient<$Result.GetResult<Prisma.$tugasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tugases.
     * @param {tugasDeleteManyArgs} args - Arguments to filter Tugases to delete.
     * @example
     * // Delete a few Tugases
     * const { count } = await prisma.tugas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tugasDeleteManyArgs>(args?: SelectSubset<T, tugasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tugases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tugasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tugases
     * const tugas = await prisma.tugas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tugasUpdateManyArgs>(args: SelectSubset<T, tugasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tugas.
     * @param {tugasUpsertArgs} args - Arguments to update or create a Tugas.
     * @example
     * // Update or create a Tugas
     * const tugas = await prisma.tugas.upsert({
     *   create: {
     *     // ... data to create a Tugas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tugas we want to update
     *   }
     * })
     */
    upsert<T extends tugasUpsertArgs>(args: SelectSubset<T, tugasUpsertArgs<ExtArgs>>): Prisma__tugasClient<$Result.GetResult<Prisma.$tugasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tugases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tugasCountArgs} args - Arguments to filter Tugases to count.
     * @example
     * // Count the number of Tugases
     * const count = await prisma.tugas.count({
     *   where: {
     *     // ... the filter for the Tugases we want to count
     *   }
     * })
    **/
    count<T extends tugasCountArgs>(
      args?: Subset<T, tugasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TugasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tugas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TugasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TugasAggregateArgs>(args: Subset<T, TugasAggregateArgs>): Prisma.PrismaPromise<GetTugasAggregateType<T>>

    /**
     * Group by Tugas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tugasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tugasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tugasGroupByArgs['orderBy'] }
        : { orderBy?: tugasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tugasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTugasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tugas model
   */
  readonly fields: tugasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tugas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tugasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    praktikum<T extends praktikumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, praktikumDefaultArgs<ExtArgs>>): Prisma__praktikumClient<$Result.GetResult<Prisma.$praktikumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pengumpulan<T extends tugas$pengumpulanArgs<ExtArgs> = {}>(args?: Subset<T, tugas$pengumpulanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pengumpulanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tugas model
   */
  interface tugasFieldRefs {
    readonly id: FieldRef<"tugas", 'Int'>
    readonly praktikum_id: FieldRef<"tugas", 'Int'>
    readonly judul: FieldRef<"tugas", 'String'>
    readonly deskripsi: FieldRef<"tugas", 'String'>
    readonly fileTugas: FieldRef<"tugas", 'String'>
    readonly batas_waktu: FieldRef<"tugas", 'DateTime'>
    readonly dibuat_pada: FieldRef<"tugas", 'DateTime'>
    readonly status: FieldRef<"tugas", 'StatusTugas'>
  }
    

  // Custom InputTypes
  /**
   * tugas findUnique
   */
  export type tugasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tugas
     */
    select?: tugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tugas
     */
    omit?: tugasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tugasInclude<ExtArgs> | null
    /**
     * Filter, which tugas to fetch.
     */
    where: tugasWhereUniqueInput
  }

  /**
   * tugas findUniqueOrThrow
   */
  export type tugasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tugas
     */
    select?: tugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tugas
     */
    omit?: tugasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tugasInclude<ExtArgs> | null
    /**
     * Filter, which tugas to fetch.
     */
    where: tugasWhereUniqueInput
  }

  /**
   * tugas findFirst
   */
  export type tugasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tugas
     */
    select?: tugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tugas
     */
    omit?: tugasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tugasInclude<ExtArgs> | null
    /**
     * Filter, which tugas to fetch.
     */
    where?: tugasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tugases to fetch.
     */
    orderBy?: tugasOrderByWithRelationInput | tugasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tugases.
     */
    cursor?: tugasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tugases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tugases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tugases.
     */
    distinct?: TugasScalarFieldEnum | TugasScalarFieldEnum[]
  }

  /**
   * tugas findFirstOrThrow
   */
  export type tugasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tugas
     */
    select?: tugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tugas
     */
    omit?: tugasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tugasInclude<ExtArgs> | null
    /**
     * Filter, which tugas to fetch.
     */
    where?: tugasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tugases to fetch.
     */
    orderBy?: tugasOrderByWithRelationInput | tugasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tugases.
     */
    cursor?: tugasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tugases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tugases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tugases.
     */
    distinct?: TugasScalarFieldEnum | TugasScalarFieldEnum[]
  }

  /**
   * tugas findMany
   */
  export type tugasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tugas
     */
    select?: tugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tugas
     */
    omit?: tugasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tugasInclude<ExtArgs> | null
    /**
     * Filter, which tugases to fetch.
     */
    where?: tugasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tugases to fetch.
     */
    orderBy?: tugasOrderByWithRelationInput | tugasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tugases.
     */
    cursor?: tugasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tugases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tugases.
     */
    skip?: number
    distinct?: TugasScalarFieldEnum | TugasScalarFieldEnum[]
  }

  /**
   * tugas create
   */
  export type tugasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tugas
     */
    select?: tugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tugas
     */
    omit?: tugasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tugasInclude<ExtArgs> | null
    /**
     * The data needed to create a tugas.
     */
    data: XOR<tugasCreateInput, tugasUncheckedCreateInput>
  }

  /**
   * tugas createMany
   */
  export type tugasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tugases.
     */
    data: tugasCreateManyInput | tugasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tugas update
   */
  export type tugasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tugas
     */
    select?: tugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tugas
     */
    omit?: tugasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tugasInclude<ExtArgs> | null
    /**
     * The data needed to update a tugas.
     */
    data: XOR<tugasUpdateInput, tugasUncheckedUpdateInput>
    /**
     * Choose, which tugas to update.
     */
    where: tugasWhereUniqueInput
  }

  /**
   * tugas updateMany
   */
  export type tugasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tugases.
     */
    data: XOR<tugasUpdateManyMutationInput, tugasUncheckedUpdateManyInput>
    /**
     * Filter which tugases to update
     */
    where?: tugasWhereInput
    /**
     * Limit how many tugases to update.
     */
    limit?: number
  }

  /**
   * tugas upsert
   */
  export type tugasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tugas
     */
    select?: tugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tugas
     */
    omit?: tugasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tugasInclude<ExtArgs> | null
    /**
     * The filter to search for the tugas to update in case it exists.
     */
    where: tugasWhereUniqueInput
    /**
     * In case the tugas found by the `where` argument doesn't exist, create a new tugas with this data.
     */
    create: XOR<tugasCreateInput, tugasUncheckedCreateInput>
    /**
     * In case the tugas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tugasUpdateInput, tugasUncheckedUpdateInput>
  }

  /**
   * tugas delete
   */
  export type tugasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tugas
     */
    select?: tugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tugas
     */
    omit?: tugasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tugasInclude<ExtArgs> | null
    /**
     * Filter which tugas to delete.
     */
    where: tugasWhereUniqueInput
  }

  /**
   * tugas deleteMany
   */
  export type tugasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tugases to delete
     */
    where?: tugasWhereInput
    /**
     * Limit how many tugases to delete.
     */
    limit?: number
  }

  /**
   * tugas.pengumpulan
   */
  export type tugas$pengumpulanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumpulan
     */
    select?: pengumpulanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumpulan
     */
    omit?: pengumpulanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumpulanInclude<ExtArgs> | null
    where?: pengumpulanWhereInput
    orderBy?: pengumpulanOrderByWithRelationInput | pengumpulanOrderByWithRelationInput[]
    cursor?: pengumpulanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PengumpulanScalarFieldEnum | PengumpulanScalarFieldEnum[]
  }

  /**
   * tugas without action
   */
  export type tugasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tugas
     */
    select?: tugasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tugas
     */
    omit?: tugasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tugasInclude<ExtArgs> | null
  }


  /**
   * Model pengumpulan
   */

  export type AggregatePengumpulan = {
    _count: PengumpulanCountAggregateOutputType | null
    _avg: PengumpulanAvgAggregateOutputType | null
    _sum: PengumpulanSumAggregateOutputType | null
    _min: PengumpulanMinAggregateOutputType | null
    _max: PengumpulanMaxAggregateOutputType | null
  }

  export type PengumpulanAvgAggregateOutputType = {
    id: number | null
    tugas_id: number | null
    nilai: number | null
  }

  export type PengumpulanSumAggregateOutputType = {
    id: number | null
    tugas_id: number | null
    nilai: number | null
  }

  export type PengumpulanMinAggregateOutputType = {
    id: number | null
    tugas_id: number | null
    user_id: string | null
    file_path: string | null
    waktu_kirim: Date | null
    nilai: number | null
    catatan: string | null
  }

  export type PengumpulanMaxAggregateOutputType = {
    id: number | null
    tugas_id: number | null
    user_id: string | null
    file_path: string | null
    waktu_kirim: Date | null
    nilai: number | null
    catatan: string | null
  }

  export type PengumpulanCountAggregateOutputType = {
    id: number
    tugas_id: number
    user_id: number
    file_path: number
    waktu_kirim: number
    nilai: number
    catatan: number
    _all: number
  }


  export type PengumpulanAvgAggregateInputType = {
    id?: true
    tugas_id?: true
    nilai?: true
  }

  export type PengumpulanSumAggregateInputType = {
    id?: true
    tugas_id?: true
    nilai?: true
  }

  export type PengumpulanMinAggregateInputType = {
    id?: true
    tugas_id?: true
    user_id?: true
    file_path?: true
    waktu_kirim?: true
    nilai?: true
    catatan?: true
  }

  export type PengumpulanMaxAggregateInputType = {
    id?: true
    tugas_id?: true
    user_id?: true
    file_path?: true
    waktu_kirim?: true
    nilai?: true
    catatan?: true
  }

  export type PengumpulanCountAggregateInputType = {
    id?: true
    tugas_id?: true
    user_id?: true
    file_path?: true
    waktu_kirim?: true
    nilai?: true
    catatan?: true
    _all?: true
  }

  export type PengumpulanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pengumpulan to aggregate.
     */
    where?: pengumpulanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pengumpulans to fetch.
     */
    orderBy?: pengumpulanOrderByWithRelationInput | pengumpulanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pengumpulanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pengumpulans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pengumpulans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pengumpulans
    **/
    _count?: true | PengumpulanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PengumpulanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PengumpulanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PengumpulanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PengumpulanMaxAggregateInputType
  }

  export type GetPengumpulanAggregateType<T extends PengumpulanAggregateArgs> = {
        [P in keyof T & keyof AggregatePengumpulan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePengumpulan[P]>
      : GetScalarType<T[P], AggregatePengumpulan[P]>
  }




  export type pengumpulanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pengumpulanWhereInput
    orderBy?: pengumpulanOrderByWithAggregationInput | pengumpulanOrderByWithAggregationInput[]
    by: PengumpulanScalarFieldEnum[] | PengumpulanScalarFieldEnum
    having?: pengumpulanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PengumpulanCountAggregateInputType | true
    _avg?: PengumpulanAvgAggregateInputType
    _sum?: PengumpulanSumAggregateInputType
    _min?: PengumpulanMinAggregateInputType
    _max?: PengumpulanMaxAggregateInputType
  }

  export type PengumpulanGroupByOutputType = {
    id: number
    tugas_id: number
    user_id: string
    file_path: string | null
    waktu_kirim: Date | null
    nilai: number | null
    catatan: string | null
    _count: PengumpulanCountAggregateOutputType | null
    _avg: PengumpulanAvgAggregateOutputType | null
    _sum: PengumpulanSumAggregateOutputType | null
    _min: PengumpulanMinAggregateOutputType | null
    _max: PengumpulanMaxAggregateOutputType | null
  }

  type GetPengumpulanGroupByPayload<T extends pengumpulanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PengumpulanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PengumpulanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PengumpulanGroupByOutputType[P]>
            : GetScalarType<T[P], PengumpulanGroupByOutputType[P]>
        }
      >
    >


  export type pengumpulanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tugas_id?: boolean
    user_id?: boolean
    file_path?: boolean
    waktu_kirim?: boolean
    nilai?: boolean
    catatan?: boolean
    tugas?: boolean | tugasDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pengumpulan"]>



  export type pengumpulanSelectScalar = {
    id?: boolean
    tugas_id?: boolean
    user_id?: boolean
    file_path?: boolean
    waktu_kirim?: boolean
    nilai?: boolean
    catatan?: boolean
  }

  export type pengumpulanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tugas_id" | "user_id" | "file_path" | "waktu_kirim" | "nilai" | "catatan", ExtArgs["result"]["pengumpulan"]>
  export type pengumpulanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tugas?: boolean | tugasDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $pengumpulanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pengumpulan"
    objects: {
      tugas: Prisma.$tugasPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tugas_id: number
      user_id: string
      file_path: string | null
      waktu_kirim: Date | null
      nilai: number | null
      catatan: string | null
    }, ExtArgs["result"]["pengumpulan"]>
    composites: {}
  }

  type pengumpulanGetPayload<S extends boolean | null | undefined | pengumpulanDefaultArgs> = $Result.GetResult<Prisma.$pengumpulanPayload, S>

  type pengumpulanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pengumpulanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PengumpulanCountAggregateInputType | true
    }

  export interface pengumpulanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pengumpulan'], meta: { name: 'pengumpulan' } }
    /**
     * Find zero or one Pengumpulan that matches the filter.
     * @param {pengumpulanFindUniqueArgs} args - Arguments to find a Pengumpulan
     * @example
     * // Get one Pengumpulan
     * const pengumpulan = await prisma.pengumpulan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pengumpulanFindUniqueArgs>(args: SelectSubset<T, pengumpulanFindUniqueArgs<ExtArgs>>): Prisma__pengumpulanClient<$Result.GetResult<Prisma.$pengumpulanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pengumpulan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pengumpulanFindUniqueOrThrowArgs} args - Arguments to find a Pengumpulan
     * @example
     * // Get one Pengumpulan
     * const pengumpulan = await prisma.pengumpulan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pengumpulanFindUniqueOrThrowArgs>(args: SelectSubset<T, pengumpulanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pengumpulanClient<$Result.GetResult<Prisma.$pengumpulanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pengumpulan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengumpulanFindFirstArgs} args - Arguments to find a Pengumpulan
     * @example
     * // Get one Pengumpulan
     * const pengumpulan = await prisma.pengumpulan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pengumpulanFindFirstArgs>(args?: SelectSubset<T, pengumpulanFindFirstArgs<ExtArgs>>): Prisma__pengumpulanClient<$Result.GetResult<Prisma.$pengumpulanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pengumpulan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengumpulanFindFirstOrThrowArgs} args - Arguments to find a Pengumpulan
     * @example
     * // Get one Pengumpulan
     * const pengumpulan = await prisma.pengumpulan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pengumpulanFindFirstOrThrowArgs>(args?: SelectSubset<T, pengumpulanFindFirstOrThrowArgs<ExtArgs>>): Prisma__pengumpulanClient<$Result.GetResult<Prisma.$pengumpulanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pengumpulans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengumpulanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pengumpulans
     * const pengumpulans = await prisma.pengumpulan.findMany()
     * 
     * // Get first 10 Pengumpulans
     * const pengumpulans = await prisma.pengumpulan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pengumpulanWithIdOnly = await prisma.pengumpulan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pengumpulanFindManyArgs>(args?: SelectSubset<T, pengumpulanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pengumpulanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pengumpulan.
     * @param {pengumpulanCreateArgs} args - Arguments to create a Pengumpulan.
     * @example
     * // Create one Pengumpulan
     * const Pengumpulan = await prisma.pengumpulan.create({
     *   data: {
     *     // ... data to create a Pengumpulan
     *   }
     * })
     * 
     */
    create<T extends pengumpulanCreateArgs>(args: SelectSubset<T, pengumpulanCreateArgs<ExtArgs>>): Prisma__pengumpulanClient<$Result.GetResult<Prisma.$pengumpulanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pengumpulans.
     * @param {pengumpulanCreateManyArgs} args - Arguments to create many Pengumpulans.
     * @example
     * // Create many Pengumpulans
     * const pengumpulan = await prisma.pengumpulan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pengumpulanCreateManyArgs>(args?: SelectSubset<T, pengumpulanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pengumpulan.
     * @param {pengumpulanDeleteArgs} args - Arguments to delete one Pengumpulan.
     * @example
     * // Delete one Pengumpulan
     * const Pengumpulan = await prisma.pengumpulan.delete({
     *   where: {
     *     // ... filter to delete one Pengumpulan
     *   }
     * })
     * 
     */
    delete<T extends pengumpulanDeleteArgs>(args: SelectSubset<T, pengumpulanDeleteArgs<ExtArgs>>): Prisma__pengumpulanClient<$Result.GetResult<Prisma.$pengumpulanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pengumpulan.
     * @param {pengumpulanUpdateArgs} args - Arguments to update one Pengumpulan.
     * @example
     * // Update one Pengumpulan
     * const pengumpulan = await prisma.pengumpulan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pengumpulanUpdateArgs>(args: SelectSubset<T, pengumpulanUpdateArgs<ExtArgs>>): Prisma__pengumpulanClient<$Result.GetResult<Prisma.$pengumpulanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pengumpulans.
     * @param {pengumpulanDeleteManyArgs} args - Arguments to filter Pengumpulans to delete.
     * @example
     * // Delete a few Pengumpulans
     * const { count } = await prisma.pengumpulan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pengumpulanDeleteManyArgs>(args?: SelectSubset<T, pengumpulanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pengumpulans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengumpulanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pengumpulans
     * const pengumpulan = await prisma.pengumpulan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pengumpulanUpdateManyArgs>(args: SelectSubset<T, pengumpulanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pengumpulan.
     * @param {pengumpulanUpsertArgs} args - Arguments to update or create a Pengumpulan.
     * @example
     * // Update or create a Pengumpulan
     * const pengumpulan = await prisma.pengumpulan.upsert({
     *   create: {
     *     // ... data to create a Pengumpulan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pengumpulan we want to update
     *   }
     * })
     */
    upsert<T extends pengumpulanUpsertArgs>(args: SelectSubset<T, pengumpulanUpsertArgs<ExtArgs>>): Prisma__pengumpulanClient<$Result.GetResult<Prisma.$pengumpulanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pengumpulans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengumpulanCountArgs} args - Arguments to filter Pengumpulans to count.
     * @example
     * // Count the number of Pengumpulans
     * const count = await prisma.pengumpulan.count({
     *   where: {
     *     // ... the filter for the Pengumpulans we want to count
     *   }
     * })
    **/
    count<T extends pengumpulanCountArgs>(
      args?: Subset<T, pengumpulanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PengumpulanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pengumpulan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumpulanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PengumpulanAggregateArgs>(args: Subset<T, PengumpulanAggregateArgs>): Prisma.PrismaPromise<GetPengumpulanAggregateType<T>>

    /**
     * Group by Pengumpulan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengumpulanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pengumpulanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pengumpulanGroupByArgs['orderBy'] }
        : { orderBy?: pengumpulanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pengumpulanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPengumpulanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pengumpulan model
   */
  readonly fields: pengumpulanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pengumpulan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pengumpulanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tugas<T extends tugasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tugasDefaultArgs<ExtArgs>>): Prisma__tugasClient<$Result.GetResult<Prisma.$tugasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pengumpulan model
   */
  interface pengumpulanFieldRefs {
    readonly id: FieldRef<"pengumpulan", 'Int'>
    readonly tugas_id: FieldRef<"pengumpulan", 'Int'>
    readonly user_id: FieldRef<"pengumpulan", 'String'>
    readonly file_path: FieldRef<"pengumpulan", 'String'>
    readonly waktu_kirim: FieldRef<"pengumpulan", 'DateTime'>
    readonly nilai: FieldRef<"pengumpulan", 'Float'>
    readonly catatan: FieldRef<"pengumpulan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * pengumpulan findUnique
   */
  export type pengumpulanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumpulan
     */
    select?: pengumpulanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumpulan
     */
    omit?: pengumpulanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumpulanInclude<ExtArgs> | null
    /**
     * Filter, which pengumpulan to fetch.
     */
    where: pengumpulanWhereUniqueInput
  }

  /**
   * pengumpulan findUniqueOrThrow
   */
  export type pengumpulanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumpulan
     */
    select?: pengumpulanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumpulan
     */
    omit?: pengumpulanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumpulanInclude<ExtArgs> | null
    /**
     * Filter, which pengumpulan to fetch.
     */
    where: pengumpulanWhereUniqueInput
  }

  /**
   * pengumpulan findFirst
   */
  export type pengumpulanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumpulan
     */
    select?: pengumpulanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumpulan
     */
    omit?: pengumpulanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumpulanInclude<ExtArgs> | null
    /**
     * Filter, which pengumpulan to fetch.
     */
    where?: pengumpulanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pengumpulans to fetch.
     */
    orderBy?: pengumpulanOrderByWithRelationInput | pengumpulanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pengumpulans.
     */
    cursor?: pengumpulanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pengumpulans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pengumpulans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pengumpulans.
     */
    distinct?: PengumpulanScalarFieldEnum | PengumpulanScalarFieldEnum[]
  }

  /**
   * pengumpulan findFirstOrThrow
   */
  export type pengumpulanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumpulan
     */
    select?: pengumpulanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumpulan
     */
    omit?: pengumpulanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumpulanInclude<ExtArgs> | null
    /**
     * Filter, which pengumpulan to fetch.
     */
    where?: pengumpulanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pengumpulans to fetch.
     */
    orderBy?: pengumpulanOrderByWithRelationInput | pengumpulanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pengumpulans.
     */
    cursor?: pengumpulanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pengumpulans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pengumpulans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pengumpulans.
     */
    distinct?: PengumpulanScalarFieldEnum | PengumpulanScalarFieldEnum[]
  }

  /**
   * pengumpulan findMany
   */
  export type pengumpulanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumpulan
     */
    select?: pengumpulanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumpulan
     */
    omit?: pengumpulanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumpulanInclude<ExtArgs> | null
    /**
     * Filter, which pengumpulans to fetch.
     */
    where?: pengumpulanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pengumpulans to fetch.
     */
    orderBy?: pengumpulanOrderByWithRelationInput | pengumpulanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pengumpulans.
     */
    cursor?: pengumpulanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pengumpulans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pengumpulans.
     */
    skip?: number
    distinct?: PengumpulanScalarFieldEnum | PengumpulanScalarFieldEnum[]
  }

  /**
   * pengumpulan create
   */
  export type pengumpulanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumpulan
     */
    select?: pengumpulanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumpulan
     */
    omit?: pengumpulanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumpulanInclude<ExtArgs> | null
    /**
     * The data needed to create a pengumpulan.
     */
    data: XOR<pengumpulanCreateInput, pengumpulanUncheckedCreateInput>
  }

  /**
   * pengumpulan createMany
   */
  export type pengumpulanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pengumpulans.
     */
    data: pengumpulanCreateManyInput | pengumpulanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pengumpulan update
   */
  export type pengumpulanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumpulan
     */
    select?: pengumpulanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumpulan
     */
    omit?: pengumpulanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumpulanInclude<ExtArgs> | null
    /**
     * The data needed to update a pengumpulan.
     */
    data: XOR<pengumpulanUpdateInput, pengumpulanUncheckedUpdateInput>
    /**
     * Choose, which pengumpulan to update.
     */
    where: pengumpulanWhereUniqueInput
  }

  /**
   * pengumpulan updateMany
   */
  export type pengumpulanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pengumpulans.
     */
    data: XOR<pengumpulanUpdateManyMutationInput, pengumpulanUncheckedUpdateManyInput>
    /**
     * Filter which pengumpulans to update
     */
    where?: pengumpulanWhereInput
    /**
     * Limit how many pengumpulans to update.
     */
    limit?: number
  }

  /**
   * pengumpulan upsert
   */
  export type pengumpulanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumpulan
     */
    select?: pengumpulanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumpulan
     */
    omit?: pengumpulanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumpulanInclude<ExtArgs> | null
    /**
     * The filter to search for the pengumpulan to update in case it exists.
     */
    where: pengumpulanWhereUniqueInput
    /**
     * In case the pengumpulan found by the `where` argument doesn't exist, create a new pengumpulan with this data.
     */
    create: XOR<pengumpulanCreateInput, pengumpulanUncheckedCreateInput>
    /**
     * In case the pengumpulan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pengumpulanUpdateInput, pengumpulanUncheckedUpdateInput>
  }

  /**
   * pengumpulan delete
   */
  export type pengumpulanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumpulan
     */
    select?: pengumpulanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumpulan
     */
    omit?: pengumpulanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumpulanInclude<ExtArgs> | null
    /**
     * Filter which pengumpulan to delete.
     */
    where: pengumpulanWhereUniqueInput
  }

  /**
   * pengumpulan deleteMany
   */
  export type pengumpulanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pengumpulans to delete
     */
    where?: pengumpulanWhereInput
    /**
     * Limit how many pengumpulans to delete.
     */
    limit?: number
  }

  /**
   * pengumpulan without action
   */
  export type pengumpulanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumpulan
     */
    select?: pengumpulanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumpulan
     */
    omit?: pengumpulanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumpulanInclude<ExtArgs> | null
  }


  /**
   * Model pengumuman
   */

  export type AggregatePengumuman = {
    _count: PengumumanCountAggregateOutputType | null
    _avg: PengumumanAvgAggregateOutputType | null
    _sum: PengumumanSumAggregateOutputType | null
    _min: PengumumanMinAggregateOutputType | null
    _max: PengumumanMaxAggregateOutputType | null
  }

  export type PengumumanAvgAggregateOutputType = {
    id: number | null
    praktikum_id: number | null
  }

  export type PengumumanSumAggregateOutputType = {
    id: number | null
    praktikum_id: number | null
  }

  export type PengumumanMinAggregateOutputType = {
    id: number | null
    praktikum_id: number | null
    isi: string | null
    dibuat_oleh: string | null
    dibuat_pada: Date | null
  }

  export type PengumumanMaxAggregateOutputType = {
    id: number | null
    praktikum_id: number | null
    isi: string | null
    dibuat_oleh: string | null
    dibuat_pada: Date | null
  }

  export type PengumumanCountAggregateOutputType = {
    id: number
    praktikum_id: number
    isi: number
    dibuat_oleh: number
    dibuat_pada: number
    _all: number
  }


  export type PengumumanAvgAggregateInputType = {
    id?: true
    praktikum_id?: true
  }

  export type PengumumanSumAggregateInputType = {
    id?: true
    praktikum_id?: true
  }

  export type PengumumanMinAggregateInputType = {
    id?: true
    praktikum_id?: true
    isi?: true
    dibuat_oleh?: true
    dibuat_pada?: true
  }

  export type PengumumanMaxAggregateInputType = {
    id?: true
    praktikum_id?: true
    isi?: true
    dibuat_oleh?: true
    dibuat_pada?: true
  }

  export type PengumumanCountAggregateInputType = {
    id?: true
    praktikum_id?: true
    isi?: true
    dibuat_oleh?: true
    dibuat_pada?: true
    _all?: true
  }

  export type PengumumanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pengumuman to aggregate.
     */
    where?: pengumumanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pengumumen to fetch.
     */
    orderBy?: pengumumanOrderByWithRelationInput | pengumumanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pengumumanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pengumumen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pengumumen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pengumumen
    **/
    _count?: true | PengumumanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PengumumanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PengumumanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PengumumanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PengumumanMaxAggregateInputType
  }

  export type GetPengumumanAggregateType<T extends PengumumanAggregateArgs> = {
        [P in keyof T & keyof AggregatePengumuman]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePengumuman[P]>
      : GetScalarType<T[P], AggregatePengumuman[P]>
  }




  export type pengumumanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pengumumanWhereInput
    orderBy?: pengumumanOrderByWithAggregationInput | pengumumanOrderByWithAggregationInput[]
    by: PengumumanScalarFieldEnum[] | PengumumanScalarFieldEnum
    having?: pengumumanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PengumumanCountAggregateInputType | true
    _avg?: PengumumanAvgAggregateInputType
    _sum?: PengumumanSumAggregateInputType
    _min?: PengumumanMinAggregateInputType
    _max?: PengumumanMaxAggregateInputType
  }

  export type PengumumanGroupByOutputType = {
    id: number
    praktikum_id: number
    isi: string
    dibuat_oleh: string
    dibuat_pada: Date | null
    _count: PengumumanCountAggregateOutputType | null
    _avg: PengumumanAvgAggregateOutputType | null
    _sum: PengumumanSumAggregateOutputType | null
    _min: PengumumanMinAggregateOutputType | null
    _max: PengumumanMaxAggregateOutputType | null
  }

  type GetPengumumanGroupByPayload<T extends pengumumanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PengumumanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PengumumanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PengumumanGroupByOutputType[P]>
            : GetScalarType<T[P], PengumumanGroupByOutputType[P]>
        }
      >
    >


  export type pengumumanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    praktikum_id?: boolean
    isi?: boolean
    dibuat_oleh?: boolean
    dibuat_pada?: boolean
    praktikum?: boolean | praktikumDefaultArgs<ExtArgs>
    pembuat?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pengumuman"]>



  export type pengumumanSelectScalar = {
    id?: boolean
    praktikum_id?: boolean
    isi?: boolean
    dibuat_oleh?: boolean
    dibuat_pada?: boolean
  }

  export type pengumumanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "praktikum_id" | "isi" | "dibuat_oleh" | "dibuat_pada", ExtArgs["result"]["pengumuman"]>
  export type pengumumanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    praktikum?: boolean | praktikumDefaultArgs<ExtArgs>
    pembuat?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $pengumumanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pengumuman"
    objects: {
      praktikum: Prisma.$praktikumPayload<ExtArgs>
      pembuat: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      praktikum_id: number
      isi: string
      dibuat_oleh: string
      dibuat_pada: Date | null
    }, ExtArgs["result"]["pengumuman"]>
    composites: {}
  }

  type pengumumanGetPayload<S extends boolean | null | undefined | pengumumanDefaultArgs> = $Result.GetResult<Prisma.$pengumumanPayload, S>

  type pengumumanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pengumumanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PengumumanCountAggregateInputType | true
    }

  export interface pengumumanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pengumuman'], meta: { name: 'pengumuman' } }
    /**
     * Find zero or one Pengumuman that matches the filter.
     * @param {pengumumanFindUniqueArgs} args - Arguments to find a Pengumuman
     * @example
     * // Get one Pengumuman
     * const pengumuman = await prisma.pengumuman.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pengumumanFindUniqueArgs>(args: SelectSubset<T, pengumumanFindUniqueArgs<ExtArgs>>): Prisma__pengumumanClient<$Result.GetResult<Prisma.$pengumumanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pengumuman that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pengumumanFindUniqueOrThrowArgs} args - Arguments to find a Pengumuman
     * @example
     * // Get one Pengumuman
     * const pengumuman = await prisma.pengumuman.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pengumumanFindUniqueOrThrowArgs>(args: SelectSubset<T, pengumumanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pengumumanClient<$Result.GetResult<Prisma.$pengumumanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pengumuman that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengumumanFindFirstArgs} args - Arguments to find a Pengumuman
     * @example
     * // Get one Pengumuman
     * const pengumuman = await prisma.pengumuman.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pengumumanFindFirstArgs>(args?: SelectSubset<T, pengumumanFindFirstArgs<ExtArgs>>): Prisma__pengumumanClient<$Result.GetResult<Prisma.$pengumumanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pengumuman that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengumumanFindFirstOrThrowArgs} args - Arguments to find a Pengumuman
     * @example
     * // Get one Pengumuman
     * const pengumuman = await prisma.pengumuman.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pengumumanFindFirstOrThrowArgs>(args?: SelectSubset<T, pengumumanFindFirstOrThrowArgs<ExtArgs>>): Prisma__pengumumanClient<$Result.GetResult<Prisma.$pengumumanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pengumumen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengumumanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pengumumen
     * const pengumumen = await prisma.pengumuman.findMany()
     * 
     * // Get first 10 Pengumumen
     * const pengumumen = await prisma.pengumuman.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pengumumanWithIdOnly = await prisma.pengumuman.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pengumumanFindManyArgs>(args?: SelectSubset<T, pengumumanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pengumumanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pengumuman.
     * @param {pengumumanCreateArgs} args - Arguments to create a Pengumuman.
     * @example
     * // Create one Pengumuman
     * const Pengumuman = await prisma.pengumuman.create({
     *   data: {
     *     // ... data to create a Pengumuman
     *   }
     * })
     * 
     */
    create<T extends pengumumanCreateArgs>(args: SelectSubset<T, pengumumanCreateArgs<ExtArgs>>): Prisma__pengumumanClient<$Result.GetResult<Prisma.$pengumumanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pengumumen.
     * @param {pengumumanCreateManyArgs} args - Arguments to create many Pengumumen.
     * @example
     * // Create many Pengumumen
     * const pengumuman = await prisma.pengumuman.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pengumumanCreateManyArgs>(args?: SelectSubset<T, pengumumanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pengumuman.
     * @param {pengumumanDeleteArgs} args - Arguments to delete one Pengumuman.
     * @example
     * // Delete one Pengumuman
     * const Pengumuman = await prisma.pengumuman.delete({
     *   where: {
     *     // ... filter to delete one Pengumuman
     *   }
     * })
     * 
     */
    delete<T extends pengumumanDeleteArgs>(args: SelectSubset<T, pengumumanDeleteArgs<ExtArgs>>): Prisma__pengumumanClient<$Result.GetResult<Prisma.$pengumumanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pengumuman.
     * @param {pengumumanUpdateArgs} args - Arguments to update one Pengumuman.
     * @example
     * // Update one Pengumuman
     * const pengumuman = await prisma.pengumuman.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pengumumanUpdateArgs>(args: SelectSubset<T, pengumumanUpdateArgs<ExtArgs>>): Prisma__pengumumanClient<$Result.GetResult<Prisma.$pengumumanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pengumumen.
     * @param {pengumumanDeleteManyArgs} args - Arguments to filter Pengumumen to delete.
     * @example
     * // Delete a few Pengumumen
     * const { count } = await prisma.pengumuman.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pengumumanDeleteManyArgs>(args?: SelectSubset<T, pengumumanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pengumumen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengumumanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pengumumen
     * const pengumuman = await prisma.pengumuman.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pengumumanUpdateManyArgs>(args: SelectSubset<T, pengumumanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pengumuman.
     * @param {pengumumanUpsertArgs} args - Arguments to update or create a Pengumuman.
     * @example
     * // Update or create a Pengumuman
     * const pengumuman = await prisma.pengumuman.upsert({
     *   create: {
     *     // ... data to create a Pengumuman
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pengumuman we want to update
     *   }
     * })
     */
    upsert<T extends pengumumanUpsertArgs>(args: SelectSubset<T, pengumumanUpsertArgs<ExtArgs>>): Prisma__pengumumanClient<$Result.GetResult<Prisma.$pengumumanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pengumumen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengumumanCountArgs} args - Arguments to filter Pengumumen to count.
     * @example
     * // Count the number of Pengumumen
     * const count = await prisma.pengumuman.count({
     *   where: {
     *     // ... the filter for the Pengumumen we want to count
     *   }
     * })
    **/
    count<T extends pengumumanCountArgs>(
      args?: Subset<T, pengumumanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PengumumanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pengumuman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PengumumanAggregateArgs>(args: Subset<T, PengumumanAggregateArgs>): Prisma.PrismaPromise<GetPengumumanAggregateType<T>>

    /**
     * Group by Pengumuman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pengumumanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pengumumanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pengumumanGroupByArgs['orderBy'] }
        : { orderBy?: pengumumanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pengumumanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPengumumanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pengumuman model
   */
  readonly fields: pengumumanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pengumuman.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pengumumanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    praktikum<T extends praktikumDefaultArgs<ExtArgs> = {}>(args?: Subset<T, praktikumDefaultArgs<ExtArgs>>): Prisma__praktikumClient<$Result.GetResult<Prisma.$praktikumPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pembuat<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pengumuman model
   */
  interface pengumumanFieldRefs {
    readonly id: FieldRef<"pengumuman", 'Int'>
    readonly praktikum_id: FieldRef<"pengumuman", 'Int'>
    readonly isi: FieldRef<"pengumuman", 'String'>
    readonly dibuat_oleh: FieldRef<"pengumuman", 'String'>
    readonly dibuat_pada: FieldRef<"pengumuman", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pengumuman findUnique
   */
  export type pengumumanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumuman
     */
    select?: pengumumanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumuman
     */
    omit?: pengumumanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumumanInclude<ExtArgs> | null
    /**
     * Filter, which pengumuman to fetch.
     */
    where: pengumumanWhereUniqueInput
  }

  /**
   * pengumuman findUniqueOrThrow
   */
  export type pengumumanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumuman
     */
    select?: pengumumanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumuman
     */
    omit?: pengumumanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumumanInclude<ExtArgs> | null
    /**
     * Filter, which pengumuman to fetch.
     */
    where: pengumumanWhereUniqueInput
  }

  /**
   * pengumuman findFirst
   */
  export type pengumumanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumuman
     */
    select?: pengumumanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumuman
     */
    omit?: pengumumanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumumanInclude<ExtArgs> | null
    /**
     * Filter, which pengumuman to fetch.
     */
    where?: pengumumanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pengumumen to fetch.
     */
    orderBy?: pengumumanOrderByWithRelationInput | pengumumanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pengumumen.
     */
    cursor?: pengumumanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pengumumen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pengumumen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pengumumen.
     */
    distinct?: PengumumanScalarFieldEnum | PengumumanScalarFieldEnum[]
  }

  /**
   * pengumuman findFirstOrThrow
   */
  export type pengumumanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumuman
     */
    select?: pengumumanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumuman
     */
    omit?: pengumumanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumumanInclude<ExtArgs> | null
    /**
     * Filter, which pengumuman to fetch.
     */
    where?: pengumumanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pengumumen to fetch.
     */
    orderBy?: pengumumanOrderByWithRelationInput | pengumumanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pengumumen.
     */
    cursor?: pengumumanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pengumumen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pengumumen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pengumumen.
     */
    distinct?: PengumumanScalarFieldEnum | PengumumanScalarFieldEnum[]
  }

  /**
   * pengumuman findMany
   */
  export type pengumumanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumuman
     */
    select?: pengumumanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumuman
     */
    omit?: pengumumanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumumanInclude<ExtArgs> | null
    /**
     * Filter, which pengumumen to fetch.
     */
    where?: pengumumanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pengumumen to fetch.
     */
    orderBy?: pengumumanOrderByWithRelationInput | pengumumanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pengumumen.
     */
    cursor?: pengumumanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pengumumen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pengumumen.
     */
    skip?: number
    distinct?: PengumumanScalarFieldEnum | PengumumanScalarFieldEnum[]
  }

  /**
   * pengumuman create
   */
  export type pengumumanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumuman
     */
    select?: pengumumanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumuman
     */
    omit?: pengumumanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumumanInclude<ExtArgs> | null
    /**
     * The data needed to create a pengumuman.
     */
    data: XOR<pengumumanCreateInput, pengumumanUncheckedCreateInput>
  }

  /**
   * pengumuman createMany
   */
  export type pengumumanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pengumumen.
     */
    data: pengumumanCreateManyInput | pengumumanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pengumuman update
   */
  export type pengumumanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumuman
     */
    select?: pengumumanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumuman
     */
    omit?: pengumumanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumumanInclude<ExtArgs> | null
    /**
     * The data needed to update a pengumuman.
     */
    data: XOR<pengumumanUpdateInput, pengumumanUncheckedUpdateInput>
    /**
     * Choose, which pengumuman to update.
     */
    where: pengumumanWhereUniqueInput
  }

  /**
   * pengumuman updateMany
   */
  export type pengumumanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pengumumen.
     */
    data: XOR<pengumumanUpdateManyMutationInput, pengumumanUncheckedUpdateManyInput>
    /**
     * Filter which pengumumen to update
     */
    where?: pengumumanWhereInput
    /**
     * Limit how many pengumumen to update.
     */
    limit?: number
  }

  /**
   * pengumuman upsert
   */
  export type pengumumanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumuman
     */
    select?: pengumumanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumuman
     */
    omit?: pengumumanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumumanInclude<ExtArgs> | null
    /**
     * The filter to search for the pengumuman to update in case it exists.
     */
    where: pengumumanWhereUniqueInput
    /**
     * In case the pengumuman found by the `where` argument doesn't exist, create a new pengumuman with this data.
     */
    create: XOR<pengumumanCreateInput, pengumumanUncheckedCreateInput>
    /**
     * In case the pengumuman was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pengumumanUpdateInput, pengumumanUncheckedUpdateInput>
  }

  /**
   * pengumuman delete
   */
  export type pengumumanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumuman
     */
    select?: pengumumanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumuman
     */
    omit?: pengumumanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumumanInclude<ExtArgs> | null
    /**
     * Filter which pengumuman to delete.
     */
    where: pengumumanWhereUniqueInput
  }

  /**
   * pengumuman deleteMany
   */
  export type pengumumanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pengumumen to delete
     */
    where?: pengumumanWhereInput
    /**
     * Limit how many pengumumen to delete.
     */
    limit?: number
  }

  /**
   * pengumuman without action
   */
  export type pengumumanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pengumuman
     */
    select?: pengumumanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pengumuman
     */
    omit?: pengumumanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pengumumanInclude<ExtArgs> | null
  }


  /**
   * Model absensi
   */

  export type AggregateAbsensi = {
    _count: AbsensiCountAggregateOutputType | null
    _avg: AbsensiAvgAggregateOutputType | null
    _sum: AbsensiSumAggregateOutputType | null
    _min: AbsensiMinAggregateOutputType | null
    _max: AbsensiMaxAggregateOutputType | null
  }

  export type AbsensiAvgAggregateOutputType = {
    id: number | null
    jadwal_id: number | null
  }

  export type AbsensiSumAggregateOutputType = {
    id: number | null
    jadwal_id: number | null
  }

  export type AbsensiMinAggregateOutputType = {
    id: number | null
    user_id: string | null
    jadwal_id: number | null
    status: $Enums.StatusAbsensi | null
  }

  export type AbsensiMaxAggregateOutputType = {
    id: number | null
    user_id: string | null
    jadwal_id: number | null
    status: $Enums.StatusAbsensi | null
  }

  export type AbsensiCountAggregateOutputType = {
    id: number
    user_id: number
    jadwal_id: number
    status: number
    _all: number
  }


  export type AbsensiAvgAggregateInputType = {
    id?: true
    jadwal_id?: true
  }

  export type AbsensiSumAggregateInputType = {
    id?: true
    jadwal_id?: true
  }

  export type AbsensiMinAggregateInputType = {
    id?: true
    user_id?: true
    jadwal_id?: true
    status?: true
  }

  export type AbsensiMaxAggregateInputType = {
    id?: true
    user_id?: true
    jadwal_id?: true
    status?: true
  }

  export type AbsensiCountAggregateInputType = {
    id?: true
    user_id?: true
    jadwal_id?: true
    status?: true
    _all?: true
  }

  export type AbsensiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which absensi to aggregate.
     */
    where?: absensiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of absensis to fetch.
     */
    orderBy?: absensiOrderByWithRelationInput | absensiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: absensiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` absensis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` absensis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned absensis
    **/
    _count?: true | AbsensiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AbsensiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AbsensiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AbsensiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AbsensiMaxAggregateInputType
  }

  export type GetAbsensiAggregateType<T extends AbsensiAggregateArgs> = {
        [P in keyof T & keyof AggregateAbsensi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbsensi[P]>
      : GetScalarType<T[P], AggregateAbsensi[P]>
  }




  export type absensiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: absensiWhereInput
    orderBy?: absensiOrderByWithAggregationInput | absensiOrderByWithAggregationInput[]
    by: AbsensiScalarFieldEnum[] | AbsensiScalarFieldEnum
    having?: absensiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AbsensiCountAggregateInputType | true
    _avg?: AbsensiAvgAggregateInputType
    _sum?: AbsensiSumAggregateInputType
    _min?: AbsensiMinAggregateInputType
    _max?: AbsensiMaxAggregateInputType
  }

  export type AbsensiGroupByOutputType = {
    id: number
    user_id: string
    jadwal_id: number
    status: $Enums.StatusAbsensi
    _count: AbsensiCountAggregateOutputType | null
    _avg: AbsensiAvgAggregateOutputType | null
    _sum: AbsensiSumAggregateOutputType | null
    _min: AbsensiMinAggregateOutputType | null
    _max: AbsensiMaxAggregateOutputType | null
  }

  type GetAbsensiGroupByPayload<T extends absensiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AbsensiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AbsensiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AbsensiGroupByOutputType[P]>
            : GetScalarType<T[P], AbsensiGroupByOutputType[P]>
        }
      >
    >


  export type absensiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    jadwal_id?: boolean
    status?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    jadwal?: boolean | jadwalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["absensi"]>



  export type absensiSelectScalar = {
    id?: boolean
    user_id?: boolean
    jadwal_id?: boolean
    status?: boolean
  }

  export type absensiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "jadwal_id" | "status", ExtArgs["result"]["absensi"]>
  export type absensiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    jadwal?: boolean | jadwalDefaultArgs<ExtArgs>
  }

  export type $absensiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "absensi"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      jadwal: Prisma.$jadwalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: string
      jadwal_id: number
      status: $Enums.StatusAbsensi
    }, ExtArgs["result"]["absensi"]>
    composites: {}
  }

  type absensiGetPayload<S extends boolean | null | undefined | absensiDefaultArgs> = $Result.GetResult<Prisma.$absensiPayload, S>

  type absensiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<absensiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AbsensiCountAggregateInputType | true
    }

  export interface absensiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['absensi'], meta: { name: 'absensi' } }
    /**
     * Find zero or one Absensi that matches the filter.
     * @param {absensiFindUniqueArgs} args - Arguments to find a Absensi
     * @example
     * // Get one Absensi
     * const absensi = await prisma.absensi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends absensiFindUniqueArgs>(args: SelectSubset<T, absensiFindUniqueArgs<ExtArgs>>): Prisma__absensiClient<$Result.GetResult<Prisma.$absensiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Absensi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {absensiFindUniqueOrThrowArgs} args - Arguments to find a Absensi
     * @example
     * // Get one Absensi
     * const absensi = await prisma.absensi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends absensiFindUniqueOrThrowArgs>(args: SelectSubset<T, absensiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__absensiClient<$Result.GetResult<Prisma.$absensiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Absensi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {absensiFindFirstArgs} args - Arguments to find a Absensi
     * @example
     * // Get one Absensi
     * const absensi = await prisma.absensi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends absensiFindFirstArgs>(args?: SelectSubset<T, absensiFindFirstArgs<ExtArgs>>): Prisma__absensiClient<$Result.GetResult<Prisma.$absensiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Absensi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {absensiFindFirstOrThrowArgs} args - Arguments to find a Absensi
     * @example
     * // Get one Absensi
     * const absensi = await prisma.absensi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends absensiFindFirstOrThrowArgs>(args?: SelectSubset<T, absensiFindFirstOrThrowArgs<ExtArgs>>): Prisma__absensiClient<$Result.GetResult<Prisma.$absensiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Absensis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {absensiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Absensis
     * const absensis = await prisma.absensi.findMany()
     * 
     * // Get first 10 Absensis
     * const absensis = await prisma.absensi.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const absensiWithIdOnly = await prisma.absensi.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends absensiFindManyArgs>(args?: SelectSubset<T, absensiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$absensiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Absensi.
     * @param {absensiCreateArgs} args - Arguments to create a Absensi.
     * @example
     * // Create one Absensi
     * const Absensi = await prisma.absensi.create({
     *   data: {
     *     // ... data to create a Absensi
     *   }
     * })
     * 
     */
    create<T extends absensiCreateArgs>(args: SelectSubset<T, absensiCreateArgs<ExtArgs>>): Prisma__absensiClient<$Result.GetResult<Prisma.$absensiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Absensis.
     * @param {absensiCreateManyArgs} args - Arguments to create many Absensis.
     * @example
     * // Create many Absensis
     * const absensi = await prisma.absensi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends absensiCreateManyArgs>(args?: SelectSubset<T, absensiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Absensi.
     * @param {absensiDeleteArgs} args - Arguments to delete one Absensi.
     * @example
     * // Delete one Absensi
     * const Absensi = await prisma.absensi.delete({
     *   where: {
     *     // ... filter to delete one Absensi
     *   }
     * })
     * 
     */
    delete<T extends absensiDeleteArgs>(args: SelectSubset<T, absensiDeleteArgs<ExtArgs>>): Prisma__absensiClient<$Result.GetResult<Prisma.$absensiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Absensi.
     * @param {absensiUpdateArgs} args - Arguments to update one Absensi.
     * @example
     * // Update one Absensi
     * const absensi = await prisma.absensi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends absensiUpdateArgs>(args: SelectSubset<T, absensiUpdateArgs<ExtArgs>>): Prisma__absensiClient<$Result.GetResult<Prisma.$absensiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Absensis.
     * @param {absensiDeleteManyArgs} args - Arguments to filter Absensis to delete.
     * @example
     * // Delete a few Absensis
     * const { count } = await prisma.absensi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends absensiDeleteManyArgs>(args?: SelectSubset<T, absensiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Absensis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {absensiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Absensis
     * const absensi = await prisma.absensi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends absensiUpdateManyArgs>(args: SelectSubset<T, absensiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Absensi.
     * @param {absensiUpsertArgs} args - Arguments to update or create a Absensi.
     * @example
     * // Update or create a Absensi
     * const absensi = await prisma.absensi.upsert({
     *   create: {
     *     // ... data to create a Absensi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Absensi we want to update
     *   }
     * })
     */
    upsert<T extends absensiUpsertArgs>(args: SelectSubset<T, absensiUpsertArgs<ExtArgs>>): Prisma__absensiClient<$Result.GetResult<Prisma.$absensiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Absensis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {absensiCountArgs} args - Arguments to filter Absensis to count.
     * @example
     * // Count the number of Absensis
     * const count = await prisma.absensi.count({
     *   where: {
     *     // ... the filter for the Absensis we want to count
     *   }
     * })
    **/
    count<T extends absensiCountArgs>(
      args?: Subset<T, absensiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AbsensiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Absensi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbsensiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AbsensiAggregateArgs>(args: Subset<T, AbsensiAggregateArgs>): Prisma.PrismaPromise<GetAbsensiAggregateType<T>>

    /**
     * Group by Absensi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {absensiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends absensiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: absensiGroupByArgs['orderBy'] }
        : { orderBy?: absensiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, absensiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbsensiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the absensi model
   */
  readonly fields: absensiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for absensi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__absensiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    jadwal<T extends jadwalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jadwalDefaultArgs<ExtArgs>>): Prisma__jadwalClient<$Result.GetResult<Prisma.$jadwalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the absensi model
   */
  interface absensiFieldRefs {
    readonly id: FieldRef<"absensi", 'Int'>
    readonly user_id: FieldRef<"absensi", 'String'>
    readonly jadwal_id: FieldRef<"absensi", 'Int'>
    readonly status: FieldRef<"absensi", 'StatusAbsensi'>
  }
    

  // Custom InputTypes
  /**
   * absensi findUnique
   */
  export type absensiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the absensi
     */
    select?: absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the absensi
     */
    omit?: absensiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: absensiInclude<ExtArgs> | null
    /**
     * Filter, which absensi to fetch.
     */
    where: absensiWhereUniqueInput
  }

  /**
   * absensi findUniqueOrThrow
   */
  export type absensiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the absensi
     */
    select?: absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the absensi
     */
    omit?: absensiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: absensiInclude<ExtArgs> | null
    /**
     * Filter, which absensi to fetch.
     */
    where: absensiWhereUniqueInput
  }

  /**
   * absensi findFirst
   */
  export type absensiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the absensi
     */
    select?: absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the absensi
     */
    omit?: absensiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: absensiInclude<ExtArgs> | null
    /**
     * Filter, which absensi to fetch.
     */
    where?: absensiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of absensis to fetch.
     */
    orderBy?: absensiOrderByWithRelationInput | absensiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for absensis.
     */
    cursor?: absensiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` absensis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` absensis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of absensis.
     */
    distinct?: AbsensiScalarFieldEnum | AbsensiScalarFieldEnum[]
  }

  /**
   * absensi findFirstOrThrow
   */
  export type absensiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the absensi
     */
    select?: absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the absensi
     */
    omit?: absensiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: absensiInclude<ExtArgs> | null
    /**
     * Filter, which absensi to fetch.
     */
    where?: absensiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of absensis to fetch.
     */
    orderBy?: absensiOrderByWithRelationInput | absensiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for absensis.
     */
    cursor?: absensiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` absensis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` absensis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of absensis.
     */
    distinct?: AbsensiScalarFieldEnum | AbsensiScalarFieldEnum[]
  }

  /**
   * absensi findMany
   */
  export type absensiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the absensi
     */
    select?: absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the absensi
     */
    omit?: absensiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: absensiInclude<ExtArgs> | null
    /**
     * Filter, which absensis to fetch.
     */
    where?: absensiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of absensis to fetch.
     */
    orderBy?: absensiOrderByWithRelationInput | absensiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing absensis.
     */
    cursor?: absensiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` absensis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` absensis.
     */
    skip?: number
    distinct?: AbsensiScalarFieldEnum | AbsensiScalarFieldEnum[]
  }

  /**
   * absensi create
   */
  export type absensiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the absensi
     */
    select?: absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the absensi
     */
    omit?: absensiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: absensiInclude<ExtArgs> | null
    /**
     * The data needed to create a absensi.
     */
    data: XOR<absensiCreateInput, absensiUncheckedCreateInput>
  }

  /**
   * absensi createMany
   */
  export type absensiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many absensis.
     */
    data: absensiCreateManyInput | absensiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * absensi update
   */
  export type absensiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the absensi
     */
    select?: absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the absensi
     */
    omit?: absensiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: absensiInclude<ExtArgs> | null
    /**
     * The data needed to update a absensi.
     */
    data: XOR<absensiUpdateInput, absensiUncheckedUpdateInput>
    /**
     * Choose, which absensi to update.
     */
    where: absensiWhereUniqueInput
  }

  /**
   * absensi updateMany
   */
  export type absensiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update absensis.
     */
    data: XOR<absensiUpdateManyMutationInput, absensiUncheckedUpdateManyInput>
    /**
     * Filter which absensis to update
     */
    where?: absensiWhereInput
    /**
     * Limit how many absensis to update.
     */
    limit?: number
  }

  /**
   * absensi upsert
   */
  export type absensiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the absensi
     */
    select?: absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the absensi
     */
    omit?: absensiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: absensiInclude<ExtArgs> | null
    /**
     * The filter to search for the absensi to update in case it exists.
     */
    where: absensiWhereUniqueInput
    /**
     * In case the absensi found by the `where` argument doesn't exist, create a new absensi with this data.
     */
    create: XOR<absensiCreateInput, absensiUncheckedCreateInput>
    /**
     * In case the absensi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<absensiUpdateInput, absensiUncheckedUpdateInput>
  }

  /**
   * absensi delete
   */
  export type absensiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the absensi
     */
    select?: absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the absensi
     */
    omit?: absensiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: absensiInclude<ExtArgs> | null
    /**
     * Filter which absensi to delete.
     */
    where: absensiWhereUniqueInput
  }

  /**
   * absensi deleteMany
   */
  export type absensiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which absensis to delete
     */
    where?: absensiWhereInput
    /**
     * Limit how many absensis to delete.
     */
    limit?: number
  }

  /**
   * absensi without action
   */
  export type absensiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the absensi
     */
    select?: absensiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the absensi
     */
    omit?: absensiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: absensiInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    kata_sandi: 'kata_sandi',
    peran: 'peran',
    dibuat_pada: 'dibuat_pada'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const LabScalarFieldEnum: {
    id: 'id',
    nama_lab: 'nama_lab'
  };

  export type LabScalarFieldEnum = (typeof LabScalarFieldEnum)[keyof typeof LabScalarFieldEnum]


  export const PraktikumScalarFieldEnum: {
    id: 'id',
    nama_praktikum: 'nama_praktikum',
    lab_id: 'lab_id',
    dibuat_pada: 'dibuat_pada'
  };

  export type PraktikumScalarFieldEnum = (typeof PraktikumScalarFieldEnum)[keyof typeof PraktikumScalarFieldEnum]


  export const PendaftaranScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    praktikum_id: 'praktikum_id',
    waktu_daftar: 'waktu_daftar'
  };

  export type PendaftaranScalarFieldEnum = (typeof PendaftaranScalarFieldEnum)[keyof typeof PendaftaranScalarFieldEnum]


  export const JadwalScalarFieldEnum: {
    id: 'id',
    praktikum_id: 'praktikum_id',
    tanggal: 'tanggal',
    jam: 'jam',
    ruangan: 'ruangan',
    user_id: 'user_id',
    nama_pengajar: 'nama_pengajar',
    dibuat_pada: 'dibuat_pada'
  };

  export type JadwalScalarFieldEnum = (typeof JadwalScalarFieldEnum)[keyof typeof JadwalScalarFieldEnum]


  export const ModulScalarFieldEnum: {
    id: 'id',
    praktikum_id: 'praktikum_id',
    judul: 'judul',
    file_path: 'file_path',
    diunggah_oleh: 'diunggah_oleh',
    diunggah_pada: 'diunggah_pada'
  };

  export type ModulScalarFieldEnum = (typeof ModulScalarFieldEnum)[keyof typeof ModulScalarFieldEnum]


  export const TugasScalarFieldEnum: {
    id: 'id',
    praktikum_id: 'praktikum_id',
    judul: 'judul',
    deskripsi: 'deskripsi',
    fileTugas: 'fileTugas',
    batas_waktu: 'batas_waktu',
    dibuat_pada: 'dibuat_pada',
    status: 'status'
  };

  export type TugasScalarFieldEnum = (typeof TugasScalarFieldEnum)[keyof typeof TugasScalarFieldEnum]


  export const PengumpulanScalarFieldEnum: {
    id: 'id',
    tugas_id: 'tugas_id',
    user_id: 'user_id',
    file_path: 'file_path',
    waktu_kirim: 'waktu_kirim',
    nilai: 'nilai',
    catatan: 'catatan'
  };

  export type PengumpulanScalarFieldEnum = (typeof PengumpulanScalarFieldEnum)[keyof typeof PengumpulanScalarFieldEnum]


  export const PengumumanScalarFieldEnum: {
    id: 'id',
    praktikum_id: 'praktikum_id',
    isi: 'isi',
    dibuat_oleh: 'dibuat_oleh',
    dibuat_pada: 'dibuat_pada'
  };

  export type PengumumanScalarFieldEnum = (typeof PengumumanScalarFieldEnum)[keyof typeof PengumumanScalarFieldEnum]


  export const AbsensiScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    jadwal_id: 'jadwal_id',
    status: 'status'
  };

  export type AbsensiScalarFieldEnum = (typeof AbsensiScalarFieldEnum)[keyof typeof AbsensiScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const userOrderByRelevanceFieldEnum: {
    id: 'id',
    username: 'username',
    kata_sandi: 'kata_sandi'
  };

  export type userOrderByRelevanceFieldEnum = (typeof userOrderByRelevanceFieldEnum)[keyof typeof userOrderByRelevanceFieldEnum]


  export const labOrderByRelevanceFieldEnum: {
    nama_lab: 'nama_lab'
  };

  export type labOrderByRelevanceFieldEnum = (typeof labOrderByRelevanceFieldEnum)[keyof typeof labOrderByRelevanceFieldEnum]


  export const praktikumOrderByRelevanceFieldEnum: {
    nama_praktikum: 'nama_praktikum'
  };

  export type praktikumOrderByRelevanceFieldEnum = (typeof praktikumOrderByRelevanceFieldEnum)[keyof typeof praktikumOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const pendaftaranOrderByRelevanceFieldEnum: {
    user_id: 'user_id'
  };

  export type pendaftaranOrderByRelevanceFieldEnum = (typeof pendaftaranOrderByRelevanceFieldEnum)[keyof typeof pendaftaranOrderByRelevanceFieldEnum]


  export const jadwalOrderByRelevanceFieldEnum: {
    ruangan: 'ruangan',
    user_id: 'user_id',
    nama_pengajar: 'nama_pengajar'
  };

  export type jadwalOrderByRelevanceFieldEnum = (typeof jadwalOrderByRelevanceFieldEnum)[keyof typeof jadwalOrderByRelevanceFieldEnum]


  export const modulOrderByRelevanceFieldEnum: {
    judul: 'judul',
    file_path: 'file_path',
    diunggah_oleh: 'diunggah_oleh'
  };

  export type modulOrderByRelevanceFieldEnum = (typeof modulOrderByRelevanceFieldEnum)[keyof typeof modulOrderByRelevanceFieldEnum]


  export const tugasOrderByRelevanceFieldEnum: {
    judul: 'judul',
    deskripsi: 'deskripsi',
    fileTugas: 'fileTugas'
  };

  export type tugasOrderByRelevanceFieldEnum = (typeof tugasOrderByRelevanceFieldEnum)[keyof typeof tugasOrderByRelevanceFieldEnum]


  export const pengumpulanOrderByRelevanceFieldEnum: {
    user_id: 'user_id',
    file_path: 'file_path',
    catatan: 'catatan'
  };

  export type pengumpulanOrderByRelevanceFieldEnum = (typeof pengumpulanOrderByRelevanceFieldEnum)[keyof typeof pengumpulanOrderByRelevanceFieldEnum]


  export const pengumumanOrderByRelevanceFieldEnum: {
    isi: 'isi',
    dibuat_oleh: 'dibuat_oleh'
  };

  export type pengumumanOrderByRelevanceFieldEnum = (typeof pengumumanOrderByRelevanceFieldEnum)[keyof typeof pengumumanOrderByRelevanceFieldEnum]


  export const absensiOrderByRelevanceFieldEnum: {
    user_id: 'user_id'
  };

  export type absensiOrderByRelevanceFieldEnum = (typeof absensiOrderByRelevanceFieldEnum)[keyof typeof absensiOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Peran'
   */
  export type EnumPeranFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Peran'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'StatusTugas'
   */
  export type EnumStatusTugasFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusTugas'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'StatusAbsensi'
   */
  export type EnumStatusAbsensiFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusAbsensi'>
    
  /**
   * Deep Input Types
   */


  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: StringFilter<"user"> | string
    username?: StringFilter<"user"> | string
    kata_sandi?: StringFilter<"user"> | string
    peran?: EnumPeranFilter<"user"> | $Enums.Peran
    dibuat_pada?: DateTimeFilter<"user"> | Date | string
    pendaftaran?: PendaftaranListRelationFilter
    jadwal?: JadwalListRelationFilter
    modul?: ModulListRelationFilter
    pengumpulan?: PengumpulanListRelationFilter
    pengumuman?: PengumumanListRelationFilter
    absensi?: AbsensiListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    kata_sandi?: SortOrder
    peran?: SortOrder
    dibuat_pada?: SortOrder
    pendaftaran?: pendaftaranOrderByRelationAggregateInput
    jadwal?: jadwalOrderByRelationAggregateInput
    modul?: modulOrderByRelationAggregateInput
    pengumpulan?: pengumpulanOrderByRelationAggregateInput
    pengumuman?: pengumumanOrderByRelationAggregateInput
    absensi?: absensiOrderByRelationAggregateInput
    _relevance?: userOrderByRelevanceInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    kata_sandi?: StringFilter<"user"> | string
    peran?: EnumPeranFilter<"user"> | $Enums.Peran
    dibuat_pada?: DateTimeFilter<"user"> | Date | string
    pendaftaran?: PendaftaranListRelationFilter
    jadwal?: JadwalListRelationFilter
    modul?: ModulListRelationFilter
    pengumpulan?: PengumpulanListRelationFilter
    pengumuman?: PengumumanListRelationFilter
    absensi?: AbsensiListRelationFilter
  }, "id" | "username">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    kata_sandi?: SortOrder
    peran?: SortOrder
    dibuat_pada?: SortOrder
    _count?: userCountOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user"> | string
    username?: StringWithAggregatesFilter<"user"> | string
    kata_sandi?: StringWithAggregatesFilter<"user"> | string
    peran?: EnumPeranWithAggregatesFilter<"user"> | $Enums.Peran
    dibuat_pada?: DateTimeWithAggregatesFilter<"user"> | Date | string
  }

  export type labWhereInput = {
    AND?: labWhereInput | labWhereInput[]
    OR?: labWhereInput[]
    NOT?: labWhereInput | labWhereInput[]
    id?: IntFilter<"lab"> | number
    nama_lab?: StringFilter<"lab"> | string
    praktikum?: PraktikumListRelationFilter
  }

  export type labOrderByWithRelationInput = {
    id?: SortOrder
    nama_lab?: SortOrder
    praktikum?: praktikumOrderByRelationAggregateInput
    _relevance?: labOrderByRelevanceInput
  }

  export type labWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: labWhereInput | labWhereInput[]
    OR?: labWhereInput[]
    NOT?: labWhereInput | labWhereInput[]
    nama_lab?: StringFilter<"lab"> | string
    praktikum?: PraktikumListRelationFilter
  }, "id">

  export type labOrderByWithAggregationInput = {
    id?: SortOrder
    nama_lab?: SortOrder
    _count?: labCountOrderByAggregateInput
    _avg?: labAvgOrderByAggregateInput
    _max?: labMaxOrderByAggregateInput
    _min?: labMinOrderByAggregateInput
    _sum?: labSumOrderByAggregateInput
  }

  export type labScalarWhereWithAggregatesInput = {
    AND?: labScalarWhereWithAggregatesInput | labScalarWhereWithAggregatesInput[]
    OR?: labScalarWhereWithAggregatesInput[]
    NOT?: labScalarWhereWithAggregatesInput | labScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"lab"> | number
    nama_lab?: StringWithAggregatesFilter<"lab"> | string
  }

  export type praktikumWhereInput = {
    AND?: praktikumWhereInput | praktikumWhereInput[]
    OR?: praktikumWhereInput[]
    NOT?: praktikumWhereInput | praktikumWhereInput[]
    id?: IntFilter<"praktikum"> | number
    nama_praktikum?: StringFilter<"praktikum"> | string
    lab_id?: IntFilter<"praktikum"> | number
    dibuat_pada?: DateTimeFilter<"praktikum"> | Date | string
    lab?: XOR<LabScalarRelationFilter, labWhereInput>
    pendaftaran?: PendaftaranListRelationFilter
    jadwal?: JadwalListRelationFilter
    modul?: ModulListRelationFilter
    tugas?: TugasListRelationFilter
    pengumuman?: PengumumanListRelationFilter
  }

  export type praktikumOrderByWithRelationInput = {
    id?: SortOrder
    nama_praktikum?: SortOrder
    lab_id?: SortOrder
    dibuat_pada?: SortOrder
    lab?: labOrderByWithRelationInput
    pendaftaran?: pendaftaranOrderByRelationAggregateInput
    jadwal?: jadwalOrderByRelationAggregateInput
    modul?: modulOrderByRelationAggregateInput
    tugas?: tugasOrderByRelationAggregateInput
    pengumuman?: pengumumanOrderByRelationAggregateInput
    _relevance?: praktikumOrderByRelevanceInput
  }

  export type praktikumWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: praktikumWhereInput | praktikumWhereInput[]
    OR?: praktikumWhereInput[]
    NOT?: praktikumWhereInput | praktikumWhereInput[]
    nama_praktikum?: StringFilter<"praktikum"> | string
    lab_id?: IntFilter<"praktikum"> | number
    dibuat_pada?: DateTimeFilter<"praktikum"> | Date | string
    lab?: XOR<LabScalarRelationFilter, labWhereInput>
    pendaftaran?: PendaftaranListRelationFilter
    jadwal?: JadwalListRelationFilter
    modul?: ModulListRelationFilter
    tugas?: TugasListRelationFilter
    pengumuman?: PengumumanListRelationFilter
  }, "id">

  export type praktikumOrderByWithAggregationInput = {
    id?: SortOrder
    nama_praktikum?: SortOrder
    lab_id?: SortOrder
    dibuat_pada?: SortOrder
    _count?: praktikumCountOrderByAggregateInput
    _avg?: praktikumAvgOrderByAggregateInput
    _max?: praktikumMaxOrderByAggregateInput
    _min?: praktikumMinOrderByAggregateInput
    _sum?: praktikumSumOrderByAggregateInput
  }

  export type praktikumScalarWhereWithAggregatesInput = {
    AND?: praktikumScalarWhereWithAggregatesInput | praktikumScalarWhereWithAggregatesInput[]
    OR?: praktikumScalarWhereWithAggregatesInput[]
    NOT?: praktikumScalarWhereWithAggregatesInput | praktikumScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"praktikum"> | number
    nama_praktikum?: StringWithAggregatesFilter<"praktikum"> | string
    lab_id?: IntWithAggregatesFilter<"praktikum"> | number
    dibuat_pada?: DateTimeWithAggregatesFilter<"praktikum"> | Date | string
  }

  export type pendaftaranWhereInput = {
    AND?: pendaftaranWhereInput | pendaftaranWhereInput[]
    OR?: pendaftaranWhereInput[]
    NOT?: pendaftaranWhereInput | pendaftaranWhereInput[]
    id?: IntFilter<"pendaftaran"> | number
    user_id?: StringFilter<"pendaftaran"> | string
    praktikum_id?: IntFilter<"pendaftaran"> | number
    waktu_daftar?: DateTimeNullableFilter<"pendaftaran"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    praktikum?: XOR<PraktikumScalarRelationFilter, praktikumWhereInput>
  }

  export type pendaftaranOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    praktikum_id?: SortOrder
    waktu_daftar?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    praktikum?: praktikumOrderByWithRelationInput
    _relevance?: pendaftaranOrderByRelevanceInput
  }

  export type pendaftaranWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pendaftaranWhereInput | pendaftaranWhereInput[]
    OR?: pendaftaranWhereInput[]
    NOT?: pendaftaranWhereInput | pendaftaranWhereInput[]
    user_id?: StringFilter<"pendaftaran"> | string
    praktikum_id?: IntFilter<"pendaftaran"> | number
    waktu_daftar?: DateTimeNullableFilter<"pendaftaran"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    praktikum?: XOR<PraktikumScalarRelationFilter, praktikumWhereInput>
  }, "id">

  export type pendaftaranOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    praktikum_id?: SortOrder
    waktu_daftar?: SortOrderInput | SortOrder
    _count?: pendaftaranCountOrderByAggregateInput
    _avg?: pendaftaranAvgOrderByAggregateInput
    _max?: pendaftaranMaxOrderByAggregateInput
    _min?: pendaftaranMinOrderByAggregateInput
    _sum?: pendaftaranSumOrderByAggregateInput
  }

  export type pendaftaranScalarWhereWithAggregatesInput = {
    AND?: pendaftaranScalarWhereWithAggregatesInput | pendaftaranScalarWhereWithAggregatesInput[]
    OR?: pendaftaranScalarWhereWithAggregatesInput[]
    NOT?: pendaftaranScalarWhereWithAggregatesInput | pendaftaranScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pendaftaran"> | number
    user_id?: StringWithAggregatesFilter<"pendaftaran"> | string
    praktikum_id?: IntWithAggregatesFilter<"pendaftaran"> | number
    waktu_daftar?: DateTimeNullableWithAggregatesFilter<"pendaftaran"> | Date | string | null
  }

  export type jadwalWhereInput = {
    AND?: jadwalWhereInput | jadwalWhereInput[]
    OR?: jadwalWhereInput[]
    NOT?: jadwalWhereInput | jadwalWhereInput[]
    id?: IntFilter<"jadwal"> | number
    praktikum_id?: IntFilter<"jadwal"> | number
    tanggal?: DateTimeFilter<"jadwal"> | Date | string
    jam?: DateTimeFilter<"jadwal"> | Date | string
    ruangan?: StringNullableFilter<"jadwal"> | string | null
    user_id?: StringFilter<"jadwal"> | string
    nama_pengajar?: StringNullableFilter<"jadwal"> | string | null
    dibuat_pada?: DateTimeNullableFilter<"jadwal"> | Date | string | null
    praktikum?: XOR<PraktikumScalarRelationFilter, praktikumWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    absensi?: AbsensiListRelationFilter
  }

  export type jadwalOrderByWithRelationInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    tanggal?: SortOrder
    jam?: SortOrder
    ruangan?: SortOrderInput | SortOrder
    user_id?: SortOrder
    nama_pengajar?: SortOrderInput | SortOrder
    dibuat_pada?: SortOrderInput | SortOrder
    praktikum?: praktikumOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    absensi?: absensiOrderByRelationAggregateInput
    _relevance?: jadwalOrderByRelevanceInput
  }

  export type jadwalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: jadwalWhereInput | jadwalWhereInput[]
    OR?: jadwalWhereInput[]
    NOT?: jadwalWhereInput | jadwalWhereInput[]
    praktikum_id?: IntFilter<"jadwal"> | number
    tanggal?: DateTimeFilter<"jadwal"> | Date | string
    jam?: DateTimeFilter<"jadwal"> | Date | string
    ruangan?: StringNullableFilter<"jadwal"> | string | null
    user_id?: StringFilter<"jadwal"> | string
    nama_pengajar?: StringNullableFilter<"jadwal"> | string | null
    dibuat_pada?: DateTimeNullableFilter<"jadwal"> | Date | string | null
    praktikum?: XOR<PraktikumScalarRelationFilter, praktikumWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    absensi?: AbsensiListRelationFilter
  }, "id">

  export type jadwalOrderByWithAggregationInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    tanggal?: SortOrder
    jam?: SortOrder
    ruangan?: SortOrderInput | SortOrder
    user_id?: SortOrder
    nama_pengajar?: SortOrderInput | SortOrder
    dibuat_pada?: SortOrderInput | SortOrder
    _count?: jadwalCountOrderByAggregateInput
    _avg?: jadwalAvgOrderByAggregateInput
    _max?: jadwalMaxOrderByAggregateInput
    _min?: jadwalMinOrderByAggregateInput
    _sum?: jadwalSumOrderByAggregateInput
  }

  export type jadwalScalarWhereWithAggregatesInput = {
    AND?: jadwalScalarWhereWithAggregatesInput | jadwalScalarWhereWithAggregatesInput[]
    OR?: jadwalScalarWhereWithAggregatesInput[]
    NOT?: jadwalScalarWhereWithAggregatesInput | jadwalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"jadwal"> | number
    praktikum_id?: IntWithAggregatesFilter<"jadwal"> | number
    tanggal?: DateTimeWithAggregatesFilter<"jadwal"> | Date | string
    jam?: DateTimeWithAggregatesFilter<"jadwal"> | Date | string
    ruangan?: StringNullableWithAggregatesFilter<"jadwal"> | string | null
    user_id?: StringWithAggregatesFilter<"jadwal"> | string
    nama_pengajar?: StringNullableWithAggregatesFilter<"jadwal"> | string | null
    dibuat_pada?: DateTimeNullableWithAggregatesFilter<"jadwal"> | Date | string | null
  }

  export type modulWhereInput = {
    AND?: modulWhereInput | modulWhereInput[]
    OR?: modulWhereInput[]
    NOT?: modulWhereInput | modulWhereInput[]
    id?: IntFilter<"modul"> | number
    praktikum_id?: IntFilter<"modul"> | number
    judul?: StringFilter<"modul"> | string
    file_path?: StringFilter<"modul"> | string
    diunggah_oleh?: StringFilter<"modul"> | string
    diunggah_pada?: DateTimeNullableFilter<"modul"> | Date | string | null
    praktikum?: XOR<PraktikumScalarRelationFilter, praktikumWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type modulOrderByWithRelationInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    judul?: SortOrder
    file_path?: SortOrder
    diunggah_oleh?: SortOrder
    diunggah_pada?: SortOrderInput | SortOrder
    praktikum?: praktikumOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    _relevance?: modulOrderByRelevanceInput
  }

  export type modulWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: modulWhereInput | modulWhereInput[]
    OR?: modulWhereInput[]
    NOT?: modulWhereInput | modulWhereInput[]
    praktikum_id?: IntFilter<"modul"> | number
    judul?: StringFilter<"modul"> | string
    file_path?: StringFilter<"modul"> | string
    diunggah_oleh?: StringFilter<"modul"> | string
    diunggah_pada?: DateTimeNullableFilter<"modul"> | Date | string | null
    praktikum?: XOR<PraktikumScalarRelationFilter, praktikumWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type modulOrderByWithAggregationInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    judul?: SortOrder
    file_path?: SortOrder
    diunggah_oleh?: SortOrder
    diunggah_pada?: SortOrderInput | SortOrder
    _count?: modulCountOrderByAggregateInput
    _avg?: modulAvgOrderByAggregateInput
    _max?: modulMaxOrderByAggregateInput
    _min?: modulMinOrderByAggregateInput
    _sum?: modulSumOrderByAggregateInput
  }

  export type modulScalarWhereWithAggregatesInput = {
    AND?: modulScalarWhereWithAggregatesInput | modulScalarWhereWithAggregatesInput[]
    OR?: modulScalarWhereWithAggregatesInput[]
    NOT?: modulScalarWhereWithAggregatesInput | modulScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"modul"> | number
    praktikum_id?: IntWithAggregatesFilter<"modul"> | number
    judul?: StringWithAggregatesFilter<"modul"> | string
    file_path?: StringWithAggregatesFilter<"modul"> | string
    diunggah_oleh?: StringWithAggregatesFilter<"modul"> | string
    diunggah_pada?: DateTimeNullableWithAggregatesFilter<"modul"> | Date | string | null
  }

  export type tugasWhereInput = {
    AND?: tugasWhereInput | tugasWhereInput[]
    OR?: tugasWhereInput[]
    NOT?: tugasWhereInput | tugasWhereInput[]
    id?: IntFilter<"tugas"> | number
    praktikum_id?: IntFilter<"tugas"> | number
    judul?: StringFilter<"tugas"> | string
    deskripsi?: StringNullableFilter<"tugas"> | string | null
    fileTugas?: StringNullableFilter<"tugas"> | string | null
    batas_waktu?: DateTimeFilter<"tugas"> | Date | string
    dibuat_pada?: DateTimeFilter<"tugas"> | Date | string
    status?: EnumStatusTugasFilter<"tugas"> | $Enums.StatusTugas
    praktikum?: XOR<PraktikumScalarRelationFilter, praktikumWhereInput>
    pengumpulan?: PengumpulanListRelationFilter
  }

  export type tugasOrderByWithRelationInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    judul?: SortOrder
    deskripsi?: SortOrderInput | SortOrder
    fileTugas?: SortOrderInput | SortOrder
    batas_waktu?: SortOrder
    dibuat_pada?: SortOrder
    status?: SortOrder
    praktikum?: praktikumOrderByWithRelationInput
    pengumpulan?: pengumpulanOrderByRelationAggregateInput
    _relevance?: tugasOrderByRelevanceInput
  }

  export type tugasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tugasWhereInput | tugasWhereInput[]
    OR?: tugasWhereInput[]
    NOT?: tugasWhereInput | tugasWhereInput[]
    praktikum_id?: IntFilter<"tugas"> | number
    judul?: StringFilter<"tugas"> | string
    deskripsi?: StringNullableFilter<"tugas"> | string | null
    fileTugas?: StringNullableFilter<"tugas"> | string | null
    batas_waktu?: DateTimeFilter<"tugas"> | Date | string
    dibuat_pada?: DateTimeFilter<"tugas"> | Date | string
    status?: EnumStatusTugasFilter<"tugas"> | $Enums.StatusTugas
    praktikum?: XOR<PraktikumScalarRelationFilter, praktikumWhereInput>
    pengumpulan?: PengumpulanListRelationFilter
  }, "id">

  export type tugasOrderByWithAggregationInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    judul?: SortOrder
    deskripsi?: SortOrderInput | SortOrder
    fileTugas?: SortOrderInput | SortOrder
    batas_waktu?: SortOrder
    dibuat_pada?: SortOrder
    status?: SortOrder
    _count?: tugasCountOrderByAggregateInput
    _avg?: tugasAvgOrderByAggregateInput
    _max?: tugasMaxOrderByAggregateInput
    _min?: tugasMinOrderByAggregateInput
    _sum?: tugasSumOrderByAggregateInput
  }

  export type tugasScalarWhereWithAggregatesInput = {
    AND?: tugasScalarWhereWithAggregatesInput | tugasScalarWhereWithAggregatesInput[]
    OR?: tugasScalarWhereWithAggregatesInput[]
    NOT?: tugasScalarWhereWithAggregatesInput | tugasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tugas"> | number
    praktikum_id?: IntWithAggregatesFilter<"tugas"> | number
    judul?: StringWithAggregatesFilter<"tugas"> | string
    deskripsi?: StringNullableWithAggregatesFilter<"tugas"> | string | null
    fileTugas?: StringNullableWithAggregatesFilter<"tugas"> | string | null
    batas_waktu?: DateTimeWithAggregatesFilter<"tugas"> | Date | string
    dibuat_pada?: DateTimeWithAggregatesFilter<"tugas"> | Date | string
    status?: EnumStatusTugasWithAggregatesFilter<"tugas"> | $Enums.StatusTugas
  }

  export type pengumpulanWhereInput = {
    AND?: pengumpulanWhereInput | pengumpulanWhereInput[]
    OR?: pengumpulanWhereInput[]
    NOT?: pengumpulanWhereInput | pengumpulanWhereInput[]
    id?: IntFilter<"pengumpulan"> | number
    tugas_id?: IntFilter<"pengumpulan"> | number
    user_id?: StringFilter<"pengumpulan"> | string
    file_path?: StringNullableFilter<"pengumpulan"> | string | null
    waktu_kirim?: DateTimeNullableFilter<"pengumpulan"> | Date | string | null
    nilai?: FloatNullableFilter<"pengumpulan"> | number | null
    catatan?: StringNullableFilter<"pengumpulan"> | string | null
    tugas?: XOR<TugasScalarRelationFilter, tugasWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type pengumpulanOrderByWithRelationInput = {
    id?: SortOrder
    tugas_id?: SortOrder
    user_id?: SortOrder
    file_path?: SortOrderInput | SortOrder
    waktu_kirim?: SortOrderInput | SortOrder
    nilai?: SortOrderInput | SortOrder
    catatan?: SortOrderInput | SortOrder
    tugas?: tugasOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    _relevance?: pengumpulanOrderByRelevanceInput
  }

  export type pengumpulanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pengumpulanWhereInput | pengumpulanWhereInput[]
    OR?: pengumpulanWhereInput[]
    NOT?: pengumpulanWhereInput | pengumpulanWhereInput[]
    tugas_id?: IntFilter<"pengumpulan"> | number
    user_id?: StringFilter<"pengumpulan"> | string
    file_path?: StringNullableFilter<"pengumpulan"> | string | null
    waktu_kirim?: DateTimeNullableFilter<"pengumpulan"> | Date | string | null
    nilai?: FloatNullableFilter<"pengumpulan"> | number | null
    catatan?: StringNullableFilter<"pengumpulan"> | string | null
    tugas?: XOR<TugasScalarRelationFilter, tugasWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type pengumpulanOrderByWithAggregationInput = {
    id?: SortOrder
    tugas_id?: SortOrder
    user_id?: SortOrder
    file_path?: SortOrderInput | SortOrder
    waktu_kirim?: SortOrderInput | SortOrder
    nilai?: SortOrderInput | SortOrder
    catatan?: SortOrderInput | SortOrder
    _count?: pengumpulanCountOrderByAggregateInput
    _avg?: pengumpulanAvgOrderByAggregateInput
    _max?: pengumpulanMaxOrderByAggregateInput
    _min?: pengumpulanMinOrderByAggregateInput
    _sum?: pengumpulanSumOrderByAggregateInput
  }

  export type pengumpulanScalarWhereWithAggregatesInput = {
    AND?: pengumpulanScalarWhereWithAggregatesInput | pengumpulanScalarWhereWithAggregatesInput[]
    OR?: pengumpulanScalarWhereWithAggregatesInput[]
    NOT?: pengumpulanScalarWhereWithAggregatesInput | pengumpulanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pengumpulan"> | number
    tugas_id?: IntWithAggregatesFilter<"pengumpulan"> | number
    user_id?: StringWithAggregatesFilter<"pengumpulan"> | string
    file_path?: StringNullableWithAggregatesFilter<"pengumpulan"> | string | null
    waktu_kirim?: DateTimeNullableWithAggregatesFilter<"pengumpulan"> | Date | string | null
    nilai?: FloatNullableWithAggregatesFilter<"pengumpulan"> | number | null
    catatan?: StringNullableWithAggregatesFilter<"pengumpulan"> | string | null
  }

  export type pengumumanWhereInput = {
    AND?: pengumumanWhereInput | pengumumanWhereInput[]
    OR?: pengumumanWhereInput[]
    NOT?: pengumumanWhereInput | pengumumanWhereInput[]
    id?: IntFilter<"pengumuman"> | number
    praktikum_id?: IntFilter<"pengumuman"> | number
    isi?: StringFilter<"pengumuman"> | string
    dibuat_oleh?: StringFilter<"pengumuman"> | string
    dibuat_pada?: DateTimeNullableFilter<"pengumuman"> | Date | string | null
    praktikum?: XOR<PraktikumScalarRelationFilter, praktikumWhereInput>
    pembuat?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type pengumumanOrderByWithRelationInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    isi?: SortOrder
    dibuat_oleh?: SortOrder
    dibuat_pada?: SortOrderInput | SortOrder
    praktikum?: praktikumOrderByWithRelationInput
    pembuat?: userOrderByWithRelationInput
    _relevance?: pengumumanOrderByRelevanceInput
  }

  export type pengumumanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pengumumanWhereInput | pengumumanWhereInput[]
    OR?: pengumumanWhereInput[]
    NOT?: pengumumanWhereInput | pengumumanWhereInput[]
    praktikum_id?: IntFilter<"pengumuman"> | number
    isi?: StringFilter<"pengumuman"> | string
    dibuat_oleh?: StringFilter<"pengumuman"> | string
    dibuat_pada?: DateTimeNullableFilter<"pengumuman"> | Date | string | null
    praktikum?: XOR<PraktikumScalarRelationFilter, praktikumWhereInput>
    pembuat?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type pengumumanOrderByWithAggregationInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    isi?: SortOrder
    dibuat_oleh?: SortOrder
    dibuat_pada?: SortOrderInput | SortOrder
    _count?: pengumumanCountOrderByAggregateInput
    _avg?: pengumumanAvgOrderByAggregateInput
    _max?: pengumumanMaxOrderByAggregateInput
    _min?: pengumumanMinOrderByAggregateInput
    _sum?: pengumumanSumOrderByAggregateInput
  }

  export type pengumumanScalarWhereWithAggregatesInput = {
    AND?: pengumumanScalarWhereWithAggregatesInput | pengumumanScalarWhereWithAggregatesInput[]
    OR?: pengumumanScalarWhereWithAggregatesInput[]
    NOT?: pengumumanScalarWhereWithAggregatesInput | pengumumanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pengumuman"> | number
    praktikum_id?: IntWithAggregatesFilter<"pengumuman"> | number
    isi?: StringWithAggregatesFilter<"pengumuman"> | string
    dibuat_oleh?: StringWithAggregatesFilter<"pengumuman"> | string
    dibuat_pada?: DateTimeNullableWithAggregatesFilter<"pengumuman"> | Date | string | null
  }

  export type absensiWhereInput = {
    AND?: absensiWhereInput | absensiWhereInput[]
    OR?: absensiWhereInput[]
    NOT?: absensiWhereInput | absensiWhereInput[]
    id?: IntFilter<"absensi"> | number
    user_id?: StringFilter<"absensi"> | string
    jadwal_id?: IntFilter<"absensi"> | number
    status?: EnumStatusAbsensiFilter<"absensi"> | $Enums.StatusAbsensi
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    jadwal?: XOR<JadwalScalarRelationFilter, jadwalWhereInput>
  }

  export type absensiOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    jadwal_id?: SortOrder
    status?: SortOrder
    user?: userOrderByWithRelationInput
    jadwal?: jadwalOrderByWithRelationInput
    _relevance?: absensiOrderByRelevanceInput
  }

  export type absensiWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: absensiWhereInput | absensiWhereInput[]
    OR?: absensiWhereInput[]
    NOT?: absensiWhereInput | absensiWhereInput[]
    user_id?: StringFilter<"absensi"> | string
    jadwal_id?: IntFilter<"absensi"> | number
    status?: EnumStatusAbsensiFilter<"absensi"> | $Enums.StatusAbsensi
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    jadwal?: XOR<JadwalScalarRelationFilter, jadwalWhereInput>
  }, "id">

  export type absensiOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    jadwal_id?: SortOrder
    status?: SortOrder
    _count?: absensiCountOrderByAggregateInput
    _avg?: absensiAvgOrderByAggregateInput
    _max?: absensiMaxOrderByAggregateInput
    _min?: absensiMinOrderByAggregateInput
    _sum?: absensiSumOrderByAggregateInput
  }

  export type absensiScalarWhereWithAggregatesInput = {
    AND?: absensiScalarWhereWithAggregatesInput | absensiScalarWhereWithAggregatesInput[]
    OR?: absensiScalarWhereWithAggregatesInput[]
    NOT?: absensiScalarWhereWithAggregatesInput | absensiScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"absensi"> | number
    user_id?: StringWithAggregatesFilter<"absensi"> | string
    jadwal_id?: IntWithAggregatesFilter<"absensi"> | number
    status?: EnumStatusAbsensiWithAggregatesFilter<"absensi"> | $Enums.StatusAbsensi
  }

  export type userCreateInput = {
    id: string
    username: string
    kata_sandi: string
    peran: $Enums.Peran
    dibuat_pada?: Date | string
    pendaftaran?: pendaftaranCreateNestedManyWithoutUserInput
    jadwal?: jadwalCreateNestedManyWithoutUserInput
    modul?: modulCreateNestedManyWithoutUserInput
    pengumpulan?: pengumpulanCreateNestedManyWithoutUserInput
    pengumuman?: pengumumanCreateNestedManyWithoutPembuatInput
    absensi?: absensiCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id: string
    username: string
    kata_sandi: string
    peran: $Enums.Peran
    dibuat_pada?: Date | string
    pendaftaran?: pendaftaranUncheckedCreateNestedManyWithoutUserInput
    jadwal?: jadwalUncheckedCreateNestedManyWithoutUserInput
    modul?: modulUncheckedCreateNestedManyWithoutUserInput
    pengumpulan?: pengumpulanUncheckedCreateNestedManyWithoutUserInput
    pengumuman?: pengumumanUncheckedCreateNestedManyWithoutPembuatInput
    absensi?: absensiUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    kata_sandi?: StringFieldUpdateOperationsInput | string
    peran?: EnumPeranFieldUpdateOperationsInput | $Enums.Peran
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    pendaftaran?: pendaftaranUpdateManyWithoutUserNestedInput
    jadwal?: jadwalUpdateManyWithoutUserNestedInput
    modul?: modulUpdateManyWithoutUserNestedInput
    pengumpulan?: pengumpulanUpdateManyWithoutUserNestedInput
    pengumuman?: pengumumanUpdateManyWithoutPembuatNestedInput
    absensi?: absensiUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    kata_sandi?: StringFieldUpdateOperationsInput | string
    peran?: EnumPeranFieldUpdateOperationsInput | $Enums.Peran
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    pendaftaran?: pendaftaranUncheckedUpdateManyWithoutUserNestedInput
    jadwal?: jadwalUncheckedUpdateManyWithoutUserNestedInput
    modul?: modulUncheckedUpdateManyWithoutUserNestedInput
    pengumpulan?: pengumpulanUncheckedUpdateManyWithoutUserNestedInput
    pengumuman?: pengumumanUncheckedUpdateManyWithoutPembuatNestedInput
    absensi?: absensiUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id: string
    username: string
    kata_sandi: string
    peran: $Enums.Peran
    dibuat_pada?: Date | string
  }

  export type userUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    kata_sandi?: StringFieldUpdateOperationsInput | string
    peran?: EnumPeranFieldUpdateOperationsInput | $Enums.Peran
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    kata_sandi?: StringFieldUpdateOperationsInput | string
    peran?: EnumPeranFieldUpdateOperationsInput | $Enums.Peran
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type labCreateInput = {
    nama_lab: string
    praktikum?: praktikumCreateNestedManyWithoutLabInput
  }

  export type labUncheckedCreateInput = {
    id?: number
    nama_lab: string
    praktikum?: praktikumUncheckedCreateNestedManyWithoutLabInput
  }

  export type labUpdateInput = {
    nama_lab?: StringFieldUpdateOperationsInput | string
    praktikum?: praktikumUpdateManyWithoutLabNestedInput
  }

  export type labUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_lab?: StringFieldUpdateOperationsInput | string
    praktikum?: praktikumUncheckedUpdateManyWithoutLabNestedInput
  }

  export type labCreateManyInput = {
    id?: number
    nama_lab: string
  }

  export type labUpdateManyMutationInput = {
    nama_lab?: StringFieldUpdateOperationsInput | string
  }

  export type labUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_lab?: StringFieldUpdateOperationsInput | string
  }

  export type praktikumCreateInput = {
    nama_praktikum: string
    dibuat_pada?: Date | string
    lab: labCreateNestedOneWithoutPraktikumInput
    pendaftaran?: pendaftaranCreateNestedManyWithoutPraktikumInput
    jadwal?: jadwalCreateNestedManyWithoutPraktikumInput
    modul?: modulCreateNestedManyWithoutPraktikumInput
    tugas?: tugasCreateNestedManyWithoutPraktikumInput
    pengumuman?: pengumumanCreateNestedManyWithoutPraktikumInput
  }

  export type praktikumUncheckedCreateInput = {
    id?: number
    nama_praktikum: string
    lab_id: number
    dibuat_pada?: Date | string
    pendaftaran?: pendaftaranUncheckedCreateNestedManyWithoutPraktikumInput
    jadwal?: jadwalUncheckedCreateNestedManyWithoutPraktikumInput
    modul?: modulUncheckedCreateNestedManyWithoutPraktikumInput
    tugas?: tugasUncheckedCreateNestedManyWithoutPraktikumInput
    pengumuman?: pengumumanUncheckedCreateNestedManyWithoutPraktikumInput
  }

  export type praktikumUpdateInput = {
    nama_praktikum?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    lab?: labUpdateOneRequiredWithoutPraktikumNestedInput
    pendaftaran?: pendaftaranUpdateManyWithoutPraktikumNestedInput
    jadwal?: jadwalUpdateManyWithoutPraktikumNestedInput
    modul?: modulUpdateManyWithoutPraktikumNestedInput
    tugas?: tugasUpdateManyWithoutPraktikumNestedInput
    pengumuman?: pengumumanUpdateManyWithoutPraktikumNestedInput
  }

  export type praktikumUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_praktikum?: StringFieldUpdateOperationsInput | string
    lab_id?: IntFieldUpdateOperationsInput | number
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    pendaftaran?: pendaftaranUncheckedUpdateManyWithoutPraktikumNestedInput
    jadwal?: jadwalUncheckedUpdateManyWithoutPraktikumNestedInput
    modul?: modulUncheckedUpdateManyWithoutPraktikumNestedInput
    tugas?: tugasUncheckedUpdateManyWithoutPraktikumNestedInput
    pengumuman?: pengumumanUncheckedUpdateManyWithoutPraktikumNestedInput
  }

  export type praktikumCreateManyInput = {
    id?: number
    nama_praktikum: string
    lab_id: number
    dibuat_pada?: Date | string
  }

  export type praktikumUpdateManyMutationInput = {
    nama_praktikum?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type praktikumUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_praktikum?: StringFieldUpdateOperationsInput | string
    lab_id?: IntFieldUpdateOperationsInput | number
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pendaftaranCreateInput = {
    waktu_daftar?: Date | string | null
    user: userCreateNestedOneWithoutPendaftaranInput
    praktikum: praktikumCreateNestedOneWithoutPendaftaranInput
  }

  export type pendaftaranUncheckedCreateInput = {
    id?: number
    user_id: string
    praktikum_id: number
    waktu_daftar?: Date | string | null
  }

  export type pendaftaranUpdateInput = {
    waktu_daftar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutPendaftaranNestedInput
    praktikum?: praktikumUpdateOneRequiredWithoutPendaftaranNestedInput
  }

  export type pendaftaranUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    praktikum_id?: IntFieldUpdateOperationsInput | number
    waktu_daftar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pendaftaranCreateManyInput = {
    id?: number
    user_id: string
    praktikum_id: number
    waktu_daftar?: Date | string | null
  }

  export type pendaftaranUpdateManyMutationInput = {
    waktu_daftar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pendaftaranUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    praktikum_id?: IntFieldUpdateOperationsInput | number
    waktu_daftar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type jadwalCreateInput = {
    tanggal: Date | string
    jam: Date | string
    ruangan?: string | null
    nama_pengajar?: string | null
    dibuat_pada?: Date | string | null
    praktikum: praktikumCreateNestedOneWithoutJadwalInput
    user: userCreateNestedOneWithoutJadwalInput
    absensi?: absensiCreateNestedManyWithoutJadwalInput
  }

  export type jadwalUncheckedCreateInput = {
    id?: number
    praktikum_id: number
    tanggal: Date | string
    jam: Date | string
    ruangan?: string | null
    user_id: string
    nama_pengajar?: string | null
    dibuat_pada?: Date | string | null
    absensi?: absensiUncheckedCreateNestedManyWithoutJadwalInput
  }

  export type jadwalUpdateInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam?: DateTimeFieldUpdateOperationsInput | Date | string
    ruangan?: NullableStringFieldUpdateOperationsInput | string | null
    nama_pengajar?: NullableStringFieldUpdateOperationsInput | string | null
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    praktikum?: praktikumUpdateOneRequiredWithoutJadwalNestedInput
    user?: userUpdateOneRequiredWithoutJadwalNestedInput
    absensi?: absensiUpdateManyWithoutJadwalNestedInput
  }

  export type jadwalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    praktikum_id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam?: DateTimeFieldUpdateOperationsInput | Date | string
    ruangan?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    nama_pengajar?: NullableStringFieldUpdateOperationsInput | string | null
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    absensi?: absensiUncheckedUpdateManyWithoutJadwalNestedInput
  }

  export type jadwalCreateManyInput = {
    id?: number
    praktikum_id: number
    tanggal: Date | string
    jam: Date | string
    ruangan?: string | null
    user_id: string
    nama_pengajar?: string | null
    dibuat_pada?: Date | string | null
  }

  export type jadwalUpdateManyMutationInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam?: DateTimeFieldUpdateOperationsInput | Date | string
    ruangan?: NullableStringFieldUpdateOperationsInput | string | null
    nama_pengajar?: NullableStringFieldUpdateOperationsInput | string | null
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type jadwalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    praktikum_id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam?: DateTimeFieldUpdateOperationsInput | Date | string
    ruangan?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    nama_pengajar?: NullableStringFieldUpdateOperationsInput | string | null
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type modulCreateInput = {
    judul: string
    file_path: string
    diunggah_pada?: Date | string | null
    praktikum: praktikumCreateNestedOneWithoutModulInput
    user: userCreateNestedOneWithoutModulInput
  }

  export type modulUncheckedCreateInput = {
    id?: number
    praktikum_id: number
    judul: string
    file_path: string
    diunggah_oleh: string
    diunggah_pada?: Date | string | null
  }

  export type modulUpdateInput = {
    judul?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    diunggah_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    praktikum?: praktikumUpdateOneRequiredWithoutModulNestedInput
    user?: userUpdateOneRequiredWithoutModulNestedInput
  }

  export type modulUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    praktikum_id?: IntFieldUpdateOperationsInput | number
    judul?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    diunggah_oleh?: StringFieldUpdateOperationsInput | string
    diunggah_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type modulCreateManyInput = {
    id?: number
    praktikum_id: number
    judul: string
    file_path: string
    diunggah_oleh: string
    diunggah_pada?: Date | string | null
  }

  export type modulUpdateManyMutationInput = {
    judul?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    diunggah_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type modulUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    praktikum_id?: IntFieldUpdateOperationsInput | number
    judul?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    diunggah_oleh?: StringFieldUpdateOperationsInput | string
    diunggah_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tugasCreateInput = {
    judul: string
    deskripsi?: string | null
    fileTugas?: string | null
    batas_waktu: Date | string
    dibuat_pada?: Date | string
    status?: $Enums.StatusTugas
    praktikum: praktikumCreateNestedOneWithoutTugasInput
    pengumpulan?: pengumpulanCreateNestedManyWithoutTugasInput
  }

  export type tugasUncheckedCreateInput = {
    id?: number
    praktikum_id: number
    judul: string
    deskripsi?: string | null
    fileTugas?: string | null
    batas_waktu: Date | string
    dibuat_pada?: Date | string
    status?: $Enums.StatusTugas
    pengumpulan?: pengumpulanUncheckedCreateNestedManyWithoutTugasInput
  }

  export type tugasUpdateInput = {
    judul?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    fileTugas?: NullableStringFieldUpdateOperationsInput | string | null
    batas_waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusTugasFieldUpdateOperationsInput | $Enums.StatusTugas
    praktikum?: praktikumUpdateOneRequiredWithoutTugasNestedInput
    pengumpulan?: pengumpulanUpdateManyWithoutTugasNestedInput
  }

  export type tugasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    praktikum_id?: IntFieldUpdateOperationsInput | number
    judul?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    fileTugas?: NullableStringFieldUpdateOperationsInput | string | null
    batas_waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusTugasFieldUpdateOperationsInput | $Enums.StatusTugas
    pengumpulan?: pengumpulanUncheckedUpdateManyWithoutTugasNestedInput
  }

  export type tugasCreateManyInput = {
    id?: number
    praktikum_id: number
    judul: string
    deskripsi?: string | null
    fileTugas?: string | null
    batas_waktu: Date | string
    dibuat_pada?: Date | string
    status?: $Enums.StatusTugas
  }

  export type tugasUpdateManyMutationInput = {
    judul?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    fileTugas?: NullableStringFieldUpdateOperationsInput | string | null
    batas_waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusTugasFieldUpdateOperationsInput | $Enums.StatusTugas
  }

  export type tugasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    praktikum_id?: IntFieldUpdateOperationsInput | number
    judul?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    fileTugas?: NullableStringFieldUpdateOperationsInput | string | null
    batas_waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusTugasFieldUpdateOperationsInput | $Enums.StatusTugas
  }

  export type pengumpulanCreateInput = {
    file_path?: string | null
    waktu_kirim?: Date | string | null
    nilai?: number | null
    catatan?: string | null
    tugas: tugasCreateNestedOneWithoutPengumpulanInput
    user: userCreateNestedOneWithoutPengumpulanInput
  }

  export type pengumpulanUncheckedCreateInput = {
    id?: number
    tugas_id: number
    user_id: string
    file_path?: string | null
    waktu_kirim?: Date | string | null
    nilai?: number | null
    catatan?: string | null
  }

  export type pengumpulanUpdateInput = {
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_kirim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nilai?: NullableFloatFieldUpdateOperationsInput | number | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    tugas?: tugasUpdateOneRequiredWithoutPengumpulanNestedInput
    user?: userUpdateOneRequiredWithoutPengumpulanNestedInput
  }

  export type pengumpulanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tugas_id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_kirim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nilai?: NullableFloatFieldUpdateOperationsInput | number | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pengumpulanCreateManyInput = {
    id?: number
    tugas_id: number
    user_id: string
    file_path?: string | null
    waktu_kirim?: Date | string | null
    nilai?: number | null
    catatan?: string | null
  }

  export type pengumpulanUpdateManyMutationInput = {
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_kirim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nilai?: NullableFloatFieldUpdateOperationsInput | number | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pengumpulanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tugas_id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_kirim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nilai?: NullableFloatFieldUpdateOperationsInput | number | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pengumumanCreateInput = {
    isi: string
    dibuat_pada?: Date | string | null
    praktikum: praktikumCreateNestedOneWithoutPengumumanInput
    pembuat: userCreateNestedOneWithoutPengumumanInput
  }

  export type pengumumanUncheckedCreateInput = {
    id?: number
    praktikum_id: number
    isi: string
    dibuat_oleh: string
    dibuat_pada?: Date | string | null
  }

  export type pengumumanUpdateInput = {
    isi?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    praktikum?: praktikumUpdateOneRequiredWithoutPengumumanNestedInput
    pembuat?: userUpdateOneRequiredWithoutPengumumanNestedInput
  }

  export type pengumumanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    praktikum_id?: IntFieldUpdateOperationsInput | number
    isi?: StringFieldUpdateOperationsInput | string
    dibuat_oleh?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pengumumanCreateManyInput = {
    id?: number
    praktikum_id: number
    isi: string
    dibuat_oleh: string
    dibuat_pada?: Date | string | null
  }

  export type pengumumanUpdateManyMutationInput = {
    isi?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pengumumanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    praktikum_id?: IntFieldUpdateOperationsInput | number
    isi?: StringFieldUpdateOperationsInput | string
    dibuat_oleh?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type absensiCreateInput = {
    status: $Enums.StatusAbsensi
    user: userCreateNestedOneWithoutAbsensiInput
    jadwal: jadwalCreateNestedOneWithoutAbsensiInput
  }

  export type absensiUncheckedCreateInput = {
    id?: number
    user_id: string
    jadwal_id: number
    status: $Enums.StatusAbsensi
  }

  export type absensiUpdateInput = {
    status?: EnumStatusAbsensiFieldUpdateOperationsInput | $Enums.StatusAbsensi
    user?: userUpdateOneRequiredWithoutAbsensiNestedInput
    jadwal?: jadwalUpdateOneRequiredWithoutAbsensiNestedInput
  }

  export type absensiUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    jadwal_id?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusAbsensiFieldUpdateOperationsInput | $Enums.StatusAbsensi
  }

  export type absensiCreateManyInput = {
    id?: number
    user_id: string
    jadwal_id: number
    status: $Enums.StatusAbsensi
  }

  export type absensiUpdateManyMutationInput = {
    status?: EnumStatusAbsensiFieldUpdateOperationsInput | $Enums.StatusAbsensi
  }

  export type absensiUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    jadwal_id?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusAbsensiFieldUpdateOperationsInput | $Enums.StatusAbsensi
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumPeranFilter<$PrismaModel = never> = {
    equals?: $Enums.Peran | EnumPeranFieldRefInput<$PrismaModel>
    in?: $Enums.Peran[]
    notIn?: $Enums.Peran[]
    not?: NestedEnumPeranFilter<$PrismaModel> | $Enums.Peran
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PendaftaranListRelationFilter = {
    every?: pendaftaranWhereInput
    some?: pendaftaranWhereInput
    none?: pendaftaranWhereInput
  }

  export type JadwalListRelationFilter = {
    every?: jadwalWhereInput
    some?: jadwalWhereInput
    none?: jadwalWhereInput
  }

  export type ModulListRelationFilter = {
    every?: modulWhereInput
    some?: modulWhereInput
    none?: modulWhereInput
  }

  export type PengumpulanListRelationFilter = {
    every?: pengumpulanWhereInput
    some?: pengumpulanWhereInput
    none?: pengumpulanWhereInput
  }

  export type PengumumanListRelationFilter = {
    every?: pengumumanWhereInput
    some?: pengumumanWhereInput
    none?: pengumumanWhereInput
  }

  export type AbsensiListRelationFilter = {
    every?: absensiWhereInput
    some?: absensiWhereInput
    none?: absensiWhereInput
  }

  export type pendaftaranOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type jadwalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type modulOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pengumpulanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pengumumanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type absensiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userOrderByRelevanceInput = {
    fields: userOrderByRelevanceFieldEnum | userOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    kata_sandi?: SortOrder
    peran?: SortOrder
    dibuat_pada?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    kata_sandi?: SortOrder
    peran?: SortOrder
    dibuat_pada?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    kata_sandi?: SortOrder
    peran?: SortOrder
    dibuat_pada?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumPeranWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Peran | EnumPeranFieldRefInput<$PrismaModel>
    in?: $Enums.Peran[]
    notIn?: $Enums.Peran[]
    not?: NestedEnumPeranWithAggregatesFilter<$PrismaModel> | $Enums.Peran
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPeranFilter<$PrismaModel>
    _max?: NestedEnumPeranFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PraktikumListRelationFilter = {
    every?: praktikumWhereInput
    some?: praktikumWhereInput
    none?: praktikumWhereInput
  }

  export type praktikumOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type labOrderByRelevanceInput = {
    fields: labOrderByRelevanceFieldEnum | labOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type labCountOrderByAggregateInput = {
    id?: SortOrder
    nama_lab?: SortOrder
  }

  export type labAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type labMaxOrderByAggregateInput = {
    id?: SortOrder
    nama_lab?: SortOrder
  }

  export type labMinOrderByAggregateInput = {
    id?: SortOrder
    nama_lab?: SortOrder
  }

  export type labSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type LabScalarRelationFilter = {
    is?: labWhereInput
    isNot?: labWhereInput
  }

  export type TugasListRelationFilter = {
    every?: tugasWhereInput
    some?: tugasWhereInput
    none?: tugasWhereInput
  }

  export type tugasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type praktikumOrderByRelevanceInput = {
    fields: praktikumOrderByRelevanceFieldEnum | praktikumOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type praktikumCountOrderByAggregateInput = {
    id?: SortOrder
    nama_praktikum?: SortOrder
    lab_id?: SortOrder
    dibuat_pada?: SortOrder
  }

  export type praktikumAvgOrderByAggregateInput = {
    id?: SortOrder
    lab_id?: SortOrder
  }

  export type praktikumMaxOrderByAggregateInput = {
    id?: SortOrder
    nama_praktikum?: SortOrder
    lab_id?: SortOrder
    dibuat_pada?: SortOrder
  }

  export type praktikumMinOrderByAggregateInput = {
    id?: SortOrder
    nama_praktikum?: SortOrder
    lab_id?: SortOrder
    dibuat_pada?: SortOrder
  }

  export type praktikumSumOrderByAggregateInput = {
    id?: SortOrder
    lab_id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserScalarRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type PraktikumScalarRelationFilter = {
    is?: praktikumWhereInput
    isNot?: praktikumWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type pendaftaranOrderByRelevanceInput = {
    fields: pendaftaranOrderByRelevanceFieldEnum | pendaftaranOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type pendaftaranCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    praktikum_id?: SortOrder
    waktu_daftar?: SortOrder
  }

  export type pendaftaranAvgOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
  }

  export type pendaftaranMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    praktikum_id?: SortOrder
    waktu_daftar?: SortOrder
  }

  export type pendaftaranMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    praktikum_id?: SortOrder
    waktu_daftar?: SortOrder
  }

  export type pendaftaranSumOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type jadwalOrderByRelevanceInput = {
    fields: jadwalOrderByRelevanceFieldEnum | jadwalOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type jadwalCountOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    tanggal?: SortOrder
    jam?: SortOrder
    ruangan?: SortOrder
    user_id?: SortOrder
    nama_pengajar?: SortOrder
    dibuat_pada?: SortOrder
  }

  export type jadwalAvgOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
  }

  export type jadwalMaxOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    tanggal?: SortOrder
    jam?: SortOrder
    ruangan?: SortOrder
    user_id?: SortOrder
    nama_pengajar?: SortOrder
    dibuat_pada?: SortOrder
  }

  export type jadwalMinOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    tanggal?: SortOrder
    jam?: SortOrder
    ruangan?: SortOrder
    user_id?: SortOrder
    nama_pengajar?: SortOrder
    dibuat_pada?: SortOrder
  }

  export type jadwalSumOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type modulOrderByRelevanceInput = {
    fields: modulOrderByRelevanceFieldEnum | modulOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type modulCountOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    judul?: SortOrder
    file_path?: SortOrder
    diunggah_oleh?: SortOrder
    diunggah_pada?: SortOrder
  }

  export type modulAvgOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
  }

  export type modulMaxOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    judul?: SortOrder
    file_path?: SortOrder
    diunggah_oleh?: SortOrder
    diunggah_pada?: SortOrder
  }

  export type modulMinOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    judul?: SortOrder
    file_path?: SortOrder
    diunggah_oleh?: SortOrder
    diunggah_pada?: SortOrder
  }

  export type modulSumOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
  }

  export type EnumStatusTugasFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusTugas | EnumStatusTugasFieldRefInput<$PrismaModel>
    in?: $Enums.StatusTugas[]
    notIn?: $Enums.StatusTugas[]
    not?: NestedEnumStatusTugasFilter<$PrismaModel> | $Enums.StatusTugas
  }

  export type tugasOrderByRelevanceInput = {
    fields: tugasOrderByRelevanceFieldEnum | tugasOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tugasCountOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    judul?: SortOrder
    deskripsi?: SortOrder
    fileTugas?: SortOrder
    batas_waktu?: SortOrder
    dibuat_pada?: SortOrder
    status?: SortOrder
  }

  export type tugasAvgOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
  }

  export type tugasMaxOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    judul?: SortOrder
    deskripsi?: SortOrder
    fileTugas?: SortOrder
    batas_waktu?: SortOrder
    dibuat_pada?: SortOrder
    status?: SortOrder
  }

  export type tugasMinOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    judul?: SortOrder
    deskripsi?: SortOrder
    fileTugas?: SortOrder
    batas_waktu?: SortOrder
    dibuat_pada?: SortOrder
    status?: SortOrder
  }

  export type tugasSumOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
  }

  export type EnumStatusTugasWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusTugas | EnumStatusTugasFieldRefInput<$PrismaModel>
    in?: $Enums.StatusTugas[]
    notIn?: $Enums.StatusTugas[]
    not?: NestedEnumStatusTugasWithAggregatesFilter<$PrismaModel> | $Enums.StatusTugas
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusTugasFilter<$PrismaModel>
    _max?: NestedEnumStatusTugasFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type TugasScalarRelationFilter = {
    is?: tugasWhereInput
    isNot?: tugasWhereInput
  }

  export type pengumpulanOrderByRelevanceInput = {
    fields: pengumpulanOrderByRelevanceFieldEnum | pengumpulanOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type pengumpulanCountOrderByAggregateInput = {
    id?: SortOrder
    tugas_id?: SortOrder
    user_id?: SortOrder
    file_path?: SortOrder
    waktu_kirim?: SortOrder
    nilai?: SortOrder
    catatan?: SortOrder
  }

  export type pengumpulanAvgOrderByAggregateInput = {
    id?: SortOrder
    tugas_id?: SortOrder
    nilai?: SortOrder
  }

  export type pengumpulanMaxOrderByAggregateInput = {
    id?: SortOrder
    tugas_id?: SortOrder
    user_id?: SortOrder
    file_path?: SortOrder
    waktu_kirim?: SortOrder
    nilai?: SortOrder
    catatan?: SortOrder
  }

  export type pengumpulanMinOrderByAggregateInput = {
    id?: SortOrder
    tugas_id?: SortOrder
    user_id?: SortOrder
    file_path?: SortOrder
    waktu_kirim?: SortOrder
    nilai?: SortOrder
    catatan?: SortOrder
  }

  export type pengumpulanSumOrderByAggregateInput = {
    id?: SortOrder
    tugas_id?: SortOrder
    nilai?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type pengumumanOrderByRelevanceInput = {
    fields: pengumumanOrderByRelevanceFieldEnum | pengumumanOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type pengumumanCountOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    isi?: SortOrder
    dibuat_oleh?: SortOrder
    dibuat_pada?: SortOrder
  }

  export type pengumumanAvgOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
  }

  export type pengumumanMaxOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    isi?: SortOrder
    dibuat_oleh?: SortOrder
    dibuat_pada?: SortOrder
  }

  export type pengumumanMinOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
    isi?: SortOrder
    dibuat_oleh?: SortOrder
    dibuat_pada?: SortOrder
  }

  export type pengumumanSumOrderByAggregateInput = {
    id?: SortOrder
    praktikum_id?: SortOrder
  }

  export type EnumStatusAbsensiFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusAbsensi | EnumStatusAbsensiFieldRefInput<$PrismaModel>
    in?: $Enums.StatusAbsensi[]
    notIn?: $Enums.StatusAbsensi[]
    not?: NestedEnumStatusAbsensiFilter<$PrismaModel> | $Enums.StatusAbsensi
  }

  export type JadwalScalarRelationFilter = {
    is?: jadwalWhereInput
    isNot?: jadwalWhereInput
  }

  export type absensiOrderByRelevanceInput = {
    fields: absensiOrderByRelevanceFieldEnum | absensiOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type absensiCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    jadwal_id?: SortOrder
    status?: SortOrder
  }

  export type absensiAvgOrderByAggregateInput = {
    id?: SortOrder
    jadwal_id?: SortOrder
  }

  export type absensiMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    jadwal_id?: SortOrder
    status?: SortOrder
  }

  export type absensiMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    jadwal_id?: SortOrder
    status?: SortOrder
  }

  export type absensiSumOrderByAggregateInput = {
    id?: SortOrder
    jadwal_id?: SortOrder
  }

  export type EnumStatusAbsensiWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusAbsensi | EnumStatusAbsensiFieldRefInput<$PrismaModel>
    in?: $Enums.StatusAbsensi[]
    notIn?: $Enums.StatusAbsensi[]
    not?: NestedEnumStatusAbsensiWithAggregatesFilter<$PrismaModel> | $Enums.StatusAbsensi
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusAbsensiFilter<$PrismaModel>
    _max?: NestedEnumStatusAbsensiFilter<$PrismaModel>
  }

  export type pendaftaranCreateNestedManyWithoutUserInput = {
    create?: XOR<pendaftaranCreateWithoutUserInput, pendaftaranUncheckedCreateWithoutUserInput> | pendaftaranCreateWithoutUserInput[] | pendaftaranUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pendaftaranCreateOrConnectWithoutUserInput | pendaftaranCreateOrConnectWithoutUserInput[]
    createMany?: pendaftaranCreateManyUserInputEnvelope
    connect?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
  }

  export type jadwalCreateNestedManyWithoutUserInput = {
    create?: XOR<jadwalCreateWithoutUserInput, jadwalUncheckedCreateWithoutUserInput> | jadwalCreateWithoutUserInput[] | jadwalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: jadwalCreateOrConnectWithoutUserInput | jadwalCreateOrConnectWithoutUserInput[]
    createMany?: jadwalCreateManyUserInputEnvelope
    connect?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
  }

  export type modulCreateNestedManyWithoutUserInput = {
    create?: XOR<modulCreateWithoutUserInput, modulUncheckedCreateWithoutUserInput> | modulCreateWithoutUserInput[] | modulUncheckedCreateWithoutUserInput[]
    connectOrCreate?: modulCreateOrConnectWithoutUserInput | modulCreateOrConnectWithoutUserInput[]
    createMany?: modulCreateManyUserInputEnvelope
    connect?: modulWhereUniqueInput | modulWhereUniqueInput[]
  }

  export type pengumpulanCreateNestedManyWithoutUserInput = {
    create?: XOR<pengumpulanCreateWithoutUserInput, pengumpulanUncheckedCreateWithoutUserInput> | pengumpulanCreateWithoutUserInput[] | pengumpulanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pengumpulanCreateOrConnectWithoutUserInput | pengumpulanCreateOrConnectWithoutUserInput[]
    createMany?: pengumpulanCreateManyUserInputEnvelope
    connect?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
  }

  export type pengumumanCreateNestedManyWithoutPembuatInput = {
    create?: XOR<pengumumanCreateWithoutPembuatInput, pengumumanUncheckedCreateWithoutPembuatInput> | pengumumanCreateWithoutPembuatInput[] | pengumumanUncheckedCreateWithoutPembuatInput[]
    connectOrCreate?: pengumumanCreateOrConnectWithoutPembuatInput | pengumumanCreateOrConnectWithoutPembuatInput[]
    createMany?: pengumumanCreateManyPembuatInputEnvelope
    connect?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
  }

  export type absensiCreateNestedManyWithoutUserInput = {
    create?: XOR<absensiCreateWithoutUserInput, absensiUncheckedCreateWithoutUserInput> | absensiCreateWithoutUserInput[] | absensiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: absensiCreateOrConnectWithoutUserInput | absensiCreateOrConnectWithoutUserInput[]
    createMany?: absensiCreateManyUserInputEnvelope
    connect?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
  }

  export type pendaftaranUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<pendaftaranCreateWithoutUserInput, pendaftaranUncheckedCreateWithoutUserInput> | pendaftaranCreateWithoutUserInput[] | pendaftaranUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pendaftaranCreateOrConnectWithoutUserInput | pendaftaranCreateOrConnectWithoutUserInput[]
    createMany?: pendaftaranCreateManyUserInputEnvelope
    connect?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
  }

  export type jadwalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<jadwalCreateWithoutUserInput, jadwalUncheckedCreateWithoutUserInput> | jadwalCreateWithoutUserInput[] | jadwalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: jadwalCreateOrConnectWithoutUserInput | jadwalCreateOrConnectWithoutUserInput[]
    createMany?: jadwalCreateManyUserInputEnvelope
    connect?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
  }

  export type modulUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<modulCreateWithoutUserInput, modulUncheckedCreateWithoutUserInput> | modulCreateWithoutUserInput[] | modulUncheckedCreateWithoutUserInput[]
    connectOrCreate?: modulCreateOrConnectWithoutUserInput | modulCreateOrConnectWithoutUserInput[]
    createMany?: modulCreateManyUserInputEnvelope
    connect?: modulWhereUniqueInput | modulWhereUniqueInput[]
  }

  export type pengumpulanUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<pengumpulanCreateWithoutUserInput, pengumpulanUncheckedCreateWithoutUserInput> | pengumpulanCreateWithoutUserInput[] | pengumpulanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pengumpulanCreateOrConnectWithoutUserInput | pengumpulanCreateOrConnectWithoutUserInput[]
    createMany?: pengumpulanCreateManyUserInputEnvelope
    connect?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
  }

  export type pengumumanUncheckedCreateNestedManyWithoutPembuatInput = {
    create?: XOR<pengumumanCreateWithoutPembuatInput, pengumumanUncheckedCreateWithoutPembuatInput> | pengumumanCreateWithoutPembuatInput[] | pengumumanUncheckedCreateWithoutPembuatInput[]
    connectOrCreate?: pengumumanCreateOrConnectWithoutPembuatInput | pengumumanCreateOrConnectWithoutPembuatInput[]
    createMany?: pengumumanCreateManyPembuatInputEnvelope
    connect?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
  }

  export type absensiUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<absensiCreateWithoutUserInput, absensiUncheckedCreateWithoutUserInput> | absensiCreateWithoutUserInput[] | absensiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: absensiCreateOrConnectWithoutUserInput | absensiCreateOrConnectWithoutUserInput[]
    createMany?: absensiCreateManyUserInputEnvelope
    connect?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumPeranFieldUpdateOperationsInput = {
    set?: $Enums.Peran
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type pendaftaranUpdateManyWithoutUserNestedInput = {
    create?: XOR<pendaftaranCreateWithoutUserInput, pendaftaranUncheckedCreateWithoutUserInput> | pendaftaranCreateWithoutUserInput[] | pendaftaranUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pendaftaranCreateOrConnectWithoutUserInput | pendaftaranCreateOrConnectWithoutUserInput[]
    upsert?: pendaftaranUpsertWithWhereUniqueWithoutUserInput | pendaftaranUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: pendaftaranCreateManyUserInputEnvelope
    set?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
    disconnect?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
    delete?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
    connect?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
    update?: pendaftaranUpdateWithWhereUniqueWithoutUserInput | pendaftaranUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: pendaftaranUpdateManyWithWhereWithoutUserInput | pendaftaranUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: pendaftaranScalarWhereInput | pendaftaranScalarWhereInput[]
  }

  export type jadwalUpdateManyWithoutUserNestedInput = {
    create?: XOR<jadwalCreateWithoutUserInput, jadwalUncheckedCreateWithoutUserInput> | jadwalCreateWithoutUserInput[] | jadwalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: jadwalCreateOrConnectWithoutUserInput | jadwalCreateOrConnectWithoutUserInput[]
    upsert?: jadwalUpsertWithWhereUniqueWithoutUserInput | jadwalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: jadwalCreateManyUserInputEnvelope
    set?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
    disconnect?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
    delete?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
    connect?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
    update?: jadwalUpdateWithWhereUniqueWithoutUserInput | jadwalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: jadwalUpdateManyWithWhereWithoutUserInput | jadwalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: jadwalScalarWhereInput | jadwalScalarWhereInput[]
  }

  export type modulUpdateManyWithoutUserNestedInput = {
    create?: XOR<modulCreateWithoutUserInput, modulUncheckedCreateWithoutUserInput> | modulCreateWithoutUserInput[] | modulUncheckedCreateWithoutUserInput[]
    connectOrCreate?: modulCreateOrConnectWithoutUserInput | modulCreateOrConnectWithoutUserInput[]
    upsert?: modulUpsertWithWhereUniqueWithoutUserInput | modulUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: modulCreateManyUserInputEnvelope
    set?: modulWhereUniqueInput | modulWhereUniqueInput[]
    disconnect?: modulWhereUniqueInput | modulWhereUniqueInput[]
    delete?: modulWhereUniqueInput | modulWhereUniqueInput[]
    connect?: modulWhereUniqueInput | modulWhereUniqueInput[]
    update?: modulUpdateWithWhereUniqueWithoutUserInput | modulUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: modulUpdateManyWithWhereWithoutUserInput | modulUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: modulScalarWhereInput | modulScalarWhereInput[]
  }

  export type pengumpulanUpdateManyWithoutUserNestedInput = {
    create?: XOR<pengumpulanCreateWithoutUserInput, pengumpulanUncheckedCreateWithoutUserInput> | pengumpulanCreateWithoutUserInput[] | pengumpulanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pengumpulanCreateOrConnectWithoutUserInput | pengumpulanCreateOrConnectWithoutUserInput[]
    upsert?: pengumpulanUpsertWithWhereUniqueWithoutUserInput | pengumpulanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: pengumpulanCreateManyUserInputEnvelope
    set?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
    disconnect?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
    delete?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
    connect?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
    update?: pengumpulanUpdateWithWhereUniqueWithoutUserInput | pengumpulanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: pengumpulanUpdateManyWithWhereWithoutUserInput | pengumpulanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: pengumpulanScalarWhereInput | pengumpulanScalarWhereInput[]
  }

  export type pengumumanUpdateManyWithoutPembuatNestedInput = {
    create?: XOR<pengumumanCreateWithoutPembuatInput, pengumumanUncheckedCreateWithoutPembuatInput> | pengumumanCreateWithoutPembuatInput[] | pengumumanUncheckedCreateWithoutPembuatInput[]
    connectOrCreate?: pengumumanCreateOrConnectWithoutPembuatInput | pengumumanCreateOrConnectWithoutPembuatInput[]
    upsert?: pengumumanUpsertWithWhereUniqueWithoutPembuatInput | pengumumanUpsertWithWhereUniqueWithoutPembuatInput[]
    createMany?: pengumumanCreateManyPembuatInputEnvelope
    set?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
    disconnect?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
    delete?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
    connect?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
    update?: pengumumanUpdateWithWhereUniqueWithoutPembuatInput | pengumumanUpdateWithWhereUniqueWithoutPembuatInput[]
    updateMany?: pengumumanUpdateManyWithWhereWithoutPembuatInput | pengumumanUpdateManyWithWhereWithoutPembuatInput[]
    deleteMany?: pengumumanScalarWhereInput | pengumumanScalarWhereInput[]
  }

  export type absensiUpdateManyWithoutUserNestedInput = {
    create?: XOR<absensiCreateWithoutUserInput, absensiUncheckedCreateWithoutUserInput> | absensiCreateWithoutUserInput[] | absensiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: absensiCreateOrConnectWithoutUserInput | absensiCreateOrConnectWithoutUserInput[]
    upsert?: absensiUpsertWithWhereUniqueWithoutUserInput | absensiUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: absensiCreateManyUserInputEnvelope
    set?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
    disconnect?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
    delete?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
    connect?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
    update?: absensiUpdateWithWhereUniqueWithoutUserInput | absensiUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: absensiUpdateManyWithWhereWithoutUserInput | absensiUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: absensiScalarWhereInput | absensiScalarWhereInput[]
  }

  export type pendaftaranUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<pendaftaranCreateWithoutUserInput, pendaftaranUncheckedCreateWithoutUserInput> | pendaftaranCreateWithoutUserInput[] | pendaftaranUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pendaftaranCreateOrConnectWithoutUserInput | pendaftaranCreateOrConnectWithoutUserInput[]
    upsert?: pendaftaranUpsertWithWhereUniqueWithoutUserInput | pendaftaranUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: pendaftaranCreateManyUserInputEnvelope
    set?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
    disconnect?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
    delete?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
    connect?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
    update?: pendaftaranUpdateWithWhereUniqueWithoutUserInput | pendaftaranUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: pendaftaranUpdateManyWithWhereWithoutUserInput | pendaftaranUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: pendaftaranScalarWhereInput | pendaftaranScalarWhereInput[]
  }

  export type jadwalUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<jadwalCreateWithoutUserInput, jadwalUncheckedCreateWithoutUserInput> | jadwalCreateWithoutUserInput[] | jadwalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: jadwalCreateOrConnectWithoutUserInput | jadwalCreateOrConnectWithoutUserInput[]
    upsert?: jadwalUpsertWithWhereUniqueWithoutUserInput | jadwalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: jadwalCreateManyUserInputEnvelope
    set?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
    disconnect?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
    delete?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
    connect?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
    update?: jadwalUpdateWithWhereUniqueWithoutUserInput | jadwalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: jadwalUpdateManyWithWhereWithoutUserInput | jadwalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: jadwalScalarWhereInput | jadwalScalarWhereInput[]
  }

  export type modulUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<modulCreateWithoutUserInput, modulUncheckedCreateWithoutUserInput> | modulCreateWithoutUserInput[] | modulUncheckedCreateWithoutUserInput[]
    connectOrCreate?: modulCreateOrConnectWithoutUserInput | modulCreateOrConnectWithoutUserInput[]
    upsert?: modulUpsertWithWhereUniqueWithoutUserInput | modulUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: modulCreateManyUserInputEnvelope
    set?: modulWhereUniqueInput | modulWhereUniqueInput[]
    disconnect?: modulWhereUniqueInput | modulWhereUniqueInput[]
    delete?: modulWhereUniqueInput | modulWhereUniqueInput[]
    connect?: modulWhereUniqueInput | modulWhereUniqueInput[]
    update?: modulUpdateWithWhereUniqueWithoutUserInput | modulUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: modulUpdateManyWithWhereWithoutUserInput | modulUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: modulScalarWhereInput | modulScalarWhereInput[]
  }

  export type pengumpulanUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<pengumpulanCreateWithoutUserInput, pengumpulanUncheckedCreateWithoutUserInput> | pengumpulanCreateWithoutUserInput[] | pengumpulanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: pengumpulanCreateOrConnectWithoutUserInput | pengumpulanCreateOrConnectWithoutUserInput[]
    upsert?: pengumpulanUpsertWithWhereUniqueWithoutUserInput | pengumpulanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: pengumpulanCreateManyUserInputEnvelope
    set?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
    disconnect?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
    delete?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
    connect?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
    update?: pengumpulanUpdateWithWhereUniqueWithoutUserInput | pengumpulanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: pengumpulanUpdateManyWithWhereWithoutUserInput | pengumpulanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: pengumpulanScalarWhereInput | pengumpulanScalarWhereInput[]
  }

  export type pengumumanUncheckedUpdateManyWithoutPembuatNestedInput = {
    create?: XOR<pengumumanCreateWithoutPembuatInput, pengumumanUncheckedCreateWithoutPembuatInput> | pengumumanCreateWithoutPembuatInput[] | pengumumanUncheckedCreateWithoutPembuatInput[]
    connectOrCreate?: pengumumanCreateOrConnectWithoutPembuatInput | pengumumanCreateOrConnectWithoutPembuatInput[]
    upsert?: pengumumanUpsertWithWhereUniqueWithoutPembuatInput | pengumumanUpsertWithWhereUniqueWithoutPembuatInput[]
    createMany?: pengumumanCreateManyPembuatInputEnvelope
    set?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
    disconnect?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
    delete?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
    connect?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
    update?: pengumumanUpdateWithWhereUniqueWithoutPembuatInput | pengumumanUpdateWithWhereUniqueWithoutPembuatInput[]
    updateMany?: pengumumanUpdateManyWithWhereWithoutPembuatInput | pengumumanUpdateManyWithWhereWithoutPembuatInput[]
    deleteMany?: pengumumanScalarWhereInput | pengumumanScalarWhereInput[]
  }

  export type absensiUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<absensiCreateWithoutUserInput, absensiUncheckedCreateWithoutUserInput> | absensiCreateWithoutUserInput[] | absensiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: absensiCreateOrConnectWithoutUserInput | absensiCreateOrConnectWithoutUserInput[]
    upsert?: absensiUpsertWithWhereUniqueWithoutUserInput | absensiUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: absensiCreateManyUserInputEnvelope
    set?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
    disconnect?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
    delete?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
    connect?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
    update?: absensiUpdateWithWhereUniqueWithoutUserInput | absensiUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: absensiUpdateManyWithWhereWithoutUserInput | absensiUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: absensiScalarWhereInput | absensiScalarWhereInput[]
  }

  export type praktikumCreateNestedManyWithoutLabInput = {
    create?: XOR<praktikumCreateWithoutLabInput, praktikumUncheckedCreateWithoutLabInput> | praktikumCreateWithoutLabInput[] | praktikumUncheckedCreateWithoutLabInput[]
    connectOrCreate?: praktikumCreateOrConnectWithoutLabInput | praktikumCreateOrConnectWithoutLabInput[]
    createMany?: praktikumCreateManyLabInputEnvelope
    connect?: praktikumWhereUniqueInput | praktikumWhereUniqueInput[]
  }

  export type praktikumUncheckedCreateNestedManyWithoutLabInput = {
    create?: XOR<praktikumCreateWithoutLabInput, praktikumUncheckedCreateWithoutLabInput> | praktikumCreateWithoutLabInput[] | praktikumUncheckedCreateWithoutLabInput[]
    connectOrCreate?: praktikumCreateOrConnectWithoutLabInput | praktikumCreateOrConnectWithoutLabInput[]
    createMany?: praktikumCreateManyLabInputEnvelope
    connect?: praktikumWhereUniqueInput | praktikumWhereUniqueInput[]
  }

  export type praktikumUpdateManyWithoutLabNestedInput = {
    create?: XOR<praktikumCreateWithoutLabInput, praktikumUncheckedCreateWithoutLabInput> | praktikumCreateWithoutLabInput[] | praktikumUncheckedCreateWithoutLabInput[]
    connectOrCreate?: praktikumCreateOrConnectWithoutLabInput | praktikumCreateOrConnectWithoutLabInput[]
    upsert?: praktikumUpsertWithWhereUniqueWithoutLabInput | praktikumUpsertWithWhereUniqueWithoutLabInput[]
    createMany?: praktikumCreateManyLabInputEnvelope
    set?: praktikumWhereUniqueInput | praktikumWhereUniqueInput[]
    disconnect?: praktikumWhereUniqueInput | praktikumWhereUniqueInput[]
    delete?: praktikumWhereUniqueInput | praktikumWhereUniqueInput[]
    connect?: praktikumWhereUniqueInput | praktikumWhereUniqueInput[]
    update?: praktikumUpdateWithWhereUniqueWithoutLabInput | praktikumUpdateWithWhereUniqueWithoutLabInput[]
    updateMany?: praktikumUpdateManyWithWhereWithoutLabInput | praktikumUpdateManyWithWhereWithoutLabInput[]
    deleteMany?: praktikumScalarWhereInput | praktikumScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type praktikumUncheckedUpdateManyWithoutLabNestedInput = {
    create?: XOR<praktikumCreateWithoutLabInput, praktikumUncheckedCreateWithoutLabInput> | praktikumCreateWithoutLabInput[] | praktikumUncheckedCreateWithoutLabInput[]
    connectOrCreate?: praktikumCreateOrConnectWithoutLabInput | praktikumCreateOrConnectWithoutLabInput[]
    upsert?: praktikumUpsertWithWhereUniqueWithoutLabInput | praktikumUpsertWithWhereUniqueWithoutLabInput[]
    createMany?: praktikumCreateManyLabInputEnvelope
    set?: praktikumWhereUniqueInput | praktikumWhereUniqueInput[]
    disconnect?: praktikumWhereUniqueInput | praktikumWhereUniqueInput[]
    delete?: praktikumWhereUniqueInput | praktikumWhereUniqueInput[]
    connect?: praktikumWhereUniqueInput | praktikumWhereUniqueInput[]
    update?: praktikumUpdateWithWhereUniqueWithoutLabInput | praktikumUpdateWithWhereUniqueWithoutLabInput[]
    updateMany?: praktikumUpdateManyWithWhereWithoutLabInput | praktikumUpdateManyWithWhereWithoutLabInput[]
    deleteMany?: praktikumScalarWhereInput | praktikumScalarWhereInput[]
  }

  export type labCreateNestedOneWithoutPraktikumInput = {
    create?: XOR<labCreateWithoutPraktikumInput, labUncheckedCreateWithoutPraktikumInput>
    connectOrCreate?: labCreateOrConnectWithoutPraktikumInput
    connect?: labWhereUniqueInput
  }

  export type pendaftaranCreateNestedManyWithoutPraktikumInput = {
    create?: XOR<pendaftaranCreateWithoutPraktikumInput, pendaftaranUncheckedCreateWithoutPraktikumInput> | pendaftaranCreateWithoutPraktikumInput[] | pendaftaranUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: pendaftaranCreateOrConnectWithoutPraktikumInput | pendaftaranCreateOrConnectWithoutPraktikumInput[]
    createMany?: pendaftaranCreateManyPraktikumInputEnvelope
    connect?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
  }

  export type jadwalCreateNestedManyWithoutPraktikumInput = {
    create?: XOR<jadwalCreateWithoutPraktikumInput, jadwalUncheckedCreateWithoutPraktikumInput> | jadwalCreateWithoutPraktikumInput[] | jadwalUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: jadwalCreateOrConnectWithoutPraktikumInput | jadwalCreateOrConnectWithoutPraktikumInput[]
    createMany?: jadwalCreateManyPraktikumInputEnvelope
    connect?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
  }

  export type modulCreateNestedManyWithoutPraktikumInput = {
    create?: XOR<modulCreateWithoutPraktikumInput, modulUncheckedCreateWithoutPraktikumInput> | modulCreateWithoutPraktikumInput[] | modulUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: modulCreateOrConnectWithoutPraktikumInput | modulCreateOrConnectWithoutPraktikumInput[]
    createMany?: modulCreateManyPraktikumInputEnvelope
    connect?: modulWhereUniqueInput | modulWhereUniqueInput[]
  }

  export type tugasCreateNestedManyWithoutPraktikumInput = {
    create?: XOR<tugasCreateWithoutPraktikumInput, tugasUncheckedCreateWithoutPraktikumInput> | tugasCreateWithoutPraktikumInput[] | tugasUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: tugasCreateOrConnectWithoutPraktikumInput | tugasCreateOrConnectWithoutPraktikumInput[]
    createMany?: tugasCreateManyPraktikumInputEnvelope
    connect?: tugasWhereUniqueInput | tugasWhereUniqueInput[]
  }

  export type pengumumanCreateNestedManyWithoutPraktikumInput = {
    create?: XOR<pengumumanCreateWithoutPraktikumInput, pengumumanUncheckedCreateWithoutPraktikumInput> | pengumumanCreateWithoutPraktikumInput[] | pengumumanUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: pengumumanCreateOrConnectWithoutPraktikumInput | pengumumanCreateOrConnectWithoutPraktikumInput[]
    createMany?: pengumumanCreateManyPraktikumInputEnvelope
    connect?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
  }

  export type pendaftaranUncheckedCreateNestedManyWithoutPraktikumInput = {
    create?: XOR<pendaftaranCreateWithoutPraktikumInput, pendaftaranUncheckedCreateWithoutPraktikumInput> | pendaftaranCreateWithoutPraktikumInput[] | pendaftaranUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: pendaftaranCreateOrConnectWithoutPraktikumInput | pendaftaranCreateOrConnectWithoutPraktikumInput[]
    createMany?: pendaftaranCreateManyPraktikumInputEnvelope
    connect?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
  }

  export type jadwalUncheckedCreateNestedManyWithoutPraktikumInput = {
    create?: XOR<jadwalCreateWithoutPraktikumInput, jadwalUncheckedCreateWithoutPraktikumInput> | jadwalCreateWithoutPraktikumInput[] | jadwalUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: jadwalCreateOrConnectWithoutPraktikumInput | jadwalCreateOrConnectWithoutPraktikumInput[]
    createMany?: jadwalCreateManyPraktikumInputEnvelope
    connect?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
  }

  export type modulUncheckedCreateNestedManyWithoutPraktikumInput = {
    create?: XOR<modulCreateWithoutPraktikumInput, modulUncheckedCreateWithoutPraktikumInput> | modulCreateWithoutPraktikumInput[] | modulUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: modulCreateOrConnectWithoutPraktikumInput | modulCreateOrConnectWithoutPraktikumInput[]
    createMany?: modulCreateManyPraktikumInputEnvelope
    connect?: modulWhereUniqueInput | modulWhereUniqueInput[]
  }

  export type tugasUncheckedCreateNestedManyWithoutPraktikumInput = {
    create?: XOR<tugasCreateWithoutPraktikumInput, tugasUncheckedCreateWithoutPraktikumInput> | tugasCreateWithoutPraktikumInput[] | tugasUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: tugasCreateOrConnectWithoutPraktikumInput | tugasCreateOrConnectWithoutPraktikumInput[]
    createMany?: tugasCreateManyPraktikumInputEnvelope
    connect?: tugasWhereUniqueInput | tugasWhereUniqueInput[]
  }

  export type pengumumanUncheckedCreateNestedManyWithoutPraktikumInput = {
    create?: XOR<pengumumanCreateWithoutPraktikumInput, pengumumanUncheckedCreateWithoutPraktikumInput> | pengumumanCreateWithoutPraktikumInput[] | pengumumanUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: pengumumanCreateOrConnectWithoutPraktikumInput | pengumumanCreateOrConnectWithoutPraktikumInput[]
    createMany?: pengumumanCreateManyPraktikumInputEnvelope
    connect?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
  }

  export type labUpdateOneRequiredWithoutPraktikumNestedInput = {
    create?: XOR<labCreateWithoutPraktikumInput, labUncheckedCreateWithoutPraktikumInput>
    connectOrCreate?: labCreateOrConnectWithoutPraktikumInput
    upsert?: labUpsertWithoutPraktikumInput
    connect?: labWhereUniqueInput
    update?: XOR<XOR<labUpdateToOneWithWhereWithoutPraktikumInput, labUpdateWithoutPraktikumInput>, labUncheckedUpdateWithoutPraktikumInput>
  }

  export type pendaftaranUpdateManyWithoutPraktikumNestedInput = {
    create?: XOR<pendaftaranCreateWithoutPraktikumInput, pendaftaranUncheckedCreateWithoutPraktikumInput> | pendaftaranCreateWithoutPraktikumInput[] | pendaftaranUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: pendaftaranCreateOrConnectWithoutPraktikumInput | pendaftaranCreateOrConnectWithoutPraktikumInput[]
    upsert?: pendaftaranUpsertWithWhereUniqueWithoutPraktikumInput | pendaftaranUpsertWithWhereUniqueWithoutPraktikumInput[]
    createMany?: pendaftaranCreateManyPraktikumInputEnvelope
    set?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
    disconnect?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
    delete?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
    connect?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
    update?: pendaftaranUpdateWithWhereUniqueWithoutPraktikumInput | pendaftaranUpdateWithWhereUniqueWithoutPraktikumInput[]
    updateMany?: pendaftaranUpdateManyWithWhereWithoutPraktikumInput | pendaftaranUpdateManyWithWhereWithoutPraktikumInput[]
    deleteMany?: pendaftaranScalarWhereInput | pendaftaranScalarWhereInput[]
  }

  export type jadwalUpdateManyWithoutPraktikumNestedInput = {
    create?: XOR<jadwalCreateWithoutPraktikumInput, jadwalUncheckedCreateWithoutPraktikumInput> | jadwalCreateWithoutPraktikumInput[] | jadwalUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: jadwalCreateOrConnectWithoutPraktikumInput | jadwalCreateOrConnectWithoutPraktikumInput[]
    upsert?: jadwalUpsertWithWhereUniqueWithoutPraktikumInput | jadwalUpsertWithWhereUniqueWithoutPraktikumInput[]
    createMany?: jadwalCreateManyPraktikumInputEnvelope
    set?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
    disconnect?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
    delete?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
    connect?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
    update?: jadwalUpdateWithWhereUniqueWithoutPraktikumInput | jadwalUpdateWithWhereUniqueWithoutPraktikumInput[]
    updateMany?: jadwalUpdateManyWithWhereWithoutPraktikumInput | jadwalUpdateManyWithWhereWithoutPraktikumInput[]
    deleteMany?: jadwalScalarWhereInput | jadwalScalarWhereInput[]
  }

  export type modulUpdateManyWithoutPraktikumNestedInput = {
    create?: XOR<modulCreateWithoutPraktikumInput, modulUncheckedCreateWithoutPraktikumInput> | modulCreateWithoutPraktikumInput[] | modulUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: modulCreateOrConnectWithoutPraktikumInput | modulCreateOrConnectWithoutPraktikumInput[]
    upsert?: modulUpsertWithWhereUniqueWithoutPraktikumInput | modulUpsertWithWhereUniqueWithoutPraktikumInput[]
    createMany?: modulCreateManyPraktikumInputEnvelope
    set?: modulWhereUniqueInput | modulWhereUniqueInput[]
    disconnect?: modulWhereUniqueInput | modulWhereUniqueInput[]
    delete?: modulWhereUniqueInput | modulWhereUniqueInput[]
    connect?: modulWhereUniqueInput | modulWhereUniqueInput[]
    update?: modulUpdateWithWhereUniqueWithoutPraktikumInput | modulUpdateWithWhereUniqueWithoutPraktikumInput[]
    updateMany?: modulUpdateManyWithWhereWithoutPraktikumInput | modulUpdateManyWithWhereWithoutPraktikumInput[]
    deleteMany?: modulScalarWhereInput | modulScalarWhereInput[]
  }

  export type tugasUpdateManyWithoutPraktikumNestedInput = {
    create?: XOR<tugasCreateWithoutPraktikumInput, tugasUncheckedCreateWithoutPraktikumInput> | tugasCreateWithoutPraktikumInput[] | tugasUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: tugasCreateOrConnectWithoutPraktikumInput | tugasCreateOrConnectWithoutPraktikumInput[]
    upsert?: tugasUpsertWithWhereUniqueWithoutPraktikumInput | tugasUpsertWithWhereUniqueWithoutPraktikumInput[]
    createMany?: tugasCreateManyPraktikumInputEnvelope
    set?: tugasWhereUniqueInput | tugasWhereUniqueInput[]
    disconnect?: tugasWhereUniqueInput | tugasWhereUniqueInput[]
    delete?: tugasWhereUniqueInput | tugasWhereUniqueInput[]
    connect?: tugasWhereUniqueInput | tugasWhereUniqueInput[]
    update?: tugasUpdateWithWhereUniqueWithoutPraktikumInput | tugasUpdateWithWhereUniqueWithoutPraktikumInput[]
    updateMany?: tugasUpdateManyWithWhereWithoutPraktikumInput | tugasUpdateManyWithWhereWithoutPraktikumInput[]
    deleteMany?: tugasScalarWhereInput | tugasScalarWhereInput[]
  }

  export type pengumumanUpdateManyWithoutPraktikumNestedInput = {
    create?: XOR<pengumumanCreateWithoutPraktikumInput, pengumumanUncheckedCreateWithoutPraktikumInput> | pengumumanCreateWithoutPraktikumInput[] | pengumumanUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: pengumumanCreateOrConnectWithoutPraktikumInput | pengumumanCreateOrConnectWithoutPraktikumInput[]
    upsert?: pengumumanUpsertWithWhereUniqueWithoutPraktikumInput | pengumumanUpsertWithWhereUniqueWithoutPraktikumInput[]
    createMany?: pengumumanCreateManyPraktikumInputEnvelope
    set?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
    disconnect?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
    delete?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
    connect?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
    update?: pengumumanUpdateWithWhereUniqueWithoutPraktikumInput | pengumumanUpdateWithWhereUniqueWithoutPraktikumInput[]
    updateMany?: pengumumanUpdateManyWithWhereWithoutPraktikumInput | pengumumanUpdateManyWithWhereWithoutPraktikumInput[]
    deleteMany?: pengumumanScalarWhereInput | pengumumanScalarWhereInput[]
  }

  export type pendaftaranUncheckedUpdateManyWithoutPraktikumNestedInput = {
    create?: XOR<pendaftaranCreateWithoutPraktikumInput, pendaftaranUncheckedCreateWithoutPraktikumInput> | pendaftaranCreateWithoutPraktikumInput[] | pendaftaranUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: pendaftaranCreateOrConnectWithoutPraktikumInput | pendaftaranCreateOrConnectWithoutPraktikumInput[]
    upsert?: pendaftaranUpsertWithWhereUniqueWithoutPraktikumInput | pendaftaranUpsertWithWhereUniqueWithoutPraktikumInput[]
    createMany?: pendaftaranCreateManyPraktikumInputEnvelope
    set?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
    disconnect?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
    delete?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
    connect?: pendaftaranWhereUniqueInput | pendaftaranWhereUniqueInput[]
    update?: pendaftaranUpdateWithWhereUniqueWithoutPraktikumInput | pendaftaranUpdateWithWhereUniqueWithoutPraktikumInput[]
    updateMany?: pendaftaranUpdateManyWithWhereWithoutPraktikumInput | pendaftaranUpdateManyWithWhereWithoutPraktikumInput[]
    deleteMany?: pendaftaranScalarWhereInput | pendaftaranScalarWhereInput[]
  }

  export type jadwalUncheckedUpdateManyWithoutPraktikumNestedInput = {
    create?: XOR<jadwalCreateWithoutPraktikumInput, jadwalUncheckedCreateWithoutPraktikumInput> | jadwalCreateWithoutPraktikumInput[] | jadwalUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: jadwalCreateOrConnectWithoutPraktikumInput | jadwalCreateOrConnectWithoutPraktikumInput[]
    upsert?: jadwalUpsertWithWhereUniqueWithoutPraktikumInput | jadwalUpsertWithWhereUniqueWithoutPraktikumInput[]
    createMany?: jadwalCreateManyPraktikumInputEnvelope
    set?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
    disconnect?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
    delete?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
    connect?: jadwalWhereUniqueInput | jadwalWhereUniqueInput[]
    update?: jadwalUpdateWithWhereUniqueWithoutPraktikumInput | jadwalUpdateWithWhereUniqueWithoutPraktikumInput[]
    updateMany?: jadwalUpdateManyWithWhereWithoutPraktikumInput | jadwalUpdateManyWithWhereWithoutPraktikumInput[]
    deleteMany?: jadwalScalarWhereInput | jadwalScalarWhereInput[]
  }

  export type modulUncheckedUpdateManyWithoutPraktikumNestedInput = {
    create?: XOR<modulCreateWithoutPraktikumInput, modulUncheckedCreateWithoutPraktikumInput> | modulCreateWithoutPraktikumInput[] | modulUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: modulCreateOrConnectWithoutPraktikumInput | modulCreateOrConnectWithoutPraktikumInput[]
    upsert?: modulUpsertWithWhereUniqueWithoutPraktikumInput | modulUpsertWithWhereUniqueWithoutPraktikumInput[]
    createMany?: modulCreateManyPraktikumInputEnvelope
    set?: modulWhereUniqueInput | modulWhereUniqueInput[]
    disconnect?: modulWhereUniqueInput | modulWhereUniqueInput[]
    delete?: modulWhereUniqueInput | modulWhereUniqueInput[]
    connect?: modulWhereUniqueInput | modulWhereUniqueInput[]
    update?: modulUpdateWithWhereUniqueWithoutPraktikumInput | modulUpdateWithWhereUniqueWithoutPraktikumInput[]
    updateMany?: modulUpdateManyWithWhereWithoutPraktikumInput | modulUpdateManyWithWhereWithoutPraktikumInput[]
    deleteMany?: modulScalarWhereInput | modulScalarWhereInput[]
  }

  export type tugasUncheckedUpdateManyWithoutPraktikumNestedInput = {
    create?: XOR<tugasCreateWithoutPraktikumInput, tugasUncheckedCreateWithoutPraktikumInput> | tugasCreateWithoutPraktikumInput[] | tugasUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: tugasCreateOrConnectWithoutPraktikumInput | tugasCreateOrConnectWithoutPraktikumInput[]
    upsert?: tugasUpsertWithWhereUniqueWithoutPraktikumInput | tugasUpsertWithWhereUniqueWithoutPraktikumInput[]
    createMany?: tugasCreateManyPraktikumInputEnvelope
    set?: tugasWhereUniqueInput | tugasWhereUniqueInput[]
    disconnect?: tugasWhereUniqueInput | tugasWhereUniqueInput[]
    delete?: tugasWhereUniqueInput | tugasWhereUniqueInput[]
    connect?: tugasWhereUniqueInput | tugasWhereUniqueInput[]
    update?: tugasUpdateWithWhereUniqueWithoutPraktikumInput | tugasUpdateWithWhereUniqueWithoutPraktikumInput[]
    updateMany?: tugasUpdateManyWithWhereWithoutPraktikumInput | tugasUpdateManyWithWhereWithoutPraktikumInput[]
    deleteMany?: tugasScalarWhereInput | tugasScalarWhereInput[]
  }

  export type pengumumanUncheckedUpdateManyWithoutPraktikumNestedInput = {
    create?: XOR<pengumumanCreateWithoutPraktikumInput, pengumumanUncheckedCreateWithoutPraktikumInput> | pengumumanCreateWithoutPraktikumInput[] | pengumumanUncheckedCreateWithoutPraktikumInput[]
    connectOrCreate?: pengumumanCreateOrConnectWithoutPraktikumInput | pengumumanCreateOrConnectWithoutPraktikumInput[]
    upsert?: pengumumanUpsertWithWhereUniqueWithoutPraktikumInput | pengumumanUpsertWithWhereUniqueWithoutPraktikumInput[]
    createMany?: pengumumanCreateManyPraktikumInputEnvelope
    set?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
    disconnect?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
    delete?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
    connect?: pengumumanWhereUniqueInput | pengumumanWhereUniqueInput[]
    update?: pengumumanUpdateWithWhereUniqueWithoutPraktikumInput | pengumumanUpdateWithWhereUniqueWithoutPraktikumInput[]
    updateMany?: pengumumanUpdateManyWithWhereWithoutPraktikumInput | pengumumanUpdateManyWithWhereWithoutPraktikumInput[]
    deleteMany?: pengumumanScalarWhereInput | pengumumanScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutPendaftaranInput = {
    create?: XOR<userCreateWithoutPendaftaranInput, userUncheckedCreateWithoutPendaftaranInput>
    connectOrCreate?: userCreateOrConnectWithoutPendaftaranInput
    connect?: userWhereUniqueInput
  }

  export type praktikumCreateNestedOneWithoutPendaftaranInput = {
    create?: XOR<praktikumCreateWithoutPendaftaranInput, praktikumUncheckedCreateWithoutPendaftaranInput>
    connectOrCreate?: praktikumCreateOrConnectWithoutPendaftaranInput
    connect?: praktikumWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type userUpdateOneRequiredWithoutPendaftaranNestedInput = {
    create?: XOR<userCreateWithoutPendaftaranInput, userUncheckedCreateWithoutPendaftaranInput>
    connectOrCreate?: userCreateOrConnectWithoutPendaftaranInput
    upsert?: userUpsertWithoutPendaftaranInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPendaftaranInput, userUpdateWithoutPendaftaranInput>, userUncheckedUpdateWithoutPendaftaranInput>
  }

  export type praktikumUpdateOneRequiredWithoutPendaftaranNestedInput = {
    create?: XOR<praktikumCreateWithoutPendaftaranInput, praktikumUncheckedCreateWithoutPendaftaranInput>
    connectOrCreate?: praktikumCreateOrConnectWithoutPendaftaranInput
    upsert?: praktikumUpsertWithoutPendaftaranInput
    connect?: praktikumWhereUniqueInput
    update?: XOR<XOR<praktikumUpdateToOneWithWhereWithoutPendaftaranInput, praktikumUpdateWithoutPendaftaranInput>, praktikumUncheckedUpdateWithoutPendaftaranInput>
  }

  export type praktikumCreateNestedOneWithoutJadwalInput = {
    create?: XOR<praktikumCreateWithoutJadwalInput, praktikumUncheckedCreateWithoutJadwalInput>
    connectOrCreate?: praktikumCreateOrConnectWithoutJadwalInput
    connect?: praktikumWhereUniqueInput
  }

  export type userCreateNestedOneWithoutJadwalInput = {
    create?: XOR<userCreateWithoutJadwalInput, userUncheckedCreateWithoutJadwalInput>
    connectOrCreate?: userCreateOrConnectWithoutJadwalInput
    connect?: userWhereUniqueInput
  }

  export type absensiCreateNestedManyWithoutJadwalInput = {
    create?: XOR<absensiCreateWithoutJadwalInput, absensiUncheckedCreateWithoutJadwalInput> | absensiCreateWithoutJadwalInput[] | absensiUncheckedCreateWithoutJadwalInput[]
    connectOrCreate?: absensiCreateOrConnectWithoutJadwalInput | absensiCreateOrConnectWithoutJadwalInput[]
    createMany?: absensiCreateManyJadwalInputEnvelope
    connect?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
  }

  export type absensiUncheckedCreateNestedManyWithoutJadwalInput = {
    create?: XOR<absensiCreateWithoutJadwalInput, absensiUncheckedCreateWithoutJadwalInput> | absensiCreateWithoutJadwalInput[] | absensiUncheckedCreateWithoutJadwalInput[]
    connectOrCreate?: absensiCreateOrConnectWithoutJadwalInput | absensiCreateOrConnectWithoutJadwalInput[]
    createMany?: absensiCreateManyJadwalInputEnvelope
    connect?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type praktikumUpdateOneRequiredWithoutJadwalNestedInput = {
    create?: XOR<praktikumCreateWithoutJadwalInput, praktikumUncheckedCreateWithoutJadwalInput>
    connectOrCreate?: praktikumCreateOrConnectWithoutJadwalInput
    upsert?: praktikumUpsertWithoutJadwalInput
    connect?: praktikumWhereUniqueInput
    update?: XOR<XOR<praktikumUpdateToOneWithWhereWithoutJadwalInput, praktikumUpdateWithoutJadwalInput>, praktikumUncheckedUpdateWithoutJadwalInput>
  }

  export type userUpdateOneRequiredWithoutJadwalNestedInput = {
    create?: XOR<userCreateWithoutJadwalInput, userUncheckedCreateWithoutJadwalInput>
    connectOrCreate?: userCreateOrConnectWithoutJadwalInput
    upsert?: userUpsertWithoutJadwalInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutJadwalInput, userUpdateWithoutJadwalInput>, userUncheckedUpdateWithoutJadwalInput>
  }

  export type absensiUpdateManyWithoutJadwalNestedInput = {
    create?: XOR<absensiCreateWithoutJadwalInput, absensiUncheckedCreateWithoutJadwalInput> | absensiCreateWithoutJadwalInput[] | absensiUncheckedCreateWithoutJadwalInput[]
    connectOrCreate?: absensiCreateOrConnectWithoutJadwalInput | absensiCreateOrConnectWithoutJadwalInput[]
    upsert?: absensiUpsertWithWhereUniqueWithoutJadwalInput | absensiUpsertWithWhereUniqueWithoutJadwalInput[]
    createMany?: absensiCreateManyJadwalInputEnvelope
    set?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
    disconnect?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
    delete?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
    connect?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
    update?: absensiUpdateWithWhereUniqueWithoutJadwalInput | absensiUpdateWithWhereUniqueWithoutJadwalInput[]
    updateMany?: absensiUpdateManyWithWhereWithoutJadwalInput | absensiUpdateManyWithWhereWithoutJadwalInput[]
    deleteMany?: absensiScalarWhereInput | absensiScalarWhereInput[]
  }

  export type absensiUncheckedUpdateManyWithoutJadwalNestedInput = {
    create?: XOR<absensiCreateWithoutJadwalInput, absensiUncheckedCreateWithoutJadwalInput> | absensiCreateWithoutJadwalInput[] | absensiUncheckedCreateWithoutJadwalInput[]
    connectOrCreate?: absensiCreateOrConnectWithoutJadwalInput | absensiCreateOrConnectWithoutJadwalInput[]
    upsert?: absensiUpsertWithWhereUniqueWithoutJadwalInput | absensiUpsertWithWhereUniqueWithoutJadwalInput[]
    createMany?: absensiCreateManyJadwalInputEnvelope
    set?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
    disconnect?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
    delete?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
    connect?: absensiWhereUniqueInput | absensiWhereUniqueInput[]
    update?: absensiUpdateWithWhereUniqueWithoutJadwalInput | absensiUpdateWithWhereUniqueWithoutJadwalInput[]
    updateMany?: absensiUpdateManyWithWhereWithoutJadwalInput | absensiUpdateManyWithWhereWithoutJadwalInput[]
    deleteMany?: absensiScalarWhereInput | absensiScalarWhereInput[]
  }

  export type praktikumCreateNestedOneWithoutModulInput = {
    create?: XOR<praktikumCreateWithoutModulInput, praktikumUncheckedCreateWithoutModulInput>
    connectOrCreate?: praktikumCreateOrConnectWithoutModulInput
    connect?: praktikumWhereUniqueInput
  }

  export type userCreateNestedOneWithoutModulInput = {
    create?: XOR<userCreateWithoutModulInput, userUncheckedCreateWithoutModulInput>
    connectOrCreate?: userCreateOrConnectWithoutModulInput
    connect?: userWhereUniqueInput
  }

  export type praktikumUpdateOneRequiredWithoutModulNestedInput = {
    create?: XOR<praktikumCreateWithoutModulInput, praktikumUncheckedCreateWithoutModulInput>
    connectOrCreate?: praktikumCreateOrConnectWithoutModulInput
    upsert?: praktikumUpsertWithoutModulInput
    connect?: praktikumWhereUniqueInput
    update?: XOR<XOR<praktikumUpdateToOneWithWhereWithoutModulInput, praktikumUpdateWithoutModulInput>, praktikumUncheckedUpdateWithoutModulInput>
  }

  export type userUpdateOneRequiredWithoutModulNestedInput = {
    create?: XOR<userCreateWithoutModulInput, userUncheckedCreateWithoutModulInput>
    connectOrCreate?: userCreateOrConnectWithoutModulInput
    upsert?: userUpsertWithoutModulInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutModulInput, userUpdateWithoutModulInput>, userUncheckedUpdateWithoutModulInput>
  }

  export type praktikumCreateNestedOneWithoutTugasInput = {
    create?: XOR<praktikumCreateWithoutTugasInput, praktikumUncheckedCreateWithoutTugasInput>
    connectOrCreate?: praktikumCreateOrConnectWithoutTugasInput
    connect?: praktikumWhereUniqueInput
  }

  export type pengumpulanCreateNestedManyWithoutTugasInput = {
    create?: XOR<pengumpulanCreateWithoutTugasInput, pengumpulanUncheckedCreateWithoutTugasInput> | pengumpulanCreateWithoutTugasInput[] | pengumpulanUncheckedCreateWithoutTugasInput[]
    connectOrCreate?: pengumpulanCreateOrConnectWithoutTugasInput | pengumpulanCreateOrConnectWithoutTugasInput[]
    createMany?: pengumpulanCreateManyTugasInputEnvelope
    connect?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
  }

  export type pengumpulanUncheckedCreateNestedManyWithoutTugasInput = {
    create?: XOR<pengumpulanCreateWithoutTugasInput, pengumpulanUncheckedCreateWithoutTugasInput> | pengumpulanCreateWithoutTugasInput[] | pengumpulanUncheckedCreateWithoutTugasInput[]
    connectOrCreate?: pengumpulanCreateOrConnectWithoutTugasInput | pengumpulanCreateOrConnectWithoutTugasInput[]
    createMany?: pengumpulanCreateManyTugasInputEnvelope
    connect?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
  }

  export type EnumStatusTugasFieldUpdateOperationsInput = {
    set?: $Enums.StatusTugas
  }

  export type praktikumUpdateOneRequiredWithoutTugasNestedInput = {
    create?: XOR<praktikumCreateWithoutTugasInput, praktikumUncheckedCreateWithoutTugasInput>
    connectOrCreate?: praktikumCreateOrConnectWithoutTugasInput
    upsert?: praktikumUpsertWithoutTugasInput
    connect?: praktikumWhereUniqueInput
    update?: XOR<XOR<praktikumUpdateToOneWithWhereWithoutTugasInput, praktikumUpdateWithoutTugasInput>, praktikumUncheckedUpdateWithoutTugasInput>
  }

  export type pengumpulanUpdateManyWithoutTugasNestedInput = {
    create?: XOR<pengumpulanCreateWithoutTugasInput, pengumpulanUncheckedCreateWithoutTugasInput> | pengumpulanCreateWithoutTugasInput[] | pengumpulanUncheckedCreateWithoutTugasInput[]
    connectOrCreate?: pengumpulanCreateOrConnectWithoutTugasInput | pengumpulanCreateOrConnectWithoutTugasInput[]
    upsert?: pengumpulanUpsertWithWhereUniqueWithoutTugasInput | pengumpulanUpsertWithWhereUniqueWithoutTugasInput[]
    createMany?: pengumpulanCreateManyTugasInputEnvelope
    set?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
    disconnect?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
    delete?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
    connect?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
    update?: pengumpulanUpdateWithWhereUniqueWithoutTugasInput | pengumpulanUpdateWithWhereUniqueWithoutTugasInput[]
    updateMany?: pengumpulanUpdateManyWithWhereWithoutTugasInput | pengumpulanUpdateManyWithWhereWithoutTugasInput[]
    deleteMany?: pengumpulanScalarWhereInput | pengumpulanScalarWhereInput[]
  }

  export type pengumpulanUncheckedUpdateManyWithoutTugasNestedInput = {
    create?: XOR<pengumpulanCreateWithoutTugasInput, pengumpulanUncheckedCreateWithoutTugasInput> | pengumpulanCreateWithoutTugasInput[] | pengumpulanUncheckedCreateWithoutTugasInput[]
    connectOrCreate?: pengumpulanCreateOrConnectWithoutTugasInput | pengumpulanCreateOrConnectWithoutTugasInput[]
    upsert?: pengumpulanUpsertWithWhereUniqueWithoutTugasInput | pengumpulanUpsertWithWhereUniqueWithoutTugasInput[]
    createMany?: pengumpulanCreateManyTugasInputEnvelope
    set?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
    disconnect?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
    delete?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
    connect?: pengumpulanWhereUniqueInput | pengumpulanWhereUniqueInput[]
    update?: pengumpulanUpdateWithWhereUniqueWithoutTugasInput | pengumpulanUpdateWithWhereUniqueWithoutTugasInput[]
    updateMany?: pengumpulanUpdateManyWithWhereWithoutTugasInput | pengumpulanUpdateManyWithWhereWithoutTugasInput[]
    deleteMany?: pengumpulanScalarWhereInput | pengumpulanScalarWhereInput[]
  }

  export type tugasCreateNestedOneWithoutPengumpulanInput = {
    create?: XOR<tugasCreateWithoutPengumpulanInput, tugasUncheckedCreateWithoutPengumpulanInput>
    connectOrCreate?: tugasCreateOrConnectWithoutPengumpulanInput
    connect?: tugasWhereUniqueInput
  }

  export type userCreateNestedOneWithoutPengumpulanInput = {
    create?: XOR<userCreateWithoutPengumpulanInput, userUncheckedCreateWithoutPengumpulanInput>
    connectOrCreate?: userCreateOrConnectWithoutPengumpulanInput
    connect?: userWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type tugasUpdateOneRequiredWithoutPengumpulanNestedInput = {
    create?: XOR<tugasCreateWithoutPengumpulanInput, tugasUncheckedCreateWithoutPengumpulanInput>
    connectOrCreate?: tugasCreateOrConnectWithoutPengumpulanInput
    upsert?: tugasUpsertWithoutPengumpulanInput
    connect?: tugasWhereUniqueInput
    update?: XOR<XOR<tugasUpdateToOneWithWhereWithoutPengumpulanInput, tugasUpdateWithoutPengumpulanInput>, tugasUncheckedUpdateWithoutPengumpulanInput>
  }

  export type userUpdateOneRequiredWithoutPengumpulanNestedInput = {
    create?: XOR<userCreateWithoutPengumpulanInput, userUncheckedCreateWithoutPengumpulanInput>
    connectOrCreate?: userCreateOrConnectWithoutPengumpulanInput
    upsert?: userUpsertWithoutPengumpulanInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPengumpulanInput, userUpdateWithoutPengumpulanInput>, userUncheckedUpdateWithoutPengumpulanInput>
  }

  export type praktikumCreateNestedOneWithoutPengumumanInput = {
    create?: XOR<praktikumCreateWithoutPengumumanInput, praktikumUncheckedCreateWithoutPengumumanInput>
    connectOrCreate?: praktikumCreateOrConnectWithoutPengumumanInput
    connect?: praktikumWhereUniqueInput
  }

  export type userCreateNestedOneWithoutPengumumanInput = {
    create?: XOR<userCreateWithoutPengumumanInput, userUncheckedCreateWithoutPengumumanInput>
    connectOrCreate?: userCreateOrConnectWithoutPengumumanInput
    connect?: userWhereUniqueInput
  }

  export type praktikumUpdateOneRequiredWithoutPengumumanNestedInput = {
    create?: XOR<praktikumCreateWithoutPengumumanInput, praktikumUncheckedCreateWithoutPengumumanInput>
    connectOrCreate?: praktikumCreateOrConnectWithoutPengumumanInput
    upsert?: praktikumUpsertWithoutPengumumanInput
    connect?: praktikumWhereUniqueInput
    update?: XOR<XOR<praktikumUpdateToOneWithWhereWithoutPengumumanInput, praktikumUpdateWithoutPengumumanInput>, praktikumUncheckedUpdateWithoutPengumumanInput>
  }

  export type userUpdateOneRequiredWithoutPengumumanNestedInput = {
    create?: XOR<userCreateWithoutPengumumanInput, userUncheckedCreateWithoutPengumumanInput>
    connectOrCreate?: userCreateOrConnectWithoutPengumumanInput
    upsert?: userUpsertWithoutPengumumanInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPengumumanInput, userUpdateWithoutPengumumanInput>, userUncheckedUpdateWithoutPengumumanInput>
  }

  export type userCreateNestedOneWithoutAbsensiInput = {
    create?: XOR<userCreateWithoutAbsensiInput, userUncheckedCreateWithoutAbsensiInput>
    connectOrCreate?: userCreateOrConnectWithoutAbsensiInput
    connect?: userWhereUniqueInput
  }

  export type jadwalCreateNestedOneWithoutAbsensiInput = {
    create?: XOR<jadwalCreateWithoutAbsensiInput, jadwalUncheckedCreateWithoutAbsensiInput>
    connectOrCreate?: jadwalCreateOrConnectWithoutAbsensiInput
    connect?: jadwalWhereUniqueInput
  }

  export type EnumStatusAbsensiFieldUpdateOperationsInput = {
    set?: $Enums.StatusAbsensi
  }

  export type userUpdateOneRequiredWithoutAbsensiNestedInput = {
    create?: XOR<userCreateWithoutAbsensiInput, userUncheckedCreateWithoutAbsensiInput>
    connectOrCreate?: userCreateOrConnectWithoutAbsensiInput
    upsert?: userUpsertWithoutAbsensiInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutAbsensiInput, userUpdateWithoutAbsensiInput>, userUncheckedUpdateWithoutAbsensiInput>
  }

  export type jadwalUpdateOneRequiredWithoutAbsensiNestedInput = {
    create?: XOR<jadwalCreateWithoutAbsensiInput, jadwalUncheckedCreateWithoutAbsensiInput>
    connectOrCreate?: jadwalCreateOrConnectWithoutAbsensiInput
    upsert?: jadwalUpsertWithoutAbsensiInput
    connect?: jadwalWhereUniqueInput
    update?: XOR<XOR<jadwalUpdateToOneWithWhereWithoutAbsensiInput, jadwalUpdateWithoutAbsensiInput>, jadwalUncheckedUpdateWithoutAbsensiInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumPeranFilter<$PrismaModel = never> = {
    equals?: $Enums.Peran | EnumPeranFieldRefInput<$PrismaModel>
    in?: $Enums.Peran[]
    notIn?: $Enums.Peran[]
    not?: NestedEnumPeranFilter<$PrismaModel> | $Enums.Peran
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumPeranWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Peran | EnumPeranFieldRefInput<$PrismaModel>
    in?: $Enums.Peran[]
    notIn?: $Enums.Peran[]
    not?: NestedEnumPeranWithAggregatesFilter<$PrismaModel> | $Enums.Peran
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPeranFilter<$PrismaModel>
    _max?: NestedEnumPeranFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatusTugasFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusTugas | EnumStatusTugasFieldRefInput<$PrismaModel>
    in?: $Enums.StatusTugas[]
    notIn?: $Enums.StatusTugas[]
    not?: NestedEnumStatusTugasFilter<$PrismaModel> | $Enums.StatusTugas
  }

  export type NestedEnumStatusTugasWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusTugas | EnumStatusTugasFieldRefInput<$PrismaModel>
    in?: $Enums.StatusTugas[]
    notIn?: $Enums.StatusTugas[]
    not?: NestedEnumStatusTugasWithAggregatesFilter<$PrismaModel> | $Enums.StatusTugas
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusTugasFilter<$PrismaModel>
    _max?: NestedEnumStatusTugasFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatusAbsensiFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusAbsensi | EnumStatusAbsensiFieldRefInput<$PrismaModel>
    in?: $Enums.StatusAbsensi[]
    notIn?: $Enums.StatusAbsensi[]
    not?: NestedEnumStatusAbsensiFilter<$PrismaModel> | $Enums.StatusAbsensi
  }

  export type NestedEnumStatusAbsensiWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusAbsensi | EnumStatusAbsensiFieldRefInput<$PrismaModel>
    in?: $Enums.StatusAbsensi[]
    notIn?: $Enums.StatusAbsensi[]
    not?: NestedEnumStatusAbsensiWithAggregatesFilter<$PrismaModel> | $Enums.StatusAbsensi
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusAbsensiFilter<$PrismaModel>
    _max?: NestedEnumStatusAbsensiFilter<$PrismaModel>
  }

  export type pendaftaranCreateWithoutUserInput = {
    waktu_daftar?: Date | string | null
    praktikum: praktikumCreateNestedOneWithoutPendaftaranInput
  }

  export type pendaftaranUncheckedCreateWithoutUserInput = {
    id?: number
    praktikum_id: number
    waktu_daftar?: Date | string | null
  }

  export type pendaftaranCreateOrConnectWithoutUserInput = {
    where: pendaftaranWhereUniqueInput
    create: XOR<pendaftaranCreateWithoutUserInput, pendaftaranUncheckedCreateWithoutUserInput>
  }

  export type pendaftaranCreateManyUserInputEnvelope = {
    data: pendaftaranCreateManyUserInput | pendaftaranCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type jadwalCreateWithoutUserInput = {
    tanggal: Date | string
    jam: Date | string
    ruangan?: string | null
    nama_pengajar?: string | null
    dibuat_pada?: Date | string | null
    praktikum: praktikumCreateNestedOneWithoutJadwalInput
    absensi?: absensiCreateNestedManyWithoutJadwalInput
  }

  export type jadwalUncheckedCreateWithoutUserInput = {
    id?: number
    praktikum_id: number
    tanggal: Date | string
    jam: Date | string
    ruangan?: string | null
    nama_pengajar?: string | null
    dibuat_pada?: Date | string | null
    absensi?: absensiUncheckedCreateNestedManyWithoutJadwalInput
  }

  export type jadwalCreateOrConnectWithoutUserInput = {
    where: jadwalWhereUniqueInput
    create: XOR<jadwalCreateWithoutUserInput, jadwalUncheckedCreateWithoutUserInput>
  }

  export type jadwalCreateManyUserInputEnvelope = {
    data: jadwalCreateManyUserInput | jadwalCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type modulCreateWithoutUserInput = {
    judul: string
    file_path: string
    diunggah_pada?: Date | string | null
    praktikum: praktikumCreateNestedOneWithoutModulInput
  }

  export type modulUncheckedCreateWithoutUserInput = {
    id?: number
    praktikum_id: number
    judul: string
    file_path: string
    diunggah_pada?: Date | string | null
  }

  export type modulCreateOrConnectWithoutUserInput = {
    where: modulWhereUniqueInput
    create: XOR<modulCreateWithoutUserInput, modulUncheckedCreateWithoutUserInput>
  }

  export type modulCreateManyUserInputEnvelope = {
    data: modulCreateManyUserInput | modulCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type pengumpulanCreateWithoutUserInput = {
    file_path?: string | null
    waktu_kirim?: Date | string | null
    nilai?: number | null
    catatan?: string | null
    tugas: tugasCreateNestedOneWithoutPengumpulanInput
  }

  export type pengumpulanUncheckedCreateWithoutUserInput = {
    id?: number
    tugas_id: number
    file_path?: string | null
    waktu_kirim?: Date | string | null
    nilai?: number | null
    catatan?: string | null
  }

  export type pengumpulanCreateOrConnectWithoutUserInput = {
    where: pengumpulanWhereUniqueInput
    create: XOR<pengumpulanCreateWithoutUserInput, pengumpulanUncheckedCreateWithoutUserInput>
  }

  export type pengumpulanCreateManyUserInputEnvelope = {
    data: pengumpulanCreateManyUserInput | pengumpulanCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type pengumumanCreateWithoutPembuatInput = {
    isi: string
    dibuat_pada?: Date | string | null
    praktikum: praktikumCreateNestedOneWithoutPengumumanInput
  }

  export type pengumumanUncheckedCreateWithoutPembuatInput = {
    id?: number
    praktikum_id: number
    isi: string
    dibuat_pada?: Date | string | null
  }

  export type pengumumanCreateOrConnectWithoutPembuatInput = {
    where: pengumumanWhereUniqueInput
    create: XOR<pengumumanCreateWithoutPembuatInput, pengumumanUncheckedCreateWithoutPembuatInput>
  }

  export type pengumumanCreateManyPembuatInputEnvelope = {
    data: pengumumanCreateManyPembuatInput | pengumumanCreateManyPembuatInput[]
    skipDuplicates?: boolean
  }

  export type absensiCreateWithoutUserInput = {
    status: $Enums.StatusAbsensi
    jadwal: jadwalCreateNestedOneWithoutAbsensiInput
  }

  export type absensiUncheckedCreateWithoutUserInput = {
    id?: number
    jadwal_id: number
    status: $Enums.StatusAbsensi
  }

  export type absensiCreateOrConnectWithoutUserInput = {
    where: absensiWhereUniqueInput
    create: XOR<absensiCreateWithoutUserInput, absensiUncheckedCreateWithoutUserInput>
  }

  export type absensiCreateManyUserInputEnvelope = {
    data: absensiCreateManyUserInput | absensiCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type pendaftaranUpsertWithWhereUniqueWithoutUserInput = {
    where: pendaftaranWhereUniqueInput
    update: XOR<pendaftaranUpdateWithoutUserInput, pendaftaranUncheckedUpdateWithoutUserInput>
    create: XOR<pendaftaranCreateWithoutUserInput, pendaftaranUncheckedCreateWithoutUserInput>
  }

  export type pendaftaranUpdateWithWhereUniqueWithoutUserInput = {
    where: pendaftaranWhereUniqueInput
    data: XOR<pendaftaranUpdateWithoutUserInput, pendaftaranUncheckedUpdateWithoutUserInput>
  }

  export type pendaftaranUpdateManyWithWhereWithoutUserInput = {
    where: pendaftaranScalarWhereInput
    data: XOR<pendaftaranUpdateManyMutationInput, pendaftaranUncheckedUpdateManyWithoutUserInput>
  }

  export type pendaftaranScalarWhereInput = {
    AND?: pendaftaranScalarWhereInput | pendaftaranScalarWhereInput[]
    OR?: pendaftaranScalarWhereInput[]
    NOT?: pendaftaranScalarWhereInput | pendaftaranScalarWhereInput[]
    id?: IntFilter<"pendaftaran"> | number
    user_id?: StringFilter<"pendaftaran"> | string
    praktikum_id?: IntFilter<"pendaftaran"> | number
    waktu_daftar?: DateTimeNullableFilter<"pendaftaran"> | Date | string | null
  }

  export type jadwalUpsertWithWhereUniqueWithoutUserInput = {
    where: jadwalWhereUniqueInput
    update: XOR<jadwalUpdateWithoutUserInput, jadwalUncheckedUpdateWithoutUserInput>
    create: XOR<jadwalCreateWithoutUserInput, jadwalUncheckedCreateWithoutUserInput>
  }

  export type jadwalUpdateWithWhereUniqueWithoutUserInput = {
    where: jadwalWhereUniqueInput
    data: XOR<jadwalUpdateWithoutUserInput, jadwalUncheckedUpdateWithoutUserInput>
  }

  export type jadwalUpdateManyWithWhereWithoutUserInput = {
    where: jadwalScalarWhereInput
    data: XOR<jadwalUpdateManyMutationInput, jadwalUncheckedUpdateManyWithoutUserInput>
  }

  export type jadwalScalarWhereInput = {
    AND?: jadwalScalarWhereInput | jadwalScalarWhereInput[]
    OR?: jadwalScalarWhereInput[]
    NOT?: jadwalScalarWhereInput | jadwalScalarWhereInput[]
    id?: IntFilter<"jadwal"> | number
    praktikum_id?: IntFilter<"jadwal"> | number
    tanggal?: DateTimeFilter<"jadwal"> | Date | string
    jam?: DateTimeFilter<"jadwal"> | Date | string
    ruangan?: StringNullableFilter<"jadwal"> | string | null
    user_id?: StringFilter<"jadwal"> | string
    nama_pengajar?: StringNullableFilter<"jadwal"> | string | null
    dibuat_pada?: DateTimeNullableFilter<"jadwal"> | Date | string | null
  }

  export type modulUpsertWithWhereUniqueWithoutUserInput = {
    where: modulWhereUniqueInput
    update: XOR<modulUpdateWithoutUserInput, modulUncheckedUpdateWithoutUserInput>
    create: XOR<modulCreateWithoutUserInput, modulUncheckedCreateWithoutUserInput>
  }

  export type modulUpdateWithWhereUniqueWithoutUserInput = {
    where: modulWhereUniqueInput
    data: XOR<modulUpdateWithoutUserInput, modulUncheckedUpdateWithoutUserInput>
  }

  export type modulUpdateManyWithWhereWithoutUserInput = {
    where: modulScalarWhereInput
    data: XOR<modulUpdateManyMutationInput, modulUncheckedUpdateManyWithoutUserInput>
  }

  export type modulScalarWhereInput = {
    AND?: modulScalarWhereInput | modulScalarWhereInput[]
    OR?: modulScalarWhereInput[]
    NOT?: modulScalarWhereInput | modulScalarWhereInput[]
    id?: IntFilter<"modul"> | number
    praktikum_id?: IntFilter<"modul"> | number
    judul?: StringFilter<"modul"> | string
    file_path?: StringFilter<"modul"> | string
    diunggah_oleh?: StringFilter<"modul"> | string
    diunggah_pada?: DateTimeNullableFilter<"modul"> | Date | string | null
  }

  export type pengumpulanUpsertWithWhereUniqueWithoutUserInput = {
    where: pengumpulanWhereUniqueInput
    update: XOR<pengumpulanUpdateWithoutUserInput, pengumpulanUncheckedUpdateWithoutUserInput>
    create: XOR<pengumpulanCreateWithoutUserInput, pengumpulanUncheckedCreateWithoutUserInput>
  }

  export type pengumpulanUpdateWithWhereUniqueWithoutUserInput = {
    where: pengumpulanWhereUniqueInput
    data: XOR<pengumpulanUpdateWithoutUserInput, pengumpulanUncheckedUpdateWithoutUserInput>
  }

  export type pengumpulanUpdateManyWithWhereWithoutUserInput = {
    where: pengumpulanScalarWhereInput
    data: XOR<pengumpulanUpdateManyMutationInput, pengumpulanUncheckedUpdateManyWithoutUserInput>
  }

  export type pengumpulanScalarWhereInput = {
    AND?: pengumpulanScalarWhereInput | pengumpulanScalarWhereInput[]
    OR?: pengumpulanScalarWhereInput[]
    NOT?: pengumpulanScalarWhereInput | pengumpulanScalarWhereInput[]
    id?: IntFilter<"pengumpulan"> | number
    tugas_id?: IntFilter<"pengumpulan"> | number
    user_id?: StringFilter<"pengumpulan"> | string
    file_path?: StringNullableFilter<"pengumpulan"> | string | null
    waktu_kirim?: DateTimeNullableFilter<"pengumpulan"> | Date | string | null
    nilai?: FloatNullableFilter<"pengumpulan"> | number | null
    catatan?: StringNullableFilter<"pengumpulan"> | string | null
  }

  export type pengumumanUpsertWithWhereUniqueWithoutPembuatInput = {
    where: pengumumanWhereUniqueInput
    update: XOR<pengumumanUpdateWithoutPembuatInput, pengumumanUncheckedUpdateWithoutPembuatInput>
    create: XOR<pengumumanCreateWithoutPembuatInput, pengumumanUncheckedCreateWithoutPembuatInput>
  }

  export type pengumumanUpdateWithWhereUniqueWithoutPembuatInput = {
    where: pengumumanWhereUniqueInput
    data: XOR<pengumumanUpdateWithoutPembuatInput, pengumumanUncheckedUpdateWithoutPembuatInput>
  }

  export type pengumumanUpdateManyWithWhereWithoutPembuatInput = {
    where: pengumumanScalarWhereInput
    data: XOR<pengumumanUpdateManyMutationInput, pengumumanUncheckedUpdateManyWithoutPembuatInput>
  }

  export type pengumumanScalarWhereInput = {
    AND?: pengumumanScalarWhereInput | pengumumanScalarWhereInput[]
    OR?: pengumumanScalarWhereInput[]
    NOT?: pengumumanScalarWhereInput | pengumumanScalarWhereInput[]
    id?: IntFilter<"pengumuman"> | number
    praktikum_id?: IntFilter<"pengumuman"> | number
    isi?: StringFilter<"pengumuman"> | string
    dibuat_oleh?: StringFilter<"pengumuman"> | string
    dibuat_pada?: DateTimeNullableFilter<"pengumuman"> | Date | string | null
  }

  export type absensiUpsertWithWhereUniqueWithoutUserInput = {
    where: absensiWhereUniqueInput
    update: XOR<absensiUpdateWithoutUserInput, absensiUncheckedUpdateWithoutUserInput>
    create: XOR<absensiCreateWithoutUserInput, absensiUncheckedCreateWithoutUserInput>
  }

  export type absensiUpdateWithWhereUniqueWithoutUserInput = {
    where: absensiWhereUniqueInput
    data: XOR<absensiUpdateWithoutUserInput, absensiUncheckedUpdateWithoutUserInput>
  }

  export type absensiUpdateManyWithWhereWithoutUserInput = {
    where: absensiScalarWhereInput
    data: XOR<absensiUpdateManyMutationInput, absensiUncheckedUpdateManyWithoutUserInput>
  }

  export type absensiScalarWhereInput = {
    AND?: absensiScalarWhereInput | absensiScalarWhereInput[]
    OR?: absensiScalarWhereInput[]
    NOT?: absensiScalarWhereInput | absensiScalarWhereInput[]
    id?: IntFilter<"absensi"> | number
    user_id?: StringFilter<"absensi"> | string
    jadwal_id?: IntFilter<"absensi"> | number
    status?: EnumStatusAbsensiFilter<"absensi"> | $Enums.StatusAbsensi
  }

  export type praktikumCreateWithoutLabInput = {
    nama_praktikum: string
    dibuat_pada?: Date | string
    pendaftaran?: pendaftaranCreateNestedManyWithoutPraktikumInput
    jadwal?: jadwalCreateNestedManyWithoutPraktikumInput
    modul?: modulCreateNestedManyWithoutPraktikumInput
    tugas?: tugasCreateNestedManyWithoutPraktikumInput
    pengumuman?: pengumumanCreateNestedManyWithoutPraktikumInput
  }

  export type praktikumUncheckedCreateWithoutLabInput = {
    id?: number
    nama_praktikum: string
    dibuat_pada?: Date | string
    pendaftaran?: pendaftaranUncheckedCreateNestedManyWithoutPraktikumInput
    jadwal?: jadwalUncheckedCreateNestedManyWithoutPraktikumInput
    modul?: modulUncheckedCreateNestedManyWithoutPraktikumInput
    tugas?: tugasUncheckedCreateNestedManyWithoutPraktikumInput
    pengumuman?: pengumumanUncheckedCreateNestedManyWithoutPraktikumInput
  }

  export type praktikumCreateOrConnectWithoutLabInput = {
    where: praktikumWhereUniqueInput
    create: XOR<praktikumCreateWithoutLabInput, praktikumUncheckedCreateWithoutLabInput>
  }

  export type praktikumCreateManyLabInputEnvelope = {
    data: praktikumCreateManyLabInput | praktikumCreateManyLabInput[]
    skipDuplicates?: boolean
  }

  export type praktikumUpsertWithWhereUniqueWithoutLabInput = {
    where: praktikumWhereUniqueInput
    update: XOR<praktikumUpdateWithoutLabInput, praktikumUncheckedUpdateWithoutLabInput>
    create: XOR<praktikumCreateWithoutLabInput, praktikumUncheckedCreateWithoutLabInput>
  }

  export type praktikumUpdateWithWhereUniqueWithoutLabInput = {
    where: praktikumWhereUniqueInput
    data: XOR<praktikumUpdateWithoutLabInput, praktikumUncheckedUpdateWithoutLabInput>
  }

  export type praktikumUpdateManyWithWhereWithoutLabInput = {
    where: praktikumScalarWhereInput
    data: XOR<praktikumUpdateManyMutationInput, praktikumUncheckedUpdateManyWithoutLabInput>
  }

  export type praktikumScalarWhereInput = {
    AND?: praktikumScalarWhereInput | praktikumScalarWhereInput[]
    OR?: praktikumScalarWhereInput[]
    NOT?: praktikumScalarWhereInput | praktikumScalarWhereInput[]
    id?: IntFilter<"praktikum"> | number
    nama_praktikum?: StringFilter<"praktikum"> | string
    lab_id?: IntFilter<"praktikum"> | number
    dibuat_pada?: DateTimeFilter<"praktikum"> | Date | string
  }

  export type labCreateWithoutPraktikumInput = {
    nama_lab: string
  }

  export type labUncheckedCreateWithoutPraktikumInput = {
    id?: number
    nama_lab: string
  }

  export type labCreateOrConnectWithoutPraktikumInput = {
    where: labWhereUniqueInput
    create: XOR<labCreateWithoutPraktikumInput, labUncheckedCreateWithoutPraktikumInput>
  }

  export type pendaftaranCreateWithoutPraktikumInput = {
    waktu_daftar?: Date | string | null
    user: userCreateNestedOneWithoutPendaftaranInput
  }

  export type pendaftaranUncheckedCreateWithoutPraktikumInput = {
    id?: number
    user_id: string
    waktu_daftar?: Date | string | null
  }

  export type pendaftaranCreateOrConnectWithoutPraktikumInput = {
    where: pendaftaranWhereUniqueInput
    create: XOR<pendaftaranCreateWithoutPraktikumInput, pendaftaranUncheckedCreateWithoutPraktikumInput>
  }

  export type pendaftaranCreateManyPraktikumInputEnvelope = {
    data: pendaftaranCreateManyPraktikumInput | pendaftaranCreateManyPraktikumInput[]
    skipDuplicates?: boolean
  }

  export type jadwalCreateWithoutPraktikumInput = {
    tanggal: Date | string
    jam: Date | string
    ruangan?: string | null
    nama_pengajar?: string | null
    dibuat_pada?: Date | string | null
    user: userCreateNestedOneWithoutJadwalInput
    absensi?: absensiCreateNestedManyWithoutJadwalInput
  }

  export type jadwalUncheckedCreateWithoutPraktikumInput = {
    id?: number
    tanggal: Date | string
    jam: Date | string
    ruangan?: string | null
    user_id: string
    nama_pengajar?: string | null
    dibuat_pada?: Date | string | null
    absensi?: absensiUncheckedCreateNestedManyWithoutJadwalInput
  }

  export type jadwalCreateOrConnectWithoutPraktikumInput = {
    where: jadwalWhereUniqueInput
    create: XOR<jadwalCreateWithoutPraktikumInput, jadwalUncheckedCreateWithoutPraktikumInput>
  }

  export type jadwalCreateManyPraktikumInputEnvelope = {
    data: jadwalCreateManyPraktikumInput | jadwalCreateManyPraktikumInput[]
    skipDuplicates?: boolean
  }

  export type modulCreateWithoutPraktikumInput = {
    judul: string
    file_path: string
    diunggah_pada?: Date | string | null
    user: userCreateNestedOneWithoutModulInput
  }

  export type modulUncheckedCreateWithoutPraktikumInput = {
    id?: number
    judul: string
    file_path: string
    diunggah_oleh: string
    diunggah_pada?: Date | string | null
  }

  export type modulCreateOrConnectWithoutPraktikumInput = {
    where: modulWhereUniqueInput
    create: XOR<modulCreateWithoutPraktikumInput, modulUncheckedCreateWithoutPraktikumInput>
  }

  export type modulCreateManyPraktikumInputEnvelope = {
    data: modulCreateManyPraktikumInput | modulCreateManyPraktikumInput[]
    skipDuplicates?: boolean
  }

  export type tugasCreateWithoutPraktikumInput = {
    judul: string
    deskripsi?: string | null
    fileTugas?: string | null
    batas_waktu: Date | string
    dibuat_pada?: Date | string
    status?: $Enums.StatusTugas
    pengumpulan?: pengumpulanCreateNestedManyWithoutTugasInput
  }

  export type tugasUncheckedCreateWithoutPraktikumInput = {
    id?: number
    judul: string
    deskripsi?: string | null
    fileTugas?: string | null
    batas_waktu: Date | string
    dibuat_pada?: Date | string
    status?: $Enums.StatusTugas
    pengumpulan?: pengumpulanUncheckedCreateNestedManyWithoutTugasInput
  }

  export type tugasCreateOrConnectWithoutPraktikumInput = {
    where: tugasWhereUniqueInput
    create: XOR<tugasCreateWithoutPraktikumInput, tugasUncheckedCreateWithoutPraktikumInput>
  }

  export type tugasCreateManyPraktikumInputEnvelope = {
    data: tugasCreateManyPraktikumInput | tugasCreateManyPraktikumInput[]
    skipDuplicates?: boolean
  }

  export type pengumumanCreateWithoutPraktikumInput = {
    isi: string
    dibuat_pada?: Date | string | null
    pembuat: userCreateNestedOneWithoutPengumumanInput
  }

  export type pengumumanUncheckedCreateWithoutPraktikumInput = {
    id?: number
    isi: string
    dibuat_oleh: string
    dibuat_pada?: Date | string | null
  }

  export type pengumumanCreateOrConnectWithoutPraktikumInput = {
    where: pengumumanWhereUniqueInput
    create: XOR<pengumumanCreateWithoutPraktikumInput, pengumumanUncheckedCreateWithoutPraktikumInput>
  }

  export type pengumumanCreateManyPraktikumInputEnvelope = {
    data: pengumumanCreateManyPraktikumInput | pengumumanCreateManyPraktikumInput[]
    skipDuplicates?: boolean
  }

  export type labUpsertWithoutPraktikumInput = {
    update: XOR<labUpdateWithoutPraktikumInput, labUncheckedUpdateWithoutPraktikumInput>
    create: XOR<labCreateWithoutPraktikumInput, labUncheckedCreateWithoutPraktikumInput>
    where?: labWhereInput
  }

  export type labUpdateToOneWithWhereWithoutPraktikumInput = {
    where?: labWhereInput
    data: XOR<labUpdateWithoutPraktikumInput, labUncheckedUpdateWithoutPraktikumInput>
  }

  export type labUpdateWithoutPraktikumInput = {
    nama_lab?: StringFieldUpdateOperationsInput | string
  }

  export type labUncheckedUpdateWithoutPraktikumInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_lab?: StringFieldUpdateOperationsInput | string
  }

  export type pendaftaranUpsertWithWhereUniqueWithoutPraktikumInput = {
    where: pendaftaranWhereUniqueInput
    update: XOR<pendaftaranUpdateWithoutPraktikumInput, pendaftaranUncheckedUpdateWithoutPraktikumInput>
    create: XOR<pendaftaranCreateWithoutPraktikumInput, pendaftaranUncheckedCreateWithoutPraktikumInput>
  }

  export type pendaftaranUpdateWithWhereUniqueWithoutPraktikumInput = {
    where: pendaftaranWhereUniqueInput
    data: XOR<pendaftaranUpdateWithoutPraktikumInput, pendaftaranUncheckedUpdateWithoutPraktikumInput>
  }

  export type pendaftaranUpdateManyWithWhereWithoutPraktikumInput = {
    where: pendaftaranScalarWhereInput
    data: XOR<pendaftaranUpdateManyMutationInput, pendaftaranUncheckedUpdateManyWithoutPraktikumInput>
  }

  export type jadwalUpsertWithWhereUniqueWithoutPraktikumInput = {
    where: jadwalWhereUniqueInput
    update: XOR<jadwalUpdateWithoutPraktikumInput, jadwalUncheckedUpdateWithoutPraktikumInput>
    create: XOR<jadwalCreateWithoutPraktikumInput, jadwalUncheckedCreateWithoutPraktikumInput>
  }

  export type jadwalUpdateWithWhereUniqueWithoutPraktikumInput = {
    where: jadwalWhereUniqueInput
    data: XOR<jadwalUpdateWithoutPraktikumInput, jadwalUncheckedUpdateWithoutPraktikumInput>
  }

  export type jadwalUpdateManyWithWhereWithoutPraktikumInput = {
    where: jadwalScalarWhereInput
    data: XOR<jadwalUpdateManyMutationInput, jadwalUncheckedUpdateManyWithoutPraktikumInput>
  }

  export type modulUpsertWithWhereUniqueWithoutPraktikumInput = {
    where: modulWhereUniqueInput
    update: XOR<modulUpdateWithoutPraktikumInput, modulUncheckedUpdateWithoutPraktikumInput>
    create: XOR<modulCreateWithoutPraktikumInput, modulUncheckedCreateWithoutPraktikumInput>
  }

  export type modulUpdateWithWhereUniqueWithoutPraktikumInput = {
    where: modulWhereUniqueInput
    data: XOR<modulUpdateWithoutPraktikumInput, modulUncheckedUpdateWithoutPraktikumInput>
  }

  export type modulUpdateManyWithWhereWithoutPraktikumInput = {
    where: modulScalarWhereInput
    data: XOR<modulUpdateManyMutationInput, modulUncheckedUpdateManyWithoutPraktikumInput>
  }

  export type tugasUpsertWithWhereUniqueWithoutPraktikumInput = {
    where: tugasWhereUniqueInput
    update: XOR<tugasUpdateWithoutPraktikumInput, tugasUncheckedUpdateWithoutPraktikumInput>
    create: XOR<tugasCreateWithoutPraktikumInput, tugasUncheckedCreateWithoutPraktikumInput>
  }

  export type tugasUpdateWithWhereUniqueWithoutPraktikumInput = {
    where: tugasWhereUniqueInput
    data: XOR<tugasUpdateWithoutPraktikumInput, tugasUncheckedUpdateWithoutPraktikumInput>
  }

  export type tugasUpdateManyWithWhereWithoutPraktikumInput = {
    where: tugasScalarWhereInput
    data: XOR<tugasUpdateManyMutationInput, tugasUncheckedUpdateManyWithoutPraktikumInput>
  }

  export type tugasScalarWhereInput = {
    AND?: tugasScalarWhereInput | tugasScalarWhereInput[]
    OR?: tugasScalarWhereInput[]
    NOT?: tugasScalarWhereInput | tugasScalarWhereInput[]
    id?: IntFilter<"tugas"> | number
    praktikum_id?: IntFilter<"tugas"> | number
    judul?: StringFilter<"tugas"> | string
    deskripsi?: StringNullableFilter<"tugas"> | string | null
    fileTugas?: StringNullableFilter<"tugas"> | string | null
    batas_waktu?: DateTimeFilter<"tugas"> | Date | string
    dibuat_pada?: DateTimeFilter<"tugas"> | Date | string
    status?: EnumStatusTugasFilter<"tugas"> | $Enums.StatusTugas
  }

  export type pengumumanUpsertWithWhereUniqueWithoutPraktikumInput = {
    where: pengumumanWhereUniqueInput
    update: XOR<pengumumanUpdateWithoutPraktikumInput, pengumumanUncheckedUpdateWithoutPraktikumInput>
    create: XOR<pengumumanCreateWithoutPraktikumInput, pengumumanUncheckedCreateWithoutPraktikumInput>
  }

  export type pengumumanUpdateWithWhereUniqueWithoutPraktikumInput = {
    where: pengumumanWhereUniqueInput
    data: XOR<pengumumanUpdateWithoutPraktikumInput, pengumumanUncheckedUpdateWithoutPraktikumInput>
  }

  export type pengumumanUpdateManyWithWhereWithoutPraktikumInput = {
    where: pengumumanScalarWhereInput
    data: XOR<pengumumanUpdateManyMutationInput, pengumumanUncheckedUpdateManyWithoutPraktikumInput>
  }

  export type userCreateWithoutPendaftaranInput = {
    id: string
    username: string
    kata_sandi: string
    peran: $Enums.Peran
    dibuat_pada?: Date | string
    jadwal?: jadwalCreateNestedManyWithoutUserInput
    modul?: modulCreateNestedManyWithoutUserInput
    pengumpulan?: pengumpulanCreateNestedManyWithoutUserInput
    pengumuman?: pengumumanCreateNestedManyWithoutPembuatInput
    absensi?: absensiCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutPendaftaranInput = {
    id: string
    username: string
    kata_sandi: string
    peran: $Enums.Peran
    dibuat_pada?: Date | string
    jadwal?: jadwalUncheckedCreateNestedManyWithoutUserInput
    modul?: modulUncheckedCreateNestedManyWithoutUserInput
    pengumpulan?: pengumpulanUncheckedCreateNestedManyWithoutUserInput
    pengumuman?: pengumumanUncheckedCreateNestedManyWithoutPembuatInput
    absensi?: absensiUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPendaftaranInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPendaftaranInput, userUncheckedCreateWithoutPendaftaranInput>
  }

  export type praktikumCreateWithoutPendaftaranInput = {
    nama_praktikum: string
    dibuat_pada?: Date | string
    lab: labCreateNestedOneWithoutPraktikumInput
    jadwal?: jadwalCreateNestedManyWithoutPraktikumInput
    modul?: modulCreateNestedManyWithoutPraktikumInput
    tugas?: tugasCreateNestedManyWithoutPraktikumInput
    pengumuman?: pengumumanCreateNestedManyWithoutPraktikumInput
  }

  export type praktikumUncheckedCreateWithoutPendaftaranInput = {
    id?: number
    nama_praktikum: string
    lab_id: number
    dibuat_pada?: Date | string
    jadwal?: jadwalUncheckedCreateNestedManyWithoutPraktikumInput
    modul?: modulUncheckedCreateNestedManyWithoutPraktikumInput
    tugas?: tugasUncheckedCreateNestedManyWithoutPraktikumInput
    pengumuman?: pengumumanUncheckedCreateNestedManyWithoutPraktikumInput
  }

  export type praktikumCreateOrConnectWithoutPendaftaranInput = {
    where: praktikumWhereUniqueInput
    create: XOR<praktikumCreateWithoutPendaftaranInput, praktikumUncheckedCreateWithoutPendaftaranInput>
  }

  export type userUpsertWithoutPendaftaranInput = {
    update: XOR<userUpdateWithoutPendaftaranInput, userUncheckedUpdateWithoutPendaftaranInput>
    create: XOR<userCreateWithoutPendaftaranInput, userUncheckedCreateWithoutPendaftaranInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPendaftaranInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPendaftaranInput, userUncheckedUpdateWithoutPendaftaranInput>
  }

  export type userUpdateWithoutPendaftaranInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    kata_sandi?: StringFieldUpdateOperationsInput | string
    peran?: EnumPeranFieldUpdateOperationsInput | $Enums.Peran
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    jadwal?: jadwalUpdateManyWithoutUserNestedInput
    modul?: modulUpdateManyWithoutUserNestedInput
    pengumpulan?: pengumpulanUpdateManyWithoutUserNestedInput
    pengumuman?: pengumumanUpdateManyWithoutPembuatNestedInput
    absensi?: absensiUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPendaftaranInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    kata_sandi?: StringFieldUpdateOperationsInput | string
    peran?: EnumPeranFieldUpdateOperationsInput | $Enums.Peran
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    jadwal?: jadwalUncheckedUpdateManyWithoutUserNestedInput
    modul?: modulUncheckedUpdateManyWithoutUserNestedInput
    pengumpulan?: pengumpulanUncheckedUpdateManyWithoutUserNestedInput
    pengumuman?: pengumumanUncheckedUpdateManyWithoutPembuatNestedInput
    absensi?: absensiUncheckedUpdateManyWithoutUserNestedInput
  }

  export type praktikumUpsertWithoutPendaftaranInput = {
    update: XOR<praktikumUpdateWithoutPendaftaranInput, praktikumUncheckedUpdateWithoutPendaftaranInput>
    create: XOR<praktikumCreateWithoutPendaftaranInput, praktikumUncheckedCreateWithoutPendaftaranInput>
    where?: praktikumWhereInput
  }

  export type praktikumUpdateToOneWithWhereWithoutPendaftaranInput = {
    where?: praktikumWhereInput
    data: XOR<praktikumUpdateWithoutPendaftaranInput, praktikumUncheckedUpdateWithoutPendaftaranInput>
  }

  export type praktikumUpdateWithoutPendaftaranInput = {
    nama_praktikum?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    lab?: labUpdateOneRequiredWithoutPraktikumNestedInput
    jadwal?: jadwalUpdateManyWithoutPraktikumNestedInput
    modul?: modulUpdateManyWithoutPraktikumNestedInput
    tugas?: tugasUpdateManyWithoutPraktikumNestedInput
    pengumuman?: pengumumanUpdateManyWithoutPraktikumNestedInput
  }

  export type praktikumUncheckedUpdateWithoutPendaftaranInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_praktikum?: StringFieldUpdateOperationsInput | string
    lab_id?: IntFieldUpdateOperationsInput | number
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    jadwal?: jadwalUncheckedUpdateManyWithoutPraktikumNestedInput
    modul?: modulUncheckedUpdateManyWithoutPraktikumNestedInput
    tugas?: tugasUncheckedUpdateManyWithoutPraktikumNestedInput
    pengumuman?: pengumumanUncheckedUpdateManyWithoutPraktikumNestedInput
  }

  export type praktikumCreateWithoutJadwalInput = {
    nama_praktikum: string
    dibuat_pada?: Date | string
    lab: labCreateNestedOneWithoutPraktikumInput
    pendaftaran?: pendaftaranCreateNestedManyWithoutPraktikumInput
    modul?: modulCreateNestedManyWithoutPraktikumInput
    tugas?: tugasCreateNestedManyWithoutPraktikumInput
    pengumuman?: pengumumanCreateNestedManyWithoutPraktikumInput
  }

  export type praktikumUncheckedCreateWithoutJadwalInput = {
    id?: number
    nama_praktikum: string
    lab_id: number
    dibuat_pada?: Date | string
    pendaftaran?: pendaftaranUncheckedCreateNestedManyWithoutPraktikumInput
    modul?: modulUncheckedCreateNestedManyWithoutPraktikumInput
    tugas?: tugasUncheckedCreateNestedManyWithoutPraktikumInput
    pengumuman?: pengumumanUncheckedCreateNestedManyWithoutPraktikumInput
  }

  export type praktikumCreateOrConnectWithoutJadwalInput = {
    where: praktikumWhereUniqueInput
    create: XOR<praktikumCreateWithoutJadwalInput, praktikumUncheckedCreateWithoutJadwalInput>
  }

  export type userCreateWithoutJadwalInput = {
    id: string
    username: string
    kata_sandi: string
    peran: $Enums.Peran
    dibuat_pada?: Date | string
    pendaftaran?: pendaftaranCreateNestedManyWithoutUserInput
    modul?: modulCreateNestedManyWithoutUserInput
    pengumpulan?: pengumpulanCreateNestedManyWithoutUserInput
    pengumuman?: pengumumanCreateNestedManyWithoutPembuatInput
    absensi?: absensiCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutJadwalInput = {
    id: string
    username: string
    kata_sandi: string
    peran: $Enums.Peran
    dibuat_pada?: Date | string
    pendaftaran?: pendaftaranUncheckedCreateNestedManyWithoutUserInput
    modul?: modulUncheckedCreateNestedManyWithoutUserInput
    pengumpulan?: pengumpulanUncheckedCreateNestedManyWithoutUserInput
    pengumuman?: pengumumanUncheckedCreateNestedManyWithoutPembuatInput
    absensi?: absensiUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutJadwalInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutJadwalInput, userUncheckedCreateWithoutJadwalInput>
  }

  export type absensiCreateWithoutJadwalInput = {
    status: $Enums.StatusAbsensi
    user: userCreateNestedOneWithoutAbsensiInput
  }

  export type absensiUncheckedCreateWithoutJadwalInput = {
    id?: number
    user_id: string
    status: $Enums.StatusAbsensi
  }

  export type absensiCreateOrConnectWithoutJadwalInput = {
    where: absensiWhereUniqueInput
    create: XOR<absensiCreateWithoutJadwalInput, absensiUncheckedCreateWithoutJadwalInput>
  }

  export type absensiCreateManyJadwalInputEnvelope = {
    data: absensiCreateManyJadwalInput | absensiCreateManyJadwalInput[]
    skipDuplicates?: boolean
  }

  export type praktikumUpsertWithoutJadwalInput = {
    update: XOR<praktikumUpdateWithoutJadwalInput, praktikumUncheckedUpdateWithoutJadwalInput>
    create: XOR<praktikumCreateWithoutJadwalInput, praktikumUncheckedCreateWithoutJadwalInput>
    where?: praktikumWhereInput
  }

  export type praktikumUpdateToOneWithWhereWithoutJadwalInput = {
    where?: praktikumWhereInput
    data: XOR<praktikumUpdateWithoutJadwalInput, praktikumUncheckedUpdateWithoutJadwalInput>
  }

  export type praktikumUpdateWithoutJadwalInput = {
    nama_praktikum?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    lab?: labUpdateOneRequiredWithoutPraktikumNestedInput
    pendaftaran?: pendaftaranUpdateManyWithoutPraktikumNestedInput
    modul?: modulUpdateManyWithoutPraktikumNestedInput
    tugas?: tugasUpdateManyWithoutPraktikumNestedInput
    pengumuman?: pengumumanUpdateManyWithoutPraktikumNestedInput
  }

  export type praktikumUncheckedUpdateWithoutJadwalInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_praktikum?: StringFieldUpdateOperationsInput | string
    lab_id?: IntFieldUpdateOperationsInput | number
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    pendaftaran?: pendaftaranUncheckedUpdateManyWithoutPraktikumNestedInput
    modul?: modulUncheckedUpdateManyWithoutPraktikumNestedInput
    tugas?: tugasUncheckedUpdateManyWithoutPraktikumNestedInput
    pengumuman?: pengumumanUncheckedUpdateManyWithoutPraktikumNestedInput
  }

  export type userUpsertWithoutJadwalInput = {
    update: XOR<userUpdateWithoutJadwalInput, userUncheckedUpdateWithoutJadwalInput>
    create: XOR<userCreateWithoutJadwalInput, userUncheckedCreateWithoutJadwalInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutJadwalInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutJadwalInput, userUncheckedUpdateWithoutJadwalInput>
  }

  export type userUpdateWithoutJadwalInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    kata_sandi?: StringFieldUpdateOperationsInput | string
    peran?: EnumPeranFieldUpdateOperationsInput | $Enums.Peran
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    pendaftaran?: pendaftaranUpdateManyWithoutUserNestedInput
    modul?: modulUpdateManyWithoutUserNestedInput
    pengumpulan?: pengumpulanUpdateManyWithoutUserNestedInput
    pengumuman?: pengumumanUpdateManyWithoutPembuatNestedInput
    absensi?: absensiUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutJadwalInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    kata_sandi?: StringFieldUpdateOperationsInput | string
    peran?: EnumPeranFieldUpdateOperationsInput | $Enums.Peran
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    pendaftaran?: pendaftaranUncheckedUpdateManyWithoutUserNestedInput
    modul?: modulUncheckedUpdateManyWithoutUserNestedInput
    pengumpulan?: pengumpulanUncheckedUpdateManyWithoutUserNestedInput
    pengumuman?: pengumumanUncheckedUpdateManyWithoutPembuatNestedInput
    absensi?: absensiUncheckedUpdateManyWithoutUserNestedInput
  }

  export type absensiUpsertWithWhereUniqueWithoutJadwalInput = {
    where: absensiWhereUniqueInput
    update: XOR<absensiUpdateWithoutJadwalInput, absensiUncheckedUpdateWithoutJadwalInput>
    create: XOR<absensiCreateWithoutJadwalInput, absensiUncheckedCreateWithoutJadwalInput>
  }

  export type absensiUpdateWithWhereUniqueWithoutJadwalInput = {
    where: absensiWhereUniqueInput
    data: XOR<absensiUpdateWithoutJadwalInput, absensiUncheckedUpdateWithoutJadwalInput>
  }

  export type absensiUpdateManyWithWhereWithoutJadwalInput = {
    where: absensiScalarWhereInput
    data: XOR<absensiUpdateManyMutationInput, absensiUncheckedUpdateManyWithoutJadwalInput>
  }

  export type praktikumCreateWithoutModulInput = {
    nama_praktikum: string
    dibuat_pada?: Date | string
    lab: labCreateNestedOneWithoutPraktikumInput
    pendaftaran?: pendaftaranCreateNestedManyWithoutPraktikumInput
    jadwal?: jadwalCreateNestedManyWithoutPraktikumInput
    tugas?: tugasCreateNestedManyWithoutPraktikumInput
    pengumuman?: pengumumanCreateNestedManyWithoutPraktikumInput
  }

  export type praktikumUncheckedCreateWithoutModulInput = {
    id?: number
    nama_praktikum: string
    lab_id: number
    dibuat_pada?: Date | string
    pendaftaran?: pendaftaranUncheckedCreateNestedManyWithoutPraktikumInput
    jadwal?: jadwalUncheckedCreateNestedManyWithoutPraktikumInput
    tugas?: tugasUncheckedCreateNestedManyWithoutPraktikumInput
    pengumuman?: pengumumanUncheckedCreateNestedManyWithoutPraktikumInput
  }

  export type praktikumCreateOrConnectWithoutModulInput = {
    where: praktikumWhereUniqueInput
    create: XOR<praktikumCreateWithoutModulInput, praktikumUncheckedCreateWithoutModulInput>
  }

  export type userCreateWithoutModulInput = {
    id: string
    username: string
    kata_sandi: string
    peran: $Enums.Peran
    dibuat_pada?: Date | string
    pendaftaran?: pendaftaranCreateNestedManyWithoutUserInput
    jadwal?: jadwalCreateNestedManyWithoutUserInput
    pengumpulan?: pengumpulanCreateNestedManyWithoutUserInput
    pengumuman?: pengumumanCreateNestedManyWithoutPembuatInput
    absensi?: absensiCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutModulInput = {
    id: string
    username: string
    kata_sandi: string
    peran: $Enums.Peran
    dibuat_pada?: Date | string
    pendaftaran?: pendaftaranUncheckedCreateNestedManyWithoutUserInput
    jadwal?: jadwalUncheckedCreateNestedManyWithoutUserInput
    pengumpulan?: pengumpulanUncheckedCreateNestedManyWithoutUserInput
    pengumuman?: pengumumanUncheckedCreateNestedManyWithoutPembuatInput
    absensi?: absensiUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutModulInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutModulInput, userUncheckedCreateWithoutModulInput>
  }

  export type praktikumUpsertWithoutModulInput = {
    update: XOR<praktikumUpdateWithoutModulInput, praktikumUncheckedUpdateWithoutModulInput>
    create: XOR<praktikumCreateWithoutModulInput, praktikumUncheckedCreateWithoutModulInput>
    where?: praktikumWhereInput
  }

  export type praktikumUpdateToOneWithWhereWithoutModulInput = {
    where?: praktikumWhereInput
    data: XOR<praktikumUpdateWithoutModulInput, praktikumUncheckedUpdateWithoutModulInput>
  }

  export type praktikumUpdateWithoutModulInput = {
    nama_praktikum?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    lab?: labUpdateOneRequiredWithoutPraktikumNestedInput
    pendaftaran?: pendaftaranUpdateManyWithoutPraktikumNestedInput
    jadwal?: jadwalUpdateManyWithoutPraktikumNestedInput
    tugas?: tugasUpdateManyWithoutPraktikumNestedInput
    pengumuman?: pengumumanUpdateManyWithoutPraktikumNestedInput
  }

  export type praktikumUncheckedUpdateWithoutModulInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_praktikum?: StringFieldUpdateOperationsInput | string
    lab_id?: IntFieldUpdateOperationsInput | number
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    pendaftaran?: pendaftaranUncheckedUpdateManyWithoutPraktikumNestedInput
    jadwal?: jadwalUncheckedUpdateManyWithoutPraktikumNestedInput
    tugas?: tugasUncheckedUpdateManyWithoutPraktikumNestedInput
    pengumuman?: pengumumanUncheckedUpdateManyWithoutPraktikumNestedInput
  }

  export type userUpsertWithoutModulInput = {
    update: XOR<userUpdateWithoutModulInput, userUncheckedUpdateWithoutModulInput>
    create: XOR<userCreateWithoutModulInput, userUncheckedCreateWithoutModulInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutModulInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutModulInput, userUncheckedUpdateWithoutModulInput>
  }

  export type userUpdateWithoutModulInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    kata_sandi?: StringFieldUpdateOperationsInput | string
    peran?: EnumPeranFieldUpdateOperationsInput | $Enums.Peran
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    pendaftaran?: pendaftaranUpdateManyWithoutUserNestedInput
    jadwal?: jadwalUpdateManyWithoutUserNestedInput
    pengumpulan?: pengumpulanUpdateManyWithoutUserNestedInput
    pengumuman?: pengumumanUpdateManyWithoutPembuatNestedInput
    absensi?: absensiUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutModulInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    kata_sandi?: StringFieldUpdateOperationsInput | string
    peran?: EnumPeranFieldUpdateOperationsInput | $Enums.Peran
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    pendaftaran?: pendaftaranUncheckedUpdateManyWithoutUserNestedInput
    jadwal?: jadwalUncheckedUpdateManyWithoutUserNestedInput
    pengumpulan?: pengumpulanUncheckedUpdateManyWithoutUserNestedInput
    pengumuman?: pengumumanUncheckedUpdateManyWithoutPembuatNestedInput
    absensi?: absensiUncheckedUpdateManyWithoutUserNestedInput
  }

  export type praktikumCreateWithoutTugasInput = {
    nama_praktikum: string
    dibuat_pada?: Date | string
    lab: labCreateNestedOneWithoutPraktikumInput
    pendaftaran?: pendaftaranCreateNestedManyWithoutPraktikumInput
    jadwal?: jadwalCreateNestedManyWithoutPraktikumInput
    modul?: modulCreateNestedManyWithoutPraktikumInput
    pengumuman?: pengumumanCreateNestedManyWithoutPraktikumInput
  }

  export type praktikumUncheckedCreateWithoutTugasInput = {
    id?: number
    nama_praktikum: string
    lab_id: number
    dibuat_pada?: Date | string
    pendaftaran?: pendaftaranUncheckedCreateNestedManyWithoutPraktikumInput
    jadwal?: jadwalUncheckedCreateNestedManyWithoutPraktikumInput
    modul?: modulUncheckedCreateNestedManyWithoutPraktikumInput
    pengumuman?: pengumumanUncheckedCreateNestedManyWithoutPraktikumInput
  }

  export type praktikumCreateOrConnectWithoutTugasInput = {
    where: praktikumWhereUniqueInput
    create: XOR<praktikumCreateWithoutTugasInput, praktikumUncheckedCreateWithoutTugasInput>
  }

  export type pengumpulanCreateWithoutTugasInput = {
    file_path?: string | null
    waktu_kirim?: Date | string | null
    nilai?: number | null
    catatan?: string | null
    user: userCreateNestedOneWithoutPengumpulanInput
  }

  export type pengumpulanUncheckedCreateWithoutTugasInput = {
    id?: number
    user_id: string
    file_path?: string | null
    waktu_kirim?: Date | string | null
    nilai?: number | null
    catatan?: string | null
  }

  export type pengumpulanCreateOrConnectWithoutTugasInput = {
    where: pengumpulanWhereUniqueInput
    create: XOR<pengumpulanCreateWithoutTugasInput, pengumpulanUncheckedCreateWithoutTugasInput>
  }

  export type pengumpulanCreateManyTugasInputEnvelope = {
    data: pengumpulanCreateManyTugasInput | pengumpulanCreateManyTugasInput[]
    skipDuplicates?: boolean
  }

  export type praktikumUpsertWithoutTugasInput = {
    update: XOR<praktikumUpdateWithoutTugasInput, praktikumUncheckedUpdateWithoutTugasInput>
    create: XOR<praktikumCreateWithoutTugasInput, praktikumUncheckedCreateWithoutTugasInput>
    where?: praktikumWhereInput
  }

  export type praktikumUpdateToOneWithWhereWithoutTugasInput = {
    where?: praktikumWhereInput
    data: XOR<praktikumUpdateWithoutTugasInput, praktikumUncheckedUpdateWithoutTugasInput>
  }

  export type praktikumUpdateWithoutTugasInput = {
    nama_praktikum?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    lab?: labUpdateOneRequiredWithoutPraktikumNestedInput
    pendaftaran?: pendaftaranUpdateManyWithoutPraktikumNestedInput
    jadwal?: jadwalUpdateManyWithoutPraktikumNestedInput
    modul?: modulUpdateManyWithoutPraktikumNestedInput
    pengumuman?: pengumumanUpdateManyWithoutPraktikumNestedInput
  }

  export type praktikumUncheckedUpdateWithoutTugasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_praktikum?: StringFieldUpdateOperationsInput | string
    lab_id?: IntFieldUpdateOperationsInput | number
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    pendaftaran?: pendaftaranUncheckedUpdateManyWithoutPraktikumNestedInput
    jadwal?: jadwalUncheckedUpdateManyWithoutPraktikumNestedInput
    modul?: modulUncheckedUpdateManyWithoutPraktikumNestedInput
    pengumuman?: pengumumanUncheckedUpdateManyWithoutPraktikumNestedInput
  }

  export type pengumpulanUpsertWithWhereUniqueWithoutTugasInput = {
    where: pengumpulanWhereUniqueInput
    update: XOR<pengumpulanUpdateWithoutTugasInput, pengumpulanUncheckedUpdateWithoutTugasInput>
    create: XOR<pengumpulanCreateWithoutTugasInput, pengumpulanUncheckedCreateWithoutTugasInput>
  }

  export type pengumpulanUpdateWithWhereUniqueWithoutTugasInput = {
    where: pengumpulanWhereUniqueInput
    data: XOR<pengumpulanUpdateWithoutTugasInput, pengumpulanUncheckedUpdateWithoutTugasInput>
  }

  export type pengumpulanUpdateManyWithWhereWithoutTugasInput = {
    where: pengumpulanScalarWhereInput
    data: XOR<pengumpulanUpdateManyMutationInput, pengumpulanUncheckedUpdateManyWithoutTugasInput>
  }

  export type tugasCreateWithoutPengumpulanInput = {
    judul: string
    deskripsi?: string | null
    fileTugas?: string | null
    batas_waktu: Date | string
    dibuat_pada?: Date | string
    status?: $Enums.StatusTugas
    praktikum: praktikumCreateNestedOneWithoutTugasInput
  }

  export type tugasUncheckedCreateWithoutPengumpulanInput = {
    id?: number
    praktikum_id: number
    judul: string
    deskripsi?: string | null
    fileTugas?: string | null
    batas_waktu: Date | string
    dibuat_pada?: Date | string
    status?: $Enums.StatusTugas
  }

  export type tugasCreateOrConnectWithoutPengumpulanInput = {
    where: tugasWhereUniqueInput
    create: XOR<tugasCreateWithoutPengumpulanInput, tugasUncheckedCreateWithoutPengumpulanInput>
  }

  export type userCreateWithoutPengumpulanInput = {
    id: string
    username: string
    kata_sandi: string
    peran: $Enums.Peran
    dibuat_pada?: Date | string
    pendaftaran?: pendaftaranCreateNestedManyWithoutUserInput
    jadwal?: jadwalCreateNestedManyWithoutUserInput
    modul?: modulCreateNestedManyWithoutUserInput
    pengumuman?: pengumumanCreateNestedManyWithoutPembuatInput
    absensi?: absensiCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutPengumpulanInput = {
    id: string
    username: string
    kata_sandi: string
    peran: $Enums.Peran
    dibuat_pada?: Date | string
    pendaftaran?: pendaftaranUncheckedCreateNestedManyWithoutUserInput
    jadwal?: jadwalUncheckedCreateNestedManyWithoutUserInput
    modul?: modulUncheckedCreateNestedManyWithoutUserInput
    pengumuman?: pengumumanUncheckedCreateNestedManyWithoutPembuatInput
    absensi?: absensiUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPengumpulanInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPengumpulanInput, userUncheckedCreateWithoutPengumpulanInput>
  }

  export type tugasUpsertWithoutPengumpulanInput = {
    update: XOR<tugasUpdateWithoutPengumpulanInput, tugasUncheckedUpdateWithoutPengumpulanInput>
    create: XOR<tugasCreateWithoutPengumpulanInput, tugasUncheckedCreateWithoutPengumpulanInput>
    where?: tugasWhereInput
  }

  export type tugasUpdateToOneWithWhereWithoutPengumpulanInput = {
    where?: tugasWhereInput
    data: XOR<tugasUpdateWithoutPengumpulanInput, tugasUncheckedUpdateWithoutPengumpulanInput>
  }

  export type tugasUpdateWithoutPengumpulanInput = {
    judul?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    fileTugas?: NullableStringFieldUpdateOperationsInput | string | null
    batas_waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusTugasFieldUpdateOperationsInput | $Enums.StatusTugas
    praktikum?: praktikumUpdateOneRequiredWithoutTugasNestedInput
  }

  export type tugasUncheckedUpdateWithoutPengumpulanInput = {
    id?: IntFieldUpdateOperationsInput | number
    praktikum_id?: IntFieldUpdateOperationsInput | number
    judul?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    fileTugas?: NullableStringFieldUpdateOperationsInput | string | null
    batas_waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusTugasFieldUpdateOperationsInput | $Enums.StatusTugas
  }

  export type userUpsertWithoutPengumpulanInput = {
    update: XOR<userUpdateWithoutPengumpulanInput, userUncheckedUpdateWithoutPengumpulanInput>
    create: XOR<userCreateWithoutPengumpulanInput, userUncheckedCreateWithoutPengumpulanInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPengumpulanInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPengumpulanInput, userUncheckedUpdateWithoutPengumpulanInput>
  }

  export type userUpdateWithoutPengumpulanInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    kata_sandi?: StringFieldUpdateOperationsInput | string
    peran?: EnumPeranFieldUpdateOperationsInput | $Enums.Peran
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    pendaftaran?: pendaftaranUpdateManyWithoutUserNestedInput
    jadwal?: jadwalUpdateManyWithoutUserNestedInput
    modul?: modulUpdateManyWithoutUserNestedInput
    pengumuman?: pengumumanUpdateManyWithoutPembuatNestedInput
    absensi?: absensiUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPengumpulanInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    kata_sandi?: StringFieldUpdateOperationsInput | string
    peran?: EnumPeranFieldUpdateOperationsInput | $Enums.Peran
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    pendaftaran?: pendaftaranUncheckedUpdateManyWithoutUserNestedInput
    jadwal?: jadwalUncheckedUpdateManyWithoutUserNestedInput
    modul?: modulUncheckedUpdateManyWithoutUserNestedInput
    pengumuman?: pengumumanUncheckedUpdateManyWithoutPembuatNestedInput
    absensi?: absensiUncheckedUpdateManyWithoutUserNestedInput
  }

  export type praktikumCreateWithoutPengumumanInput = {
    nama_praktikum: string
    dibuat_pada?: Date | string
    lab: labCreateNestedOneWithoutPraktikumInput
    pendaftaran?: pendaftaranCreateNestedManyWithoutPraktikumInput
    jadwal?: jadwalCreateNestedManyWithoutPraktikumInput
    modul?: modulCreateNestedManyWithoutPraktikumInput
    tugas?: tugasCreateNestedManyWithoutPraktikumInput
  }

  export type praktikumUncheckedCreateWithoutPengumumanInput = {
    id?: number
    nama_praktikum: string
    lab_id: number
    dibuat_pada?: Date | string
    pendaftaran?: pendaftaranUncheckedCreateNestedManyWithoutPraktikumInput
    jadwal?: jadwalUncheckedCreateNestedManyWithoutPraktikumInput
    modul?: modulUncheckedCreateNestedManyWithoutPraktikumInput
    tugas?: tugasUncheckedCreateNestedManyWithoutPraktikumInput
  }

  export type praktikumCreateOrConnectWithoutPengumumanInput = {
    where: praktikumWhereUniqueInput
    create: XOR<praktikumCreateWithoutPengumumanInput, praktikumUncheckedCreateWithoutPengumumanInput>
  }

  export type userCreateWithoutPengumumanInput = {
    id: string
    username: string
    kata_sandi: string
    peran: $Enums.Peran
    dibuat_pada?: Date | string
    pendaftaran?: pendaftaranCreateNestedManyWithoutUserInput
    jadwal?: jadwalCreateNestedManyWithoutUserInput
    modul?: modulCreateNestedManyWithoutUserInput
    pengumpulan?: pengumpulanCreateNestedManyWithoutUserInput
    absensi?: absensiCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutPengumumanInput = {
    id: string
    username: string
    kata_sandi: string
    peran: $Enums.Peran
    dibuat_pada?: Date | string
    pendaftaran?: pendaftaranUncheckedCreateNestedManyWithoutUserInput
    jadwal?: jadwalUncheckedCreateNestedManyWithoutUserInput
    modul?: modulUncheckedCreateNestedManyWithoutUserInput
    pengumpulan?: pengumpulanUncheckedCreateNestedManyWithoutUserInput
    absensi?: absensiUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPengumumanInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPengumumanInput, userUncheckedCreateWithoutPengumumanInput>
  }

  export type praktikumUpsertWithoutPengumumanInput = {
    update: XOR<praktikumUpdateWithoutPengumumanInput, praktikumUncheckedUpdateWithoutPengumumanInput>
    create: XOR<praktikumCreateWithoutPengumumanInput, praktikumUncheckedCreateWithoutPengumumanInput>
    where?: praktikumWhereInput
  }

  export type praktikumUpdateToOneWithWhereWithoutPengumumanInput = {
    where?: praktikumWhereInput
    data: XOR<praktikumUpdateWithoutPengumumanInput, praktikumUncheckedUpdateWithoutPengumumanInput>
  }

  export type praktikumUpdateWithoutPengumumanInput = {
    nama_praktikum?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    lab?: labUpdateOneRequiredWithoutPraktikumNestedInput
    pendaftaran?: pendaftaranUpdateManyWithoutPraktikumNestedInput
    jadwal?: jadwalUpdateManyWithoutPraktikumNestedInput
    modul?: modulUpdateManyWithoutPraktikumNestedInput
    tugas?: tugasUpdateManyWithoutPraktikumNestedInput
  }

  export type praktikumUncheckedUpdateWithoutPengumumanInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_praktikum?: StringFieldUpdateOperationsInput | string
    lab_id?: IntFieldUpdateOperationsInput | number
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    pendaftaran?: pendaftaranUncheckedUpdateManyWithoutPraktikumNestedInput
    jadwal?: jadwalUncheckedUpdateManyWithoutPraktikumNestedInput
    modul?: modulUncheckedUpdateManyWithoutPraktikumNestedInput
    tugas?: tugasUncheckedUpdateManyWithoutPraktikumNestedInput
  }

  export type userUpsertWithoutPengumumanInput = {
    update: XOR<userUpdateWithoutPengumumanInput, userUncheckedUpdateWithoutPengumumanInput>
    create: XOR<userCreateWithoutPengumumanInput, userUncheckedCreateWithoutPengumumanInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPengumumanInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPengumumanInput, userUncheckedUpdateWithoutPengumumanInput>
  }

  export type userUpdateWithoutPengumumanInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    kata_sandi?: StringFieldUpdateOperationsInput | string
    peran?: EnumPeranFieldUpdateOperationsInput | $Enums.Peran
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    pendaftaran?: pendaftaranUpdateManyWithoutUserNestedInput
    jadwal?: jadwalUpdateManyWithoutUserNestedInput
    modul?: modulUpdateManyWithoutUserNestedInput
    pengumpulan?: pengumpulanUpdateManyWithoutUserNestedInput
    absensi?: absensiUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPengumumanInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    kata_sandi?: StringFieldUpdateOperationsInput | string
    peran?: EnumPeranFieldUpdateOperationsInput | $Enums.Peran
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    pendaftaran?: pendaftaranUncheckedUpdateManyWithoutUserNestedInput
    jadwal?: jadwalUncheckedUpdateManyWithoutUserNestedInput
    modul?: modulUncheckedUpdateManyWithoutUserNestedInput
    pengumpulan?: pengumpulanUncheckedUpdateManyWithoutUserNestedInput
    absensi?: absensiUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutAbsensiInput = {
    id: string
    username: string
    kata_sandi: string
    peran: $Enums.Peran
    dibuat_pada?: Date | string
    pendaftaran?: pendaftaranCreateNestedManyWithoutUserInput
    jadwal?: jadwalCreateNestedManyWithoutUserInput
    modul?: modulCreateNestedManyWithoutUserInput
    pengumpulan?: pengumpulanCreateNestedManyWithoutUserInput
    pengumuman?: pengumumanCreateNestedManyWithoutPembuatInput
  }

  export type userUncheckedCreateWithoutAbsensiInput = {
    id: string
    username: string
    kata_sandi: string
    peran: $Enums.Peran
    dibuat_pada?: Date | string
    pendaftaran?: pendaftaranUncheckedCreateNestedManyWithoutUserInput
    jadwal?: jadwalUncheckedCreateNestedManyWithoutUserInput
    modul?: modulUncheckedCreateNestedManyWithoutUserInput
    pengumpulan?: pengumpulanUncheckedCreateNestedManyWithoutUserInput
    pengumuman?: pengumumanUncheckedCreateNestedManyWithoutPembuatInput
  }

  export type userCreateOrConnectWithoutAbsensiInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAbsensiInput, userUncheckedCreateWithoutAbsensiInput>
  }

  export type jadwalCreateWithoutAbsensiInput = {
    tanggal: Date | string
    jam: Date | string
    ruangan?: string | null
    nama_pengajar?: string | null
    dibuat_pada?: Date | string | null
    praktikum: praktikumCreateNestedOneWithoutJadwalInput
    user: userCreateNestedOneWithoutJadwalInput
  }

  export type jadwalUncheckedCreateWithoutAbsensiInput = {
    id?: number
    praktikum_id: number
    tanggal: Date | string
    jam: Date | string
    ruangan?: string | null
    user_id: string
    nama_pengajar?: string | null
    dibuat_pada?: Date | string | null
  }

  export type jadwalCreateOrConnectWithoutAbsensiInput = {
    where: jadwalWhereUniqueInput
    create: XOR<jadwalCreateWithoutAbsensiInput, jadwalUncheckedCreateWithoutAbsensiInput>
  }

  export type userUpsertWithoutAbsensiInput = {
    update: XOR<userUpdateWithoutAbsensiInput, userUncheckedUpdateWithoutAbsensiInput>
    create: XOR<userCreateWithoutAbsensiInput, userUncheckedCreateWithoutAbsensiInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutAbsensiInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutAbsensiInput, userUncheckedUpdateWithoutAbsensiInput>
  }

  export type userUpdateWithoutAbsensiInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    kata_sandi?: StringFieldUpdateOperationsInput | string
    peran?: EnumPeranFieldUpdateOperationsInput | $Enums.Peran
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    pendaftaran?: pendaftaranUpdateManyWithoutUserNestedInput
    jadwal?: jadwalUpdateManyWithoutUserNestedInput
    modul?: modulUpdateManyWithoutUserNestedInput
    pengumpulan?: pengumpulanUpdateManyWithoutUserNestedInput
    pengumuman?: pengumumanUpdateManyWithoutPembuatNestedInput
  }

  export type userUncheckedUpdateWithoutAbsensiInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    kata_sandi?: StringFieldUpdateOperationsInput | string
    peran?: EnumPeranFieldUpdateOperationsInput | $Enums.Peran
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    pendaftaran?: pendaftaranUncheckedUpdateManyWithoutUserNestedInput
    jadwal?: jadwalUncheckedUpdateManyWithoutUserNestedInput
    modul?: modulUncheckedUpdateManyWithoutUserNestedInput
    pengumpulan?: pengumpulanUncheckedUpdateManyWithoutUserNestedInput
    pengumuman?: pengumumanUncheckedUpdateManyWithoutPembuatNestedInput
  }

  export type jadwalUpsertWithoutAbsensiInput = {
    update: XOR<jadwalUpdateWithoutAbsensiInput, jadwalUncheckedUpdateWithoutAbsensiInput>
    create: XOR<jadwalCreateWithoutAbsensiInput, jadwalUncheckedCreateWithoutAbsensiInput>
    where?: jadwalWhereInput
  }

  export type jadwalUpdateToOneWithWhereWithoutAbsensiInput = {
    where?: jadwalWhereInput
    data: XOR<jadwalUpdateWithoutAbsensiInput, jadwalUncheckedUpdateWithoutAbsensiInput>
  }

  export type jadwalUpdateWithoutAbsensiInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam?: DateTimeFieldUpdateOperationsInput | Date | string
    ruangan?: NullableStringFieldUpdateOperationsInput | string | null
    nama_pengajar?: NullableStringFieldUpdateOperationsInput | string | null
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    praktikum?: praktikumUpdateOneRequiredWithoutJadwalNestedInput
    user?: userUpdateOneRequiredWithoutJadwalNestedInput
  }

  export type jadwalUncheckedUpdateWithoutAbsensiInput = {
    id?: IntFieldUpdateOperationsInput | number
    praktikum_id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam?: DateTimeFieldUpdateOperationsInput | Date | string
    ruangan?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    nama_pengajar?: NullableStringFieldUpdateOperationsInput | string | null
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pendaftaranCreateManyUserInput = {
    id?: number
    praktikum_id: number
    waktu_daftar?: Date | string | null
  }

  export type jadwalCreateManyUserInput = {
    id?: number
    praktikum_id: number
    tanggal: Date | string
    jam: Date | string
    ruangan?: string | null
    nama_pengajar?: string | null
    dibuat_pada?: Date | string | null
  }

  export type modulCreateManyUserInput = {
    id?: number
    praktikum_id: number
    judul: string
    file_path: string
    diunggah_pada?: Date | string | null
  }

  export type pengumpulanCreateManyUserInput = {
    id?: number
    tugas_id: number
    file_path?: string | null
    waktu_kirim?: Date | string | null
    nilai?: number | null
    catatan?: string | null
  }

  export type pengumumanCreateManyPembuatInput = {
    id?: number
    praktikum_id: number
    isi: string
    dibuat_pada?: Date | string | null
  }

  export type absensiCreateManyUserInput = {
    id?: number
    jadwal_id: number
    status: $Enums.StatusAbsensi
  }

  export type pendaftaranUpdateWithoutUserInput = {
    waktu_daftar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    praktikum?: praktikumUpdateOneRequiredWithoutPendaftaranNestedInput
  }

  export type pendaftaranUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    praktikum_id?: IntFieldUpdateOperationsInput | number
    waktu_daftar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pendaftaranUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    praktikum_id?: IntFieldUpdateOperationsInput | number
    waktu_daftar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type jadwalUpdateWithoutUserInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam?: DateTimeFieldUpdateOperationsInput | Date | string
    ruangan?: NullableStringFieldUpdateOperationsInput | string | null
    nama_pengajar?: NullableStringFieldUpdateOperationsInput | string | null
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    praktikum?: praktikumUpdateOneRequiredWithoutJadwalNestedInput
    absensi?: absensiUpdateManyWithoutJadwalNestedInput
  }

  export type jadwalUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    praktikum_id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam?: DateTimeFieldUpdateOperationsInput | Date | string
    ruangan?: NullableStringFieldUpdateOperationsInput | string | null
    nama_pengajar?: NullableStringFieldUpdateOperationsInput | string | null
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    absensi?: absensiUncheckedUpdateManyWithoutJadwalNestedInput
  }

  export type jadwalUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    praktikum_id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam?: DateTimeFieldUpdateOperationsInput | Date | string
    ruangan?: NullableStringFieldUpdateOperationsInput | string | null
    nama_pengajar?: NullableStringFieldUpdateOperationsInput | string | null
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type modulUpdateWithoutUserInput = {
    judul?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    diunggah_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    praktikum?: praktikumUpdateOneRequiredWithoutModulNestedInput
  }

  export type modulUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    praktikum_id?: IntFieldUpdateOperationsInput | number
    judul?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    diunggah_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type modulUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    praktikum_id?: IntFieldUpdateOperationsInput | number
    judul?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    diunggah_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pengumpulanUpdateWithoutUserInput = {
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_kirim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nilai?: NullableFloatFieldUpdateOperationsInput | number | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    tugas?: tugasUpdateOneRequiredWithoutPengumpulanNestedInput
  }

  export type pengumpulanUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tugas_id?: IntFieldUpdateOperationsInput | number
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_kirim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nilai?: NullableFloatFieldUpdateOperationsInput | number | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pengumpulanUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    tugas_id?: IntFieldUpdateOperationsInput | number
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_kirim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nilai?: NullableFloatFieldUpdateOperationsInput | number | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pengumumanUpdateWithoutPembuatInput = {
    isi?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    praktikum?: praktikumUpdateOneRequiredWithoutPengumumanNestedInput
  }

  export type pengumumanUncheckedUpdateWithoutPembuatInput = {
    id?: IntFieldUpdateOperationsInput | number
    praktikum_id?: IntFieldUpdateOperationsInput | number
    isi?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pengumumanUncheckedUpdateManyWithoutPembuatInput = {
    id?: IntFieldUpdateOperationsInput | number
    praktikum_id?: IntFieldUpdateOperationsInput | number
    isi?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type absensiUpdateWithoutUserInput = {
    status?: EnumStatusAbsensiFieldUpdateOperationsInput | $Enums.StatusAbsensi
    jadwal?: jadwalUpdateOneRequiredWithoutAbsensiNestedInput
  }

  export type absensiUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    jadwal_id?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusAbsensiFieldUpdateOperationsInput | $Enums.StatusAbsensi
  }

  export type absensiUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    jadwal_id?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusAbsensiFieldUpdateOperationsInput | $Enums.StatusAbsensi
  }

  export type praktikumCreateManyLabInput = {
    id?: number
    nama_praktikum: string
    dibuat_pada?: Date | string
  }

  export type praktikumUpdateWithoutLabInput = {
    nama_praktikum?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    pendaftaran?: pendaftaranUpdateManyWithoutPraktikumNestedInput
    jadwal?: jadwalUpdateManyWithoutPraktikumNestedInput
    modul?: modulUpdateManyWithoutPraktikumNestedInput
    tugas?: tugasUpdateManyWithoutPraktikumNestedInput
    pengumuman?: pengumumanUpdateManyWithoutPraktikumNestedInput
  }

  export type praktikumUncheckedUpdateWithoutLabInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_praktikum?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    pendaftaran?: pendaftaranUncheckedUpdateManyWithoutPraktikumNestedInput
    jadwal?: jadwalUncheckedUpdateManyWithoutPraktikumNestedInput
    modul?: modulUncheckedUpdateManyWithoutPraktikumNestedInput
    tugas?: tugasUncheckedUpdateManyWithoutPraktikumNestedInput
    pengumuman?: pengumumanUncheckedUpdateManyWithoutPraktikumNestedInput
  }

  export type praktikumUncheckedUpdateManyWithoutLabInput = {
    id?: IntFieldUpdateOperationsInput | number
    nama_praktikum?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pendaftaranCreateManyPraktikumInput = {
    id?: number
    user_id: string
    waktu_daftar?: Date | string | null
  }

  export type jadwalCreateManyPraktikumInput = {
    id?: number
    tanggal: Date | string
    jam: Date | string
    ruangan?: string | null
    user_id: string
    nama_pengajar?: string | null
    dibuat_pada?: Date | string | null
  }

  export type modulCreateManyPraktikumInput = {
    id?: number
    judul: string
    file_path: string
    diunggah_oleh: string
    diunggah_pada?: Date | string | null
  }

  export type tugasCreateManyPraktikumInput = {
    id?: number
    judul: string
    deskripsi?: string | null
    fileTugas?: string | null
    batas_waktu: Date | string
    dibuat_pada?: Date | string
    status?: $Enums.StatusTugas
  }

  export type pengumumanCreateManyPraktikumInput = {
    id?: number
    isi: string
    dibuat_oleh: string
    dibuat_pada?: Date | string | null
  }

  export type pendaftaranUpdateWithoutPraktikumInput = {
    waktu_daftar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutPendaftaranNestedInput
  }

  export type pendaftaranUncheckedUpdateWithoutPraktikumInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    waktu_daftar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pendaftaranUncheckedUpdateManyWithoutPraktikumInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    waktu_daftar?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type jadwalUpdateWithoutPraktikumInput = {
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam?: DateTimeFieldUpdateOperationsInput | Date | string
    ruangan?: NullableStringFieldUpdateOperationsInput | string | null
    nama_pengajar?: NullableStringFieldUpdateOperationsInput | string | null
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutJadwalNestedInput
    absensi?: absensiUpdateManyWithoutJadwalNestedInput
  }

  export type jadwalUncheckedUpdateWithoutPraktikumInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam?: DateTimeFieldUpdateOperationsInput | Date | string
    ruangan?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    nama_pengajar?: NullableStringFieldUpdateOperationsInput | string | null
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    absensi?: absensiUncheckedUpdateManyWithoutJadwalNestedInput
  }

  export type jadwalUncheckedUpdateManyWithoutPraktikumInput = {
    id?: IntFieldUpdateOperationsInput | number
    tanggal?: DateTimeFieldUpdateOperationsInput | Date | string
    jam?: DateTimeFieldUpdateOperationsInput | Date | string
    ruangan?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    nama_pengajar?: NullableStringFieldUpdateOperationsInput | string | null
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type modulUpdateWithoutPraktikumInput = {
    judul?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    diunggah_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutModulNestedInput
  }

  export type modulUncheckedUpdateWithoutPraktikumInput = {
    id?: IntFieldUpdateOperationsInput | number
    judul?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    diunggah_oleh?: StringFieldUpdateOperationsInput | string
    diunggah_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type modulUncheckedUpdateManyWithoutPraktikumInput = {
    id?: IntFieldUpdateOperationsInput | number
    judul?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    diunggah_oleh?: StringFieldUpdateOperationsInput | string
    diunggah_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tugasUpdateWithoutPraktikumInput = {
    judul?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    fileTugas?: NullableStringFieldUpdateOperationsInput | string | null
    batas_waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusTugasFieldUpdateOperationsInput | $Enums.StatusTugas
    pengumpulan?: pengumpulanUpdateManyWithoutTugasNestedInput
  }

  export type tugasUncheckedUpdateWithoutPraktikumInput = {
    id?: IntFieldUpdateOperationsInput | number
    judul?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    fileTugas?: NullableStringFieldUpdateOperationsInput | string | null
    batas_waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusTugasFieldUpdateOperationsInput | $Enums.StatusTugas
    pengumpulan?: pengumpulanUncheckedUpdateManyWithoutTugasNestedInput
  }

  export type tugasUncheckedUpdateManyWithoutPraktikumInput = {
    id?: IntFieldUpdateOperationsInput | number
    judul?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    fileTugas?: NullableStringFieldUpdateOperationsInput | string | null
    batas_waktu?: DateTimeFieldUpdateOperationsInput | Date | string
    dibuat_pada?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusTugasFieldUpdateOperationsInput | $Enums.StatusTugas
  }

  export type pengumumanUpdateWithoutPraktikumInput = {
    isi?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pembuat?: userUpdateOneRequiredWithoutPengumumanNestedInput
  }

  export type pengumumanUncheckedUpdateWithoutPraktikumInput = {
    id?: IntFieldUpdateOperationsInput | number
    isi?: StringFieldUpdateOperationsInput | string
    dibuat_oleh?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pengumumanUncheckedUpdateManyWithoutPraktikumInput = {
    id?: IntFieldUpdateOperationsInput | number
    isi?: StringFieldUpdateOperationsInput | string
    dibuat_oleh?: StringFieldUpdateOperationsInput | string
    dibuat_pada?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type absensiCreateManyJadwalInput = {
    id?: number
    user_id: string
    status: $Enums.StatusAbsensi
  }

  export type absensiUpdateWithoutJadwalInput = {
    status?: EnumStatusAbsensiFieldUpdateOperationsInput | $Enums.StatusAbsensi
    user?: userUpdateOneRequiredWithoutAbsensiNestedInput
  }

  export type absensiUncheckedUpdateWithoutJadwalInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAbsensiFieldUpdateOperationsInput | $Enums.StatusAbsensi
  }

  export type absensiUncheckedUpdateManyWithoutJadwalInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusAbsensiFieldUpdateOperationsInput | $Enums.StatusAbsensi
  }

  export type pengumpulanCreateManyTugasInput = {
    id?: number
    user_id: string
    file_path?: string | null
    waktu_kirim?: Date | string | null
    nilai?: number | null
    catatan?: string | null
  }

  export type pengumpulanUpdateWithoutTugasInput = {
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_kirim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nilai?: NullableFloatFieldUpdateOperationsInput | number | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneRequiredWithoutPengumpulanNestedInput
  }

  export type pengumpulanUncheckedUpdateWithoutTugasInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_kirim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nilai?: NullableFloatFieldUpdateOperationsInput | number | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pengumpulanUncheckedUpdateManyWithoutTugasInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    waktu_kirim?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nilai?: NullableFloatFieldUpdateOperationsInput | number | null
    catatan?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}